/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/js/";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 0);
/******/ })
/************************************************************************/
/******/ ({

/***/ "../deps/phoenix/priv/static/phoenix.js":
/*!**********************************************!*\
  !*** ../deps/phoenix/priv/static/phoenix.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var Phoenix = (() => {\n  var __defProp = Object.defineProperty;\n\n  var __markAsModule = target => __defProp(target, \"__esModule\", {\n    value: true\n  });\n\n  var __export = (target, all) => {\n    __markAsModule(target);\n\n    for (var name in all) __defProp(target, name, {\n      get: all[name],\n      enumerable: true\n    });\n  }; // js/phoenix/index.js\n\n\n  var phoenix_exports = {};\n\n  __export(phoenix_exports, {\n    Channel: () => Channel,\n    LongPoll: () => LongPoll,\n    Presence: () => Presence,\n    Serializer: () => serializer_default,\n    Socket: () => Socket\n  }); // js/phoenix/utils.js\n\n\n  var closure = value => {\n    if (typeof value === \"function\") {\n      return value;\n    } else {\n      let closure2 = function () {\n        return value;\n      };\n\n      return closure2;\n    }\n  }; // js/phoenix/constants.js\n\n\n  var globalSelf = typeof self !== \"undefined\" ? self : null;\n  var phxWindow = typeof window !== \"undefined\" ? window : null;\n  var global = globalSelf || phxWindow || void 0;\n  var DEFAULT_VSN = \"2.0.0\";\n  var SOCKET_STATES = {\n    connecting: 0,\n    open: 1,\n    closing: 2,\n    closed: 3\n  };\n  var DEFAULT_TIMEOUT = 1e4;\n  var WS_CLOSE_NORMAL = 1e3;\n  var CHANNEL_STATES = {\n    closed: \"closed\",\n    errored: \"errored\",\n    joined: \"joined\",\n    joining: \"joining\",\n    leaving: \"leaving\"\n  };\n  var CHANNEL_EVENTS = {\n    close: \"phx_close\",\n    error: \"phx_error\",\n    join: \"phx_join\",\n    reply: \"phx_reply\",\n    leave: \"phx_leave\"\n  };\n  var TRANSPORTS = {\n    longpoll: \"longpoll\",\n    websocket: \"websocket\"\n  };\n  var XHR_STATES = {\n    complete: 4\n  }; // js/phoenix/push.js\n\n  var Push = class {\n    constructor(channel, event, payload, timeout) {\n      this.channel = channel;\n      this.event = event;\n\n      this.payload = payload || function () {\n        return {};\n      };\n\n      this.receivedResp = null;\n      this.timeout = timeout;\n      this.timeoutTimer = null;\n      this.recHooks = [];\n      this.sent = false;\n    }\n\n    resend(timeout) {\n      this.timeout = timeout;\n      this.reset();\n      this.send();\n    }\n\n    send() {\n      if (this.hasReceived(\"timeout\")) {\n        return;\n      }\n\n      this.startTimeout();\n      this.sent = true;\n      this.channel.socket.push({\n        topic: this.channel.topic,\n        event: this.event,\n        payload: this.payload(),\n        ref: this.ref,\n        join_ref: this.channel.joinRef()\n      });\n    }\n\n    receive(status, callback) {\n      if (this.hasReceived(status)) {\n        callback(this.receivedResp.response);\n      }\n\n      this.recHooks.push({\n        status,\n        callback\n      });\n      return this;\n    }\n\n    reset() {\n      this.cancelRefEvent();\n      this.ref = null;\n      this.refEvent = null;\n      this.receivedResp = null;\n      this.sent = false;\n    }\n\n    matchReceive({\n      status,\n      response,\n      _ref\n    }) {\n      this.recHooks.filter(h => h.status === status).forEach(h => h.callback(response));\n    }\n\n    cancelRefEvent() {\n      if (!this.refEvent) {\n        return;\n      }\n\n      this.channel.off(this.refEvent);\n    }\n\n    cancelTimeout() {\n      clearTimeout(this.timeoutTimer);\n      this.timeoutTimer = null;\n    }\n\n    startTimeout() {\n      if (this.timeoutTimer) {\n        this.cancelTimeout();\n      }\n\n      this.ref = this.channel.socket.makeRef();\n      this.refEvent = this.channel.replyEventName(this.ref);\n      this.channel.on(this.refEvent, payload => {\n        this.cancelRefEvent();\n        this.cancelTimeout();\n        this.receivedResp = payload;\n        this.matchReceive(payload);\n      });\n      this.timeoutTimer = setTimeout(() => {\n        this.trigger(\"timeout\", {});\n      }, this.timeout);\n    }\n\n    hasReceived(status) {\n      return this.receivedResp && this.receivedResp.status === status;\n    }\n\n    trigger(status, response) {\n      this.channel.trigger(this.refEvent, {\n        status,\n        response\n      });\n    }\n\n  }; // js/phoenix/timer.js\n\n  var Timer = class {\n    constructor(callback, timerCalc) {\n      this.callback = callback;\n      this.timerCalc = timerCalc;\n      this.timer = null;\n      this.tries = 0;\n    }\n\n    reset() {\n      this.tries = 0;\n      clearTimeout(this.timer);\n    }\n\n    scheduleTimeout() {\n      clearTimeout(this.timer);\n      this.timer = setTimeout(() => {\n        this.tries = this.tries + 1;\n        this.callback();\n      }, this.timerCalc(this.tries + 1));\n    }\n\n  }; // js/phoenix/channel.js\n\n  var Channel = class {\n    constructor(topic, params, socket) {\n      this.state = CHANNEL_STATES.closed;\n      this.topic = topic;\n      this.params = closure(params || {});\n      this.socket = socket;\n      this.bindings = [];\n      this.bindingRef = 0;\n      this.timeout = this.socket.timeout;\n      this.joinedOnce = false;\n      this.joinPush = new Push(this, CHANNEL_EVENTS.join, this.params, this.timeout);\n      this.pushBuffer = [];\n      this.stateChangeRefs = [];\n      this.rejoinTimer = new Timer(() => {\n        if (this.socket.isConnected()) {\n          this.rejoin();\n        }\n      }, this.socket.rejoinAfterMs);\n      this.stateChangeRefs.push(this.socket.onError(() => this.rejoinTimer.reset()));\n      this.stateChangeRefs.push(this.socket.onOpen(() => {\n        this.rejoinTimer.reset();\n\n        if (this.isErrored()) {\n          this.rejoin();\n        }\n      }));\n      this.joinPush.receive(\"ok\", () => {\n        this.state = CHANNEL_STATES.joined;\n        this.rejoinTimer.reset();\n        this.pushBuffer.forEach(pushEvent => pushEvent.send());\n        this.pushBuffer = [];\n      });\n      this.joinPush.receive(\"error\", () => {\n        this.state = CHANNEL_STATES.errored;\n\n        if (this.socket.isConnected()) {\n          this.rejoinTimer.scheduleTimeout();\n        }\n      });\n      this.onClose(() => {\n        this.rejoinTimer.reset();\n        if (this.socket.hasLogger()) this.socket.log(\"channel\", `close ${this.topic} ${this.joinRef()}`);\n        this.state = CHANNEL_STATES.closed;\n        this.socket.remove(this);\n      });\n      this.onError(reason => {\n        if (this.socket.hasLogger()) this.socket.log(\"channel\", `error ${this.topic}`, reason);\n\n        if (this.isJoining()) {\n          this.joinPush.reset();\n        }\n\n        this.state = CHANNEL_STATES.errored;\n\n        if (this.socket.isConnected()) {\n          this.rejoinTimer.scheduleTimeout();\n        }\n      });\n      this.joinPush.receive(\"timeout\", () => {\n        if (this.socket.hasLogger()) this.socket.log(\"channel\", `timeout ${this.topic} (${this.joinRef()})`, this.joinPush.timeout);\n        let leavePush = new Push(this, CHANNEL_EVENTS.leave, closure({}), this.timeout);\n        leavePush.send();\n        this.state = CHANNEL_STATES.errored;\n        this.joinPush.reset();\n\n        if (this.socket.isConnected()) {\n          this.rejoinTimer.scheduleTimeout();\n        }\n      });\n      this.on(CHANNEL_EVENTS.reply, (payload, ref) => {\n        this.trigger(this.replyEventName(ref), payload);\n      });\n    }\n\n    join(timeout = this.timeout) {\n      if (this.joinedOnce) {\n        throw new Error(\"tried to join multiple times. 'join' can only be called a single time per channel instance\");\n      } else {\n        this.timeout = timeout;\n        this.joinedOnce = true;\n        this.rejoin();\n        return this.joinPush;\n      }\n    }\n\n    onClose(callback) {\n      this.on(CHANNEL_EVENTS.close, callback);\n    }\n\n    onError(callback) {\n      return this.on(CHANNEL_EVENTS.error, reason => callback(reason));\n    }\n\n    on(event, callback) {\n      let ref = this.bindingRef++;\n      this.bindings.push({\n        event,\n        ref,\n        callback\n      });\n      return ref;\n    }\n\n    off(event, ref) {\n      this.bindings = this.bindings.filter(bind => {\n        return !(bind.event === event && (typeof ref === \"undefined\" || ref === bind.ref));\n      });\n    }\n\n    canPush() {\n      return this.socket.isConnected() && this.isJoined();\n    }\n\n    push(event, payload, timeout = this.timeout) {\n      payload = payload || {};\n\n      if (!this.joinedOnce) {\n        throw new Error(`tried to push '${event}' to '${this.topic}' before joining. Use channel.join() before pushing events`);\n      }\n\n      let pushEvent = new Push(this, event, function () {\n        return payload;\n      }, timeout);\n\n      if (this.canPush()) {\n        pushEvent.send();\n      } else {\n        pushEvent.startTimeout();\n        this.pushBuffer.push(pushEvent);\n      }\n\n      return pushEvent;\n    }\n\n    leave(timeout = this.timeout) {\n      this.rejoinTimer.reset();\n      this.joinPush.cancelTimeout();\n      this.state = CHANNEL_STATES.leaving;\n\n      let onClose = () => {\n        if (this.socket.hasLogger()) this.socket.log(\"channel\", `leave ${this.topic}`);\n        this.trigger(CHANNEL_EVENTS.close, \"leave\");\n      };\n\n      let leavePush = new Push(this, CHANNEL_EVENTS.leave, closure({}), timeout);\n      leavePush.receive(\"ok\", () => onClose()).receive(\"timeout\", () => onClose());\n      leavePush.send();\n\n      if (!this.canPush()) {\n        leavePush.trigger(\"ok\", {});\n      }\n\n      return leavePush;\n    }\n\n    onMessage(_event, payload, _ref) {\n      return payload;\n    }\n\n    isMember(topic, event, payload, joinRef) {\n      if (this.topic !== topic) {\n        return false;\n      }\n\n      if (joinRef && joinRef !== this.joinRef()) {\n        if (this.socket.hasLogger()) this.socket.log(\"channel\", \"dropping outdated message\", {\n          topic,\n          event,\n          payload,\n          joinRef\n        });\n        return false;\n      } else {\n        return true;\n      }\n    }\n\n    joinRef() {\n      return this.joinPush.ref;\n    }\n\n    rejoin(timeout = this.timeout) {\n      if (this.isLeaving()) {\n        return;\n      }\n\n      this.socket.leaveOpenTopic(this.topic);\n      this.state = CHANNEL_STATES.joining;\n      this.joinPush.resend(timeout);\n    }\n\n    trigger(event, payload, ref, joinRef) {\n      let handledPayload = this.onMessage(event, payload, ref, joinRef);\n\n      if (payload && !handledPayload) {\n        throw new Error(\"channel onMessage callbacks must return the payload, modified or unmodified\");\n      }\n\n      let eventBindings = this.bindings.filter(bind => bind.event === event);\n\n      for (let i = 0; i < eventBindings.length; i++) {\n        let bind = eventBindings[i];\n        bind.callback(handledPayload, ref, joinRef || this.joinRef());\n      }\n    }\n\n    replyEventName(ref) {\n      return `chan_reply_${ref}`;\n    }\n\n    isClosed() {\n      return this.state === CHANNEL_STATES.closed;\n    }\n\n    isErrored() {\n      return this.state === CHANNEL_STATES.errored;\n    }\n\n    isJoined() {\n      return this.state === CHANNEL_STATES.joined;\n    }\n\n    isJoining() {\n      return this.state === CHANNEL_STATES.joining;\n    }\n\n    isLeaving() {\n      return this.state === CHANNEL_STATES.leaving;\n    }\n\n  }; // js/phoenix/ajax.js\n\n  var Ajax = class {\n    static request(method, endPoint, accept, body, timeout, ontimeout, callback) {\n      if (global.XDomainRequest) {\n        let req = new global.XDomainRequest();\n        this.xdomainRequest(req, method, endPoint, body, timeout, ontimeout, callback);\n      } else {\n        let req = new global.XMLHttpRequest();\n        this.xhrRequest(req, method, endPoint, accept, body, timeout, ontimeout, callback);\n      }\n    }\n\n    static xdomainRequest(req, method, endPoint, body, timeout, ontimeout, callback) {\n      req.timeout = timeout;\n      req.open(method, endPoint);\n\n      req.onload = () => {\n        let response = this.parseJSON(req.responseText);\n        callback && callback(response);\n      };\n\n      if (ontimeout) {\n        req.ontimeout = ontimeout;\n      }\n\n      req.onprogress = () => {};\n\n      req.send(body);\n    }\n\n    static xhrRequest(req, method, endPoint, accept, body, timeout, ontimeout, callback) {\n      req.open(method, endPoint, true);\n      req.timeout = timeout;\n      req.setRequestHeader(\"Content-Type\", accept);\n\n      req.onerror = () => {\n        callback && callback(null);\n      };\n\n      req.onreadystatechange = () => {\n        if (req.readyState === XHR_STATES.complete && callback) {\n          let response = this.parseJSON(req.responseText);\n          callback(response);\n        }\n      };\n\n      if (ontimeout) {\n        req.ontimeout = ontimeout;\n      }\n\n      req.send(body);\n    }\n\n    static parseJSON(resp) {\n      if (!resp || resp === \"\") {\n        return null;\n      }\n\n      try {\n        return JSON.parse(resp);\n      } catch (e) {\n        console && console.log(\"failed to parse JSON response\", resp);\n        return null;\n      }\n    }\n\n    static serialize(obj, parentKey) {\n      let queryStr = [];\n\n      for (var key in obj) {\n        if (!Object.prototype.hasOwnProperty.call(obj, key)) {\n          continue;\n        }\n\n        let paramKey = parentKey ? `${parentKey}[${key}]` : key;\n        let paramVal = obj[key];\n\n        if (typeof paramVal === \"object\") {\n          queryStr.push(this.serialize(paramVal, paramKey));\n        } else {\n          queryStr.push(encodeURIComponent(paramKey) + \"=\" + encodeURIComponent(paramVal));\n        }\n      }\n\n      return queryStr.join(\"&\");\n    }\n\n    static appendParams(url, params) {\n      if (Object.keys(params).length === 0) {\n        return url;\n      }\n\n      let prefix = url.match(/\\?/) ? \"&\" : \"?\";\n      return `${url}${prefix}${this.serialize(params)}`;\n    }\n\n  }; // js/phoenix/longpoll.js\n\n  var LongPoll = class {\n    constructor(endPoint) {\n      this.endPoint = null;\n      this.token = null;\n      this.skipHeartbeat = true;\n\n      this.onopen = function () {};\n\n      this.onerror = function () {};\n\n      this.onmessage = function () {};\n\n      this.onclose = function () {};\n\n      this.pollEndpoint = this.normalizeEndpoint(endPoint);\n      this.readyState = SOCKET_STATES.connecting;\n      this.poll();\n    }\n\n    normalizeEndpoint(endPoint) {\n      return endPoint.replace(\"ws://\", \"http://\").replace(\"wss://\", \"https://\").replace(new RegExp(\"(.*)/\" + TRANSPORTS.websocket), \"$1/\" + TRANSPORTS.longpoll);\n    }\n\n    endpointURL() {\n      return Ajax.appendParams(this.pollEndpoint, {\n        token: this.token\n      });\n    }\n\n    closeAndRetry() {\n      this.close();\n      this.readyState = SOCKET_STATES.connecting;\n    }\n\n    ontimeout() {\n      this.onerror(\"timeout\");\n      this.closeAndRetry();\n    }\n\n    poll() {\n      if (!(this.readyState === SOCKET_STATES.open || this.readyState === SOCKET_STATES.connecting)) {\n        return;\n      }\n\n      Ajax.request(\"GET\", this.endpointURL(), \"application/json\", null, this.timeout, this.ontimeout.bind(this), resp => {\n        if (resp) {\n          var {\n            status,\n            token,\n            messages\n          } = resp;\n          this.token = token;\n        } else {\n          status = 0;\n        }\n\n        switch (status) {\n          case 200:\n            messages.forEach(msg => {\n              setTimeout(() => {\n                this.onmessage({\n                  data: msg\n                });\n              }, 0);\n            });\n            this.poll();\n            break;\n\n          case 204:\n            this.poll();\n            break;\n\n          case 410:\n            this.readyState = SOCKET_STATES.open;\n            this.onopen();\n            this.poll();\n            break;\n\n          case 403:\n            this.onerror();\n            this.close();\n            break;\n\n          case 0:\n          case 500:\n            this.onerror();\n            this.closeAndRetry();\n            break;\n\n          default:\n            throw new Error(`unhandled poll status ${status}`);\n        }\n      });\n    }\n\n    send(body) {\n      Ajax.request(\"POST\", this.endpointURL(), \"application/json\", body, this.timeout, this.onerror.bind(this, \"timeout\"), resp => {\n        if (!resp || resp.status !== 200) {\n          this.onerror(resp && resp.status);\n          this.closeAndRetry();\n        }\n      });\n    }\n\n    close(_code, _reason) {\n      this.readyState = SOCKET_STATES.closed;\n      this.onclose();\n    }\n\n  }; // js/phoenix/presence.js\n\n  var Presence = class {\n    constructor(channel, opts = {}) {\n      let events = opts.events || {\n        state: \"presence_state\",\n        diff: \"presence_diff\"\n      };\n      this.state = {};\n      this.pendingDiffs = [];\n      this.channel = channel;\n      this.joinRef = null;\n      this.caller = {\n        onJoin: function () {},\n        onLeave: function () {},\n        onSync: function () {}\n      };\n      this.channel.on(events.state, newState => {\n        let {\n          onJoin,\n          onLeave,\n          onSync\n        } = this.caller;\n        this.joinRef = this.channel.joinRef();\n        this.state = Presence.syncState(this.state, newState, onJoin, onLeave);\n        this.pendingDiffs.forEach(diff => {\n          this.state = Presence.syncDiff(this.state, diff, onJoin, onLeave);\n        });\n        this.pendingDiffs = [];\n        onSync();\n      });\n      this.channel.on(events.diff, diff => {\n        let {\n          onJoin,\n          onLeave,\n          onSync\n        } = this.caller;\n\n        if (this.inPendingSyncState()) {\n          this.pendingDiffs.push(diff);\n        } else {\n          this.state = Presence.syncDiff(this.state, diff, onJoin, onLeave);\n          onSync();\n        }\n      });\n    }\n\n    onJoin(callback) {\n      this.caller.onJoin = callback;\n    }\n\n    onLeave(callback) {\n      this.caller.onLeave = callback;\n    }\n\n    onSync(callback) {\n      this.caller.onSync = callback;\n    }\n\n    list(by) {\n      return Presence.list(this.state, by);\n    }\n\n    inPendingSyncState() {\n      return !this.joinRef || this.joinRef !== this.channel.joinRef();\n    }\n\n    static syncState(currentState, newState, onJoin, onLeave) {\n      let state = this.clone(currentState);\n      let joins = {};\n      let leaves = {};\n      this.map(state, (key, presence) => {\n        if (!newState[key]) {\n          leaves[key] = presence;\n        }\n      });\n      this.map(newState, (key, newPresence) => {\n        let currentPresence = state[key];\n\n        if (currentPresence) {\n          let newRefs = newPresence.metas.map(m => m.phx_ref);\n          let curRefs = currentPresence.metas.map(m => m.phx_ref);\n          let joinedMetas = newPresence.metas.filter(m => curRefs.indexOf(m.phx_ref) < 0);\n          let leftMetas = currentPresence.metas.filter(m => newRefs.indexOf(m.phx_ref) < 0);\n\n          if (joinedMetas.length > 0) {\n            joins[key] = newPresence;\n            joins[key].metas = joinedMetas;\n          }\n\n          if (leftMetas.length > 0) {\n            leaves[key] = this.clone(currentPresence);\n            leaves[key].metas = leftMetas;\n          }\n        } else {\n          joins[key] = newPresence;\n        }\n      });\n      return this.syncDiff(state, {\n        joins,\n        leaves\n      }, onJoin, onLeave);\n    }\n\n    static syncDiff(state, diff, onJoin, onLeave) {\n      let {\n        joins,\n        leaves\n      } = this.clone(diff);\n\n      if (!onJoin) {\n        onJoin = function () {};\n      }\n\n      if (!onLeave) {\n        onLeave = function () {};\n      }\n\n      this.map(joins, (key, newPresence) => {\n        let currentPresence = state[key];\n        state[key] = this.clone(newPresence);\n\n        if (currentPresence) {\n          let joinedRefs = state[key].metas.map(m => m.phx_ref);\n          let curMetas = currentPresence.metas.filter(m => joinedRefs.indexOf(m.phx_ref) < 0);\n          state[key].metas.unshift(...curMetas);\n        }\n\n        onJoin(key, currentPresence, newPresence);\n      });\n      this.map(leaves, (key, leftPresence) => {\n        let currentPresence = state[key];\n\n        if (!currentPresence) {\n          return;\n        }\n\n        let refsToRemove = leftPresence.metas.map(m => m.phx_ref);\n        currentPresence.metas = currentPresence.metas.filter(p => {\n          return refsToRemove.indexOf(p.phx_ref) < 0;\n        });\n        onLeave(key, currentPresence, leftPresence);\n\n        if (currentPresence.metas.length === 0) {\n          delete state[key];\n        }\n      });\n      return state;\n    }\n\n    static list(presences, chooser) {\n      if (!chooser) {\n        chooser = function (key, pres) {\n          return pres;\n        };\n      }\n\n      return this.map(presences, (key, presence) => {\n        return chooser(key, presence);\n      });\n    }\n\n    static map(obj, func) {\n      return Object.getOwnPropertyNames(obj).map(key => func(key, obj[key]));\n    }\n\n    static clone(obj) {\n      return JSON.parse(JSON.stringify(obj));\n    }\n\n  }; // js/phoenix/serializer.js\n\n  var serializer_default = {\n    HEADER_LENGTH: 1,\n    META_LENGTH: 4,\n    KINDS: {\n      push: 0,\n      reply: 1,\n      broadcast: 2\n    },\n\n    encode(msg, callback) {\n      if (msg.payload.constructor === ArrayBuffer) {\n        return callback(this.binaryEncode(msg));\n      } else {\n        let payload = [msg.join_ref, msg.ref, msg.topic, msg.event, msg.payload];\n        return callback(JSON.stringify(payload));\n      }\n    },\n\n    decode(rawPayload, callback) {\n      if (rawPayload.constructor === ArrayBuffer) {\n        return callback(this.binaryDecode(rawPayload));\n      } else {\n        let [join_ref, ref, topic, event, payload] = JSON.parse(rawPayload);\n        return callback({\n          join_ref,\n          ref,\n          topic,\n          event,\n          payload\n        });\n      }\n    },\n\n    binaryEncode(message) {\n      let {\n        join_ref,\n        ref,\n        event,\n        topic,\n        payload\n      } = message;\n      let metaLength = this.META_LENGTH + join_ref.length + ref.length + topic.length + event.length;\n      let header = new ArrayBuffer(this.HEADER_LENGTH + metaLength);\n      let view = new DataView(header);\n      let offset = 0;\n      view.setUint8(offset++, this.KINDS.push);\n      view.setUint8(offset++, join_ref.length);\n      view.setUint8(offset++, ref.length);\n      view.setUint8(offset++, topic.length);\n      view.setUint8(offset++, event.length);\n      Array.from(join_ref, char => view.setUint8(offset++, char.charCodeAt(0)));\n      Array.from(ref, char => view.setUint8(offset++, char.charCodeAt(0)));\n      Array.from(topic, char => view.setUint8(offset++, char.charCodeAt(0)));\n      Array.from(event, char => view.setUint8(offset++, char.charCodeAt(0)));\n      var combined = new Uint8Array(header.byteLength + payload.byteLength);\n      combined.set(new Uint8Array(header), 0);\n      combined.set(new Uint8Array(payload), header.byteLength);\n      return combined.buffer;\n    },\n\n    binaryDecode(buffer) {\n      let view = new DataView(buffer);\n      let kind = view.getUint8(0);\n      let decoder = new TextDecoder();\n\n      switch (kind) {\n        case this.KINDS.push:\n          return this.decodePush(buffer, view, decoder);\n\n        case this.KINDS.reply:\n          return this.decodeReply(buffer, view, decoder);\n\n        case this.KINDS.broadcast:\n          return this.decodeBroadcast(buffer, view, decoder);\n      }\n    },\n\n    decodePush(buffer, view, decoder) {\n      let joinRefSize = view.getUint8(1);\n      let topicSize = view.getUint8(2);\n      let eventSize = view.getUint8(3);\n      let offset = this.HEADER_LENGTH + this.META_LENGTH - 1;\n      let joinRef = decoder.decode(buffer.slice(offset, offset + joinRefSize));\n      offset = offset + joinRefSize;\n      let topic = decoder.decode(buffer.slice(offset, offset + topicSize));\n      offset = offset + topicSize;\n      let event = decoder.decode(buffer.slice(offset, offset + eventSize));\n      offset = offset + eventSize;\n      let data = buffer.slice(offset, buffer.byteLength);\n      return {\n        join_ref: joinRef,\n        ref: null,\n        topic,\n        event,\n        payload: data\n      };\n    },\n\n    decodeReply(buffer, view, decoder) {\n      let joinRefSize = view.getUint8(1);\n      let refSize = view.getUint8(2);\n      let topicSize = view.getUint8(3);\n      let eventSize = view.getUint8(4);\n      let offset = this.HEADER_LENGTH + this.META_LENGTH;\n      let joinRef = decoder.decode(buffer.slice(offset, offset + joinRefSize));\n      offset = offset + joinRefSize;\n      let ref = decoder.decode(buffer.slice(offset, offset + refSize));\n      offset = offset + refSize;\n      let topic = decoder.decode(buffer.slice(offset, offset + topicSize));\n      offset = offset + topicSize;\n      let event = decoder.decode(buffer.slice(offset, offset + eventSize));\n      offset = offset + eventSize;\n      let data = buffer.slice(offset, buffer.byteLength);\n      let payload = {\n        status: event,\n        response: data\n      };\n      return {\n        join_ref: joinRef,\n        ref,\n        topic,\n        event: CHANNEL_EVENTS.reply,\n        payload\n      };\n    },\n\n    decodeBroadcast(buffer, view, decoder) {\n      let topicSize = view.getUint8(1);\n      let eventSize = view.getUint8(2);\n      let offset = this.HEADER_LENGTH + 2;\n      let topic = decoder.decode(buffer.slice(offset, offset + topicSize));\n      offset = offset + topicSize;\n      let event = decoder.decode(buffer.slice(offset, offset + eventSize));\n      offset = offset + eventSize;\n      let data = buffer.slice(offset, buffer.byteLength);\n      return {\n        join_ref: null,\n        ref: null,\n        topic,\n        event,\n        payload: data\n      };\n    }\n\n  }; // js/phoenix/socket.js\n\n  var Socket = class {\n    constructor(endPoint, opts = {}) {\n      this.stateChangeCallbacks = {\n        open: [],\n        close: [],\n        error: [],\n        message: []\n      };\n      this.channels = [];\n      this.sendBuffer = [];\n      this.ref = 0;\n      this.timeout = opts.timeout || DEFAULT_TIMEOUT;\n      this.transport = opts.transport || global.WebSocket || LongPoll;\n      this.establishedConnections = 0;\n      this.defaultEncoder = serializer_default.encode.bind(serializer_default);\n      this.defaultDecoder = serializer_default.decode.bind(serializer_default);\n      this.closeWasClean = false;\n      this.binaryType = opts.binaryType || \"arraybuffer\";\n      this.connectClock = 1;\n\n      if (this.transport !== LongPoll) {\n        this.encode = opts.encode || this.defaultEncoder;\n        this.decode = opts.decode || this.defaultDecoder;\n      } else {\n        this.encode = this.defaultEncoder;\n        this.decode = this.defaultDecoder;\n      }\n\n      let awaitingConnectionOnPageShow = null;\n\n      if (phxWindow && phxWindow.addEventListener) {\n        phxWindow.addEventListener(\"pagehide\", _e => {\n          if (this.conn) {\n            this.disconnect();\n            awaitingConnectionOnPageShow = this.connectClock;\n          }\n        });\n        phxWindow.addEventListener(\"pageshow\", _e => {\n          if (awaitingConnectionOnPageShow === this.connectClock) {\n            awaitingConnectionOnPageShow = null;\n            this.connect();\n          }\n        });\n      }\n\n      this.heartbeatIntervalMs = opts.heartbeatIntervalMs || 3e4;\n\n      this.rejoinAfterMs = tries => {\n        if (opts.rejoinAfterMs) {\n          return opts.rejoinAfterMs(tries);\n        } else {\n          return [1e3, 2e3, 5e3][tries - 1] || 1e4;\n        }\n      };\n\n      this.reconnectAfterMs = tries => {\n        if (opts.reconnectAfterMs) {\n          return opts.reconnectAfterMs(tries);\n        } else {\n          return [10, 50, 100, 150, 200, 250, 500, 1e3, 2e3][tries - 1] || 5e3;\n        }\n      };\n\n      this.logger = opts.logger || null;\n      this.longpollerTimeout = opts.longpollerTimeout || 2e4;\n      this.params = closure(opts.params || {});\n      this.endPoint = `${endPoint}/${TRANSPORTS.websocket}`;\n      this.vsn = opts.vsn || DEFAULT_VSN;\n      this.heartbeatTimer = null;\n      this.pendingHeartbeatRef = null;\n      this.reconnectTimer = new Timer(() => {\n        this.teardown(() => this.connect());\n      }, this.reconnectAfterMs);\n    }\n\n    replaceTransport(newTransport) {\n      this.disconnect();\n      this.transport = newTransport;\n    }\n\n    protocol() {\n      return location.protocol.match(/^https/) ? \"wss\" : \"ws\";\n    }\n\n    endPointURL() {\n      let uri = Ajax.appendParams(Ajax.appendParams(this.endPoint, this.params()), {\n        vsn: this.vsn\n      });\n\n      if (uri.charAt(0) !== \"/\") {\n        return uri;\n      }\n\n      if (uri.charAt(1) === \"/\") {\n        return `${this.protocol()}:${uri}`;\n      }\n\n      return `${this.protocol()}://${location.host}${uri}`;\n    }\n\n    disconnect(callback, code, reason) {\n      this.connectClock++;\n      this.closeWasClean = true;\n      this.reconnectTimer.reset();\n      this.teardown(callback, code, reason);\n    }\n\n    connect(params) {\n      this.connectClock++;\n\n      if (params) {\n        console && console.log(\"passing params to connect is deprecated. Instead pass :params to the Socket constructor\");\n        this.params = closure(params);\n      }\n\n      if (this.conn) {\n        return;\n      }\n\n      this.closeWasClean = false;\n      this.conn = new this.transport(this.endPointURL());\n      this.conn.binaryType = this.binaryType;\n      this.conn.timeout = this.longpollerTimeout;\n\n      this.conn.onopen = () => this.onConnOpen();\n\n      this.conn.onerror = error => this.onConnError(error);\n\n      this.conn.onmessage = event => this.onConnMessage(event);\n\n      this.conn.onclose = event => this.onConnClose(event);\n    }\n\n    log(kind, msg, data) {\n      this.logger(kind, msg, data);\n    }\n\n    hasLogger() {\n      return this.logger !== null;\n    }\n\n    onOpen(callback) {\n      let ref = this.makeRef();\n      this.stateChangeCallbacks.open.push([ref, callback]);\n      return ref;\n    }\n\n    onClose(callback) {\n      let ref = this.makeRef();\n      this.stateChangeCallbacks.close.push([ref, callback]);\n      return ref;\n    }\n\n    onError(callback) {\n      let ref = this.makeRef();\n      this.stateChangeCallbacks.error.push([ref, callback]);\n      return ref;\n    }\n\n    onMessage(callback) {\n      let ref = this.makeRef();\n      this.stateChangeCallbacks.message.push([ref, callback]);\n      return ref;\n    }\n\n    onConnOpen() {\n      if (this.hasLogger()) this.log(\"transport\", `connected to ${this.endPointURL()}`);\n      this.closeWasClean = false;\n      this.establishedConnections++;\n      this.flushSendBuffer();\n      this.reconnectTimer.reset();\n      this.resetHeartbeat();\n      this.stateChangeCallbacks.open.forEach(([, callback]) => callback());\n    }\n\n    heartbeatTimeout() {\n      if (this.pendingHeartbeatRef) {\n        this.pendingHeartbeatRef = null;\n\n        if (this.hasLogger()) {\n          this.log(\"transport\", \"heartbeat timeout. Attempting to re-establish connection\");\n        }\n\n        this.abnormalClose(\"heartbeat timeout\");\n      }\n    }\n\n    resetHeartbeat() {\n      if (this.conn && this.conn.skipHeartbeat) {\n        return;\n      }\n\n      this.pendingHeartbeatRef = null;\n      clearTimeout(this.heartbeatTimer);\n      setTimeout(() => this.sendHeartbeat(), this.heartbeatIntervalMs);\n    }\n\n    teardown(callback, code, reason) {\n      if (!this.conn) {\n        return callback && callback();\n      }\n\n      this.waitForBufferDone(() => {\n        if (this.conn) {\n          if (code) {\n            this.conn.close(code, reason || \"\");\n          } else {\n            this.conn.close();\n          }\n        }\n\n        this.waitForSocketClosed(() => {\n          if (this.conn) {\n            this.conn.onclose = function () {};\n\n            this.conn = null;\n          }\n\n          callback && callback();\n        });\n      });\n    }\n\n    waitForBufferDone(callback, tries = 1) {\n      if (tries === 5 || !this.conn || !this.conn.bufferedAmount) {\n        callback();\n        return;\n      }\n\n      setTimeout(() => {\n        this.waitForBufferDone(callback, tries + 1);\n      }, 150 * tries);\n    }\n\n    waitForSocketClosed(callback, tries = 1) {\n      if (tries === 5 || !this.conn || this.conn.readyState === SOCKET_STATES.closed) {\n        callback();\n        return;\n      }\n\n      setTimeout(() => {\n        this.waitForSocketClosed(callback, tries + 1);\n      }, 150 * tries);\n    }\n\n    onConnClose(event) {\n      if (this.hasLogger()) this.log(\"transport\", \"close\", event);\n      this.triggerChanError();\n      clearTimeout(this.heartbeatTimer);\n\n      if (!this.closeWasClean) {\n        this.reconnectTimer.scheduleTimeout();\n      }\n\n      this.stateChangeCallbacks.close.forEach(([, callback]) => callback(event));\n    }\n\n    onConnError(error) {\n      if (this.hasLogger()) this.log(\"transport\", error);\n      let transportBefore = this.transport;\n      let establishedBefore = this.establishedConnections;\n      this.stateChangeCallbacks.error.forEach(([, callback]) => {\n        callback(error, transportBefore, establishedBefore);\n      });\n\n      if (transportBefore === this.transport || establishedBefore > 0) {\n        this.triggerChanError();\n      }\n    }\n\n    triggerChanError() {\n      this.channels.forEach(channel => {\n        if (!(channel.isErrored() || channel.isLeaving() || channel.isClosed())) {\n          channel.trigger(CHANNEL_EVENTS.error);\n        }\n      });\n    }\n\n    connectionState() {\n      switch (this.conn && this.conn.readyState) {\n        case SOCKET_STATES.connecting:\n          return \"connecting\";\n\n        case SOCKET_STATES.open:\n          return \"open\";\n\n        case SOCKET_STATES.closing:\n          return \"closing\";\n\n        default:\n          return \"closed\";\n      }\n    }\n\n    isConnected() {\n      return this.connectionState() === \"open\";\n    }\n\n    remove(channel) {\n      this.off(channel.stateChangeRefs);\n      this.channels = this.channels.filter(c => c.joinRef() !== channel.joinRef());\n    }\n\n    off(refs) {\n      for (let key in this.stateChangeCallbacks) {\n        this.stateChangeCallbacks[key] = this.stateChangeCallbacks[key].filter(([ref]) => {\n          return refs.indexOf(ref) === -1;\n        });\n      }\n    }\n\n    channel(topic, chanParams = {}) {\n      let chan = new Channel(topic, chanParams, this);\n      this.channels.push(chan);\n      return chan;\n    }\n\n    push(data) {\n      if (this.hasLogger()) {\n        let {\n          topic,\n          event,\n          payload,\n          ref,\n          join_ref\n        } = data;\n        this.log(\"push\", `${topic} ${event} (${join_ref}, ${ref})`, payload);\n      }\n\n      if (this.isConnected()) {\n        this.encode(data, result => this.conn.send(result));\n      } else {\n        this.sendBuffer.push(() => this.encode(data, result => this.conn.send(result)));\n      }\n    }\n\n    makeRef() {\n      let newRef = this.ref + 1;\n\n      if (newRef === this.ref) {\n        this.ref = 0;\n      } else {\n        this.ref = newRef;\n      }\n\n      return this.ref.toString();\n    }\n\n    sendHeartbeat() {\n      if (this.pendingHeartbeatRef && !this.isConnected()) {\n        return;\n      }\n\n      this.pendingHeartbeatRef = this.makeRef();\n      this.push({\n        topic: \"phoenix\",\n        event: \"heartbeat\",\n        payload: {},\n        ref: this.pendingHeartbeatRef\n      });\n      this.heartbeatTimer = setTimeout(() => this.heartbeatTimeout(), this.heartbeatIntervalMs);\n    }\n\n    abnormalClose(reason) {\n      this.closeWasClean = false;\n\n      if (this.isConnected()) {\n        this.conn.close(WS_CLOSE_NORMAL, reason);\n      }\n    }\n\n    flushSendBuffer() {\n      if (this.isConnected() && this.sendBuffer.length > 0) {\n        this.sendBuffer.forEach(callback => callback());\n        this.sendBuffer = [];\n      }\n    }\n\n    onConnMessage(rawMessage) {\n      this.decode(rawMessage.data, msg => {\n        let {\n          topic,\n          event,\n          payload,\n          ref,\n          join_ref\n        } = msg;\n\n        if (ref && ref === this.pendingHeartbeatRef) {\n          clearTimeout(this.heartbeatTimer);\n          this.pendingHeartbeatRef = null;\n          setTimeout(() => this.sendHeartbeat(), this.heartbeatIntervalMs);\n        }\n\n        if (this.hasLogger()) this.log(\"receive\", `${payload.status || \"\"} ${topic} ${event} ${ref && \"(\" + ref + \")\" || \"\"}`, payload);\n\n        for (let i = 0; i < this.channels.length; i++) {\n          const channel = this.channels[i];\n\n          if (!channel.isMember(topic, event, payload, join_ref)) {\n            continue;\n          }\n\n          channel.trigger(event, payload, ref, join_ref);\n        }\n\n        for (let i = 0; i < this.stateChangeCallbacks.message.length; i++) {\n          let [, callback] = this.stateChangeCallbacks.message[i];\n          callback(msg);\n        }\n      });\n    }\n\n    leaveOpenTopic(topic) {\n      let dupChannel = this.channels.find(c => c.topic === topic && (c.isJoined() || c.isJoining()));\n\n      if (dupChannel) {\n        if (this.hasLogger()) this.log(\"transport\", `leaving duplicate topic \"${topic}\"`);\n        dupChannel.leave();\n      }\n    }\n\n  };\n  return phoenix_exports;\n})();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vZGVwcy9waG9lbml4L3ByaXYvc3RhdGljL3Bob2VuaXguanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vZGVwcy9waG9lbml4L3ByaXYvc3RhdGljL3Bob2VuaXguanM/MzFiYiJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgUGhvZW5peCA9ICgoKSA9PiB7XG4gIHZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG4gIHZhciBfX21hcmtBc01vZHVsZSA9ICh0YXJnZXQpID0+IF9fZGVmUHJvcCh0YXJnZXQsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuICB2YXIgX19leHBvcnQgPSAodGFyZ2V0LCBhbGwpID0+IHtcbiAgICBfX21hcmtBc01vZHVsZSh0YXJnZXQpO1xuICAgIGZvciAodmFyIG5hbWUgaW4gYWxsKVxuICAgICAgX19kZWZQcm9wKHRhcmdldCwgbmFtZSwgeyBnZXQ6IGFsbFtuYW1lXSwgZW51bWVyYWJsZTogdHJ1ZSB9KTtcbiAgfTtcblxuICAvLyBqcy9waG9lbml4L2luZGV4LmpzXG4gIHZhciBwaG9lbml4X2V4cG9ydHMgPSB7fTtcbiAgX19leHBvcnQocGhvZW5peF9leHBvcnRzLCB7XG4gICAgQ2hhbm5lbDogKCkgPT4gQ2hhbm5lbCxcbiAgICBMb25nUG9sbDogKCkgPT4gTG9uZ1BvbGwsXG4gICAgUHJlc2VuY2U6ICgpID0+IFByZXNlbmNlLFxuICAgIFNlcmlhbGl6ZXI6ICgpID0+IHNlcmlhbGl6ZXJfZGVmYXVsdCxcbiAgICBTb2NrZXQ6ICgpID0+IFNvY2tldFxuICB9KTtcblxuICAvLyBqcy9waG9lbml4L3V0aWxzLmpzXG4gIHZhciBjbG9zdXJlID0gKHZhbHVlKSA9PiB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCBjbG9zdXJlMiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIGNsb3N1cmUyO1xuICAgIH1cbiAgfTtcblxuICAvLyBqcy9waG9lbml4L2NvbnN0YW50cy5qc1xuICB2YXIgZ2xvYmFsU2VsZiA9IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IG51bGw7XG4gIHZhciBwaHhXaW5kb3cgPSB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDogbnVsbDtcbiAgdmFyIGdsb2JhbCA9IGdsb2JhbFNlbGYgfHwgcGh4V2luZG93IHx8IHZvaWQgMDtcbiAgdmFyIERFRkFVTFRfVlNOID0gXCIyLjAuMFwiO1xuICB2YXIgU09DS0VUX1NUQVRFUyA9IHsgY29ubmVjdGluZzogMCwgb3BlbjogMSwgY2xvc2luZzogMiwgY2xvc2VkOiAzIH07XG4gIHZhciBERUZBVUxUX1RJTUVPVVQgPSAxZTQ7XG4gIHZhciBXU19DTE9TRV9OT1JNQUwgPSAxZTM7XG4gIHZhciBDSEFOTkVMX1NUQVRFUyA9IHtcbiAgICBjbG9zZWQ6IFwiY2xvc2VkXCIsXG4gICAgZXJyb3JlZDogXCJlcnJvcmVkXCIsXG4gICAgam9pbmVkOiBcImpvaW5lZFwiLFxuICAgIGpvaW5pbmc6IFwiam9pbmluZ1wiLFxuICAgIGxlYXZpbmc6IFwibGVhdmluZ1wiXG4gIH07XG4gIHZhciBDSEFOTkVMX0VWRU5UUyA9IHtcbiAgICBjbG9zZTogXCJwaHhfY2xvc2VcIixcbiAgICBlcnJvcjogXCJwaHhfZXJyb3JcIixcbiAgICBqb2luOiBcInBoeF9qb2luXCIsXG4gICAgcmVwbHk6IFwicGh4X3JlcGx5XCIsXG4gICAgbGVhdmU6IFwicGh4X2xlYXZlXCJcbiAgfTtcbiAgdmFyIFRSQU5TUE9SVFMgPSB7XG4gICAgbG9uZ3BvbGw6IFwibG9uZ3BvbGxcIixcbiAgICB3ZWJzb2NrZXQ6IFwid2Vic29ja2V0XCJcbiAgfTtcbiAgdmFyIFhIUl9TVEFURVMgPSB7XG4gICAgY29tcGxldGU6IDRcbiAgfTtcblxuICAvLyBqcy9waG9lbml4L3B1c2guanNcbiAgdmFyIFB1c2ggPSBjbGFzcyB7XG4gICAgY29uc3RydWN0b3IoY2hhbm5lbCwgZXZlbnQsIHBheWxvYWQsIHRpbWVvdXQpIHtcbiAgICAgIHRoaXMuY2hhbm5lbCA9IGNoYW5uZWw7XG4gICAgICB0aGlzLmV2ZW50ID0gZXZlbnQ7XG4gICAgICB0aGlzLnBheWxvYWQgPSBwYXlsb2FkIHx8IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4ge307XG4gICAgICB9O1xuICAgICAgdGhpcy5yZWNlaXZlZFJlc3AgPSBudWxsO1xuICAgICAgdGhpcy50aW1lb3V0ID0gdGltZW91dDtcbiAgICAgIHRoaXMudGltZW91dFRpbWVyID0gbnVsbDtcbiAgICAgIHRoaXMucmVjSG9va3MgPSBbXTtcbiAgICAgIHRoaXMuc2VudCA9IGZhbHNlO1xuICAgIH1cbiAgICByZXNlbmQodGltZW91dCkge1xuICAgICAgdGhpcy50aW1lb3V0ID0gdGltZW91dDtcbiAgICAgIHRoaXMucmVzZXQoKTtcbiAgICAgIHRoaXMuc2VuZCgpO1xuICAgIH1cbiAgICBzZW5kKCkge1xuICAgICAgaWYgKHRoaXMuaGFzUmVjZWl2ZWQoXCJ0aW1lb3V0XCIpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMuc3RhcnRUaW1lb3V0KCk7XG4gICAgICB0aGlzLnNlbnQgPSB0cnVlO1xuICAgICAgdGhpcy5jaGFubmVsLnNvY2tldC5wdXNoKHtcbiAgICAgICAgdG9waWM6IHRoaXMuY2hhbm5lbC50b3BpYyxcbiAgICAgICAgZXZlbnQ6IHRoaXMuZXZlbnQsXG4gICAgICAgIHBheWxvYWQ6IHRoaXMucGF5bG9hZCgpLFxuICAgICAgICByZWY6IHRoaXMucmVmLFxuICAgICAgICBqb2luX3JlZjogdGhpcy5jaGFubmVsLmpvaW5SZWYoKVxuICAgICAgfSk7XG4gICAgfVxuICAgIHJlY2VpdmUoc3RhdHVzLCBjYWxsYmFjaykge1xuICAgICAgaWYgKHRoaXMuaGFzUmVjZWl2ZWQoc3RhdHVzKSkge1xuICAgICAgICBjYWxsYmFjayh0aGlzLnJlY2VpdmVkUmVzcC5yZXNwb25zZSk7XG4gICAgICB9XG4gICAgICB0aGlzLnJlY0hvb2tzLnB1c2goeyBzdGF0dXMsIGNhbGxiYWNrIH0pO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHJlc2V0KCkge1xuICAgICAgdGhpcy5jYW5jZWxSZWZFdmVudCgpO1xuICAgICAgdGhpcy5yZWYgPSBudWxsO1xuICAgICAgdGhpcy5yZWZFdmVudCA9IG51bGw7XG4gICAgICB0aGlzLnJlY2VpdmVkUmVzcCA9IG51bGw7XG4gICAgICB0aGlzLnNlbnQgPSBmYWxzZTtcbiAgICB9XG4gICAgbWF0Y2hSZWNlaXZlKHsgc3RhdHVzLCByZXNwb25zZSwgX3JlZiB9KSB7XG4gICAgICB0aGlzLnJlY0hvb2tzLmZpbHRlcigoaCkgPT4gaC5zdGF0dXMgPT09IHN0YXR1cykuZm9yRWFjaCgoaCkgPT4gaC5jYWxsYmFjayhyZXNwb25zZSkpO1xuICAgIH1cbiAgICBjYW5jZWxSZWZFdmVudCgpIHtcbiAgICAgIGlmICghdGhpcy5yZWZFdmVudCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLmNoYW5uZWwub2ZmKHRoaXMucmVmRXZlbnQpO1xuICAgIH1cbiAgICBjYW5jZWxUaW1lb3V0KCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMudGltZW91dFRpbWVyKTtcbiAgICAgIHRoaXMudGltZW91dFRpbWVyID0gbnVsbDtcbiAgICB9XG4gICAgc3RhcnRUaW1lb3V0KCkge1xuICAgICAgaWYgKHRoaXMudGltZW91dFRpbWVyKSB7XG4gICAgICAgIHRoaXMuY2FuY2VsVGltZW91dCgpO1xuICAgICAgfVxuICAgICAgdGhpcy5yZWYgPSB0aGlzLmNoYW5uZWwuc29ja2V0Lm1ha2VSZWYoKTtcbiAgICAgIHRoaXMucmVmRXZlbnQgPSB0aGlzLmNoYW5uZWwucmVwbHlFdmVudE5hbWUodGhpcy5yZWYpO1xuICAgICAgdGhpcy5jaGFubmVsLm9uKHRoaXMucmVmRXZlbnQsIChwYXlsb2FkKSA9PiB7XG4gICAgICAgIHRoaXMuY2FuY2VsUmVmRXZlbnQoKTtcbiAgICAgICAgdGhpcy5jYW5jZWxUaW1lb3V0KCk7XG4gICAgICAgIHRoaXMucmVjZWl2ZWRSZXNwID0gcGF5bG9hZDtcbiAgICAgICAgdGhpcy5tYXRjaFJlY2VpdmUocGF5bG9hZCk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMudGltZW91dFRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIHRoaXMudHJpZ2dlcihcInRpbWVvdXRcIiwge30pO1xuICAgICAgfSwgdGhpcy50aW1lb3V0KTtcbiAgICB9XG4gICAgaGFzUmVjZWl2ZWQoc3RhdHVzKSB7XG4gICAgICByZXR1cm4gdGhpcy5yZWNlaXZlZFJlc3AgJiYgdGhpcy5yZWNlaXZlZFJlc3Auc3RhdHVzID09PSBzdGF0dXM7XG4gICAgfVxuICAgIHRyaWdnZXIoc3RhdHVzLCByZXNwb25zZSkge1xuICAgICAgdGhpcy5jaGFubmVsLnRyaWdnZXIodGhpcy5yZWZFdmVudCwgeyBzdGF0dXMsIHJlc3BvbnNlIH0pO1xuICAgIH1cbiAgfTtcblxuICAvLyBqcy9waG9lbml4L3RpbWVyLmpzXG4gIHZhciBUaW1lciA9IGNsYXNzIHtcbiAgICBjb25zdHJ1Y3RvcihjYWxsYmFjaywgdGltZXJDYWxjKSB7XG4gICAgICB0aGlzLmNhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgICB0aGlzLnRpbWVyQ2FsYyA9IHRpbWVyQ2FsYztcbiAgICAgIHRoaXMudGltZXIgPSBudWxsO1xuICAgICAgdGhpcy50cmllcyA9IDA7XG4gICAgfVxuICAgIHJlc2V0KCkge1xuICAgICAgdGhpcy50cmllcyA9IDA7XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy50aW1lcik7XG4gICAgfVxuICAgIHNjaGVkdWxlVGltZW91dCgpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLnRpbWVyKTtcbiAgICAgIHRoaXMudGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgdGhpcy50cmllcyA9IHRoaXMudHJpZXMgKyAxO1xuICAgICAgICB0aGlzLmNhbGxiYWNrKCk7XG4gICAgICB9LCB0aGlzLnRpbWVyQ2FsYyh0aGlzLnRyaWVzICsgMSkpO1xuICAgIH1cbiAgfTtcblxuICAvLyBqcy9waG9lbml4L2NoYW5uZWwuanNcbiAgdmFyIENoYW5uZWwgPSBjbGFzcyB7XG4gICAgY29uc3RydWN0b3IodG9waWMsIHBhcmFtcywgc29ja2V0KSB7XG4gICAgICB0aGlzLnN0YXRlID0gQ0hBTk5FTF9TVEFURVMuY2xvc2VkO1xuICAgICAgdGhpcy50b3BpYyA9IHRvcGljO1xuICAgICAgdGhpcy5wYXJhbXMgPSBjbG9zdXJlKHBhcmFtcyB8fCB7fSk7XG4gICAgICB0aGlzLnNvY2tldCA9IHNvY2tldDtcbiAgICAgIHRoaXMuYmluZGluZ3MgPSBbXTtcbiAgICAgIHRoaXMuYmluZGluZ1JlZiA9IDA7XG4gICAgICB0aGlzLnRpbWVvdXQgPSB0aGlzLnNvY2tldC50aW1lb3V0O1xuICAgICAgdGhpcy5qb2luZWRPbmNlID0gZmFsc2U7XG4gICAgICB0aGlzLmpvaW5QdXNoID0gbmV3IFB1c2godGhpcywgQ0hBTk5FTF9FVkVOVFMuam9pbiwgdGhpcy5wYXJhbXMsIHRoaXMudGltZW91dCk7XG4gICAgICB0aGlzLnB1c2hCdWZmZXIgPSBbXTtcbiAgICAgIHRoaXMuc3RhdGVDaGFuZ2VSZWZzID0gW107XG4gICAgICB0aGlzLnJlam9pblRpbWVyID0gbmV3IFRpbWVyKCgpID0+IHtcbiAgICAgICAgaWYgKHRoaXMuc29ja2V0LmlzQ29ubmVjdGVkKCkpIHtcbiAgICAgICAgICB0aGlzLnJlam9pbigpO1xuICAgICAgICB9XG4gICAgICB9LCB0aGlzLnNvY2tldC5yZWpvaW5BZnRlck1zKTtcbiAgICAgIHRoaXMuc3RhdGVDaGFuZ2VSZWZzLnB1c2godGhpcy5zb2NrZXQub25FcnJvcigoKSA9PiB0aGlzLnJlam9pblRpbWVyLnJlc2V0KCkpKTtcbiAgICAgIHRoaXMuc3RhdGVDaGFuZ2VSZWZzLnB1c2godGhpcy5zb2NrZXQub25PcGVuKCgpID0+IHtcbiAgICAgICAgdGhpcy5yZWpvaW5UaW1lci5yZXNldCgpO1xuICAgICAgICBpZiAodGhpcy5pc0Vycm9yZWQoKSkge1xuICAgICAgICAgIHRoaXMucmVqb2luKCk7XG4gICAgICAgIH1cbiAgICAgIH0pKTtcbiAgICAgIHRoaXMuam9pblB1c2gucmVjZWl2ZShcIm9rXCIsICgpID0+IHtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IENIQU5ORUxfU1RBVEVTLmpvaW5lZDtcbiAgICAgICAgdGhpcy5yZWpvaW5UaW1lci5yZXNldCgpO1xuICAgICAgICB0aGlzLnB1c2hCdWZmZXIuZm9yRWFjaCgocHVzaEV2ZW50KSA9PiBwdXNoRXZlbnQuc2VuZCgpKTtcbiAgICAgICAgdGhpcy5wdXNoQnVmZmVyID0gW107XG4gICAgICB9KTtcbiAgICAgIHRoaXMuam9pblB1c2gucmVjZWl2ZShcImVycm9yXCIsICgpID0+IHtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IENIQU5ORUxfU1RBVEVTLmVycm9yZWQ7XG4gICAgICAgIGlmICh0aGlzLnNvY2tldC5pc0Nvbm5lY3RlZCgpKSB7XG4gICAgICAgICAgdGhpcy5yZWpvaW5UaW1lci5zY2hlZHVsZVRpbWVvdXQoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB0aGlzLm9uQ2xvc2UoKCkgPT4ge1xuICAgICAgICB0aGlzLnJlam9pblRpbWVyLnJlc2V0KCk7XG4gICAgICAgIGlmICh0aGlzLnNvY2tldC5oYXNMb2dnZXIoKSlcbiAgICAgICAgICB0aGlzLnNvY2tldC5sb2coXCJjaGFubmVsXCIsIGBjbG9zZSAke3RoaXMudG9waWN9ICR7dGhpcy5qb2luUmVmKCl9YCk7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBDSEFOTkVMX1NUQVRFUy5jbG9zZWQ7XG4gICAgICAgIHRoaXMuc29ja2V0LnJlbW92ZSh0aGlzKTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5vbkVycm9yKChyZWFzb24pID0+IHtcbiAgICAgICAgaWYgKHRoaXMuc29ja2V0Lmhhc0xvZ2dlcigpKVxuICAgICAgICAgIHRoaXMuc29ja2V0LmxvZyhcImNoYW5uZWxcIiwgYGVycm9yICR7dGhpcy50b3BpY31gLCByZWFzb24pO1xuICAgICAgICBpZiAodGhpcy5pc0pvaW5pbmcoKSkge1xuICAgICAgICAgIHRoaXMuam9pblB1c2gucmVzZXQoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN0YXRlID0gQ0hBTk5FTF9TVEFURVMuZXJyb3JlZDtcbiAgICAgICAgaWYgKHRoaXMuc29ja2V0LmlzQ29ubmVjdGVkKCkpIHtcbiAgICAgICAgICB0aGlzLnJlam9pblRpbWVyLnNjaGVkdWxlVGltZW91dCgpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHRoaXMuam9pblB1c2gucmVjZWl2ZShcInRpbWVvdXRcIiwgKCkgPT4ge1xuICAgICAgICBpZiAodGhpcy5zb2NrZXQuaGFzTG9nZ2VyKCkpXG4gICAgICAgICAgdGhpcy5zb2NrZXQubG9nKFwiY2hhbm5lbFwiLCBgdGltZW91dCAke3RoaXMudG9waWN9ICgke3RoaXMuam9pblJlZigpfSlgLCB0aGlzLmpvaW5QdXNoLnRpbWVvdXQpO1xuICAgICAgICBsZXQgbGVhdmVQdXNoID0gbmV3IFB1c2godGhpcywgQ0hBTk5FTF9FVkVOVFMubGVhdmUsIGNsb3N1cmUoe30pLCB0aGlzLnRpbWVvdXQpO1xuICAgICAgICBsZWF2ZVB1c2guc2VuZCgpO1xuICAgICAgICB0aGlzLnN0YXRlID0gQ0hBTk5FTF9TVEFURVMuZXJyb3JlZDtcbiAgICAgICAgdGhpcy5qb2luUHVzaC5yZXNldCgpO1xuICAgICAgICBpZiAodGhpcy5zb2NrZXQuaXNDb25uZWN0ZWQoKSkge1xuICAgICAgICAgIHRoaXMucmVqb2luVGltZXIuc2NoZWR1bGVUaW1lb3V0KCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgdGhpcy5vbihDSEFOTkVMX0VWRU5UUy5yZXBseSwgKHBheWxvYWQsIHJlZikgPT4ge1xuICAgICAgICB0aGlzLnRyaWdnZXIodGhpcy5yZXBseUV2ZW50TmFtZShyZWYpLCBwYXlsb2FkKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBqb2luKHRpbWVvdXQgPSB0aGlzLnRpbWVvdXQpIHtcbiAgICAgIGlmICh0aGlzLmpvaW5lZE9uY2UpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidHJpZWQgdG8gam9pbiBtdWx0aXBsZSB0aW1lcy4gJ2pvaW4nIGNhbiBvbmx5IGJlIGNhbGxlZCBhIHNpbmdsZSB0aW1lIHBlciBjaGFubmVsIGluc3RhbmNlXCIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy50aW1lb3V0ID0gdGltZW91dDtcbiAgICAgICAgdGhpcy5qb2luZWRPbmNlID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5yZWpvaW4oKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuam9pblB1c2g7XG4gICAgICB9XG4gICAgfVxuICAgIG9uQ2xvc2UoY2FsbGJhY2spIHtcbiAgICAgIHRoaXMub24oQ0hBTk5FTF9FVkVOVFMuY2xvc2UsIGNhbGxiYWNrKTtcbiAgICB9XG4gICAgb25FcnJvcihjYWxsYmFjaykge1xuICAgICAgcmV0dXJuIHRoaXMub24oQ0hBTk5FTF9FVkVOVFMuZXJyb3IsIChyZWFzb24pID0+IGNhbGxiYWNrKHJlYXNvbikpO1xuICAgIH1cbiAgICBvbihldmVudCwgY2FsbGJhY2spIHtcbiAgICAgIGxldCByZWYgPSB0aGlzLmJpbmRpbmdSZWYrKztcbiAgICAgIHRoaXMuYmluZGluZ3MucHVzaCh7IGV2ZW50LCByZWYsIGNhbGxiYWNrIH0pO1xuICAgICAgcmV0dXJuIHJlZjtcbiAgICB9XG4gICAgb2ZmKGV2ZW50LCByZWYpIHtcbiAgICAgIHRoaXMuYmluZGluZ3MgPSB0aGlzLmJpbmRpbmdzLmZpbHRlcigoYmluZCkgPT4ge1xuICAgICAgICByZXR1cm4gIShiaW5kLmV2ZW50ID09PSBldmVudCAmJiAodHlwZW9mIHJlZiA9PT0gXCJ1bmRlZmluZWRcIiB8fCByZWYgPT09IGJpbmQucmVmKSk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgY2FuUHVzaCgpIHtcbiAgICAgIHJldHVybiB0aGlzLnNvY2tldC5pc0Nvbm5lY3RlZCgpICYmIHRoaXMuaXNKb2luZWQoKTtcbiAgICB9XG4gICAgcHVzaChldmVudCwgcGF5bG9hZCwgdGltZW91dCA9IHRoaXMudGltZW91dCkge1xuICAgICAgcGF5bG9hZCA9IHBheWxvYWQgfHwge307XG4gICAgICBpZiAoIXRoaXMuam9pbmVkT25jZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHRyaWVkIHRvIHB1c2ggJyR7ZXZlbnR9JyB0byAnJHt0aGlzLnRvcGljfScgYmVmb3JlIGpvaW5pbmcuIFVzZSBjaGFubmVsLmpvaW4oKSBiZWZvcmUgcHVzaGluZyBldmVudHNgKTtcbiAgICAgIH1cbiAgICAgIGxldCBwdXNoRXZlbnQgPSBuZXcgUHVzaCh0aGlzLCBldmVudCwgZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBwYXlsb2FkO1xuICAgICAgfSwgdGltZW91dCk7XG4gICAgICBpZiAodGhpcy5jYW5QdXNoKCkpIHtcbiAgICAgICAgcHVzaEV2ZW50LnNlbmQoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHB1c2hFdmVudC5zdGFydFRpbWVvdXQoKTtcbiAgICAgICAgdGhpcy5wdXNoQnVmZmVyLnB1c2gocHVzaEV2ZW50KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwdXNoRXZlbnQ7XG4gICAgfVxuICAgIGxlYXZlKHRpbWVvdXQgPSB0aGlzLnRpbWVvdXQpIHtcbiAgICAgIHRoaXMucmVqb2luVGltZXIucmVzZXQoKTtcbiAgICAgIHRoaXMuam9pblB1c2guY2FuY2VsVGltZW91dCgpO1xuICAgICAgdGhpcy5zdGF0ZSA9IENIQU5ORUxfU1RBVEVTLmxlYXZpbmc7XG4gICAgICBsZXQgb25DbG9zZSA9ICgpID0+IHtcbiAgICAgICAgaWYgKHRoaXMuc29ja2V0Lmhhc0xvZ2dlcigpKVxuICAgICAgICAgIHRoaXMuc29ja2V0LmxvZyhcImNoYW5uZWxcIiwgYGxlYXZlICR7dGhpcy50b3BpY31gKTtcbiAgICAgICAgdGhpcy50cmlnZ2VyKENIQU5ORUxfRVZFTlRTLmNsb3NlLCBcImxlYXZlXCIpO1xuICAgICAgfTtcbiAgICAgIGxldCBsZWF2ZVB1c2ggPSBuZXcgUHVzaCh0aGlzLCBDSEFOTkVMX0VWRU5UUy5sZWF2ZSwgY2xvc3VyZSh7fSksIHRpbWVvdXQpO1xuICAgICAgbGVhdmVQdXNoLnJlY2VpdmUoXCJva1wiLCAoKSA9PiBvbkNsb3NlKCkpLnJlY2VpdmUoXCJ0aW1lb3V0XCIsICgpID0+IG9uQ2xvc2UoKSk7XG4gICAgICBsZWF2ZVB1c2guc2VuZCgpO1xuICAgICAgaWYgKCF0aGlzLmNhblB1c2goKSkge1xuICAgICAgICBsZWF2ZVB1c2gudHJpZ2dlcihcIm9rXCIsIHt9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBsZWF2ZVB1c2g7XG4gICAgfVxuICAgIG9uTWVzc2FnZShfZXZlbnQsIHBheWxvYWQsIF9yZWYpIHtcbiAgICAgIHJldHVybiBwYXlsb2FkO1xuICAgIH1cbiAgICBpc01lbWJlcih0b3BpYywgZXZlbnQsIHBheWxvYWQsIGpvaW5SZWYpIHtcbiAgICAgIGlmICh0aGlzLnRvcGljICE9PSB0b3BpYykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAoam9pblJlZiAmJiBqb2luUmVmICE9PSB0aGlzLmpvaW5SZWYoKSkge1xuICAgICAgICBpZiAodGhpcy5zb2NrZXQuaGFzTG9nZ2VyKCkpXG4gICAgICAgICAgdGhpcy5zb2NrZXQubG9nKFwiY2hhbm5lbFwiLCBcImRyb3BwaW5nIG91dGRhdGVkIG1lc3NhZ2VcIiwgeyB0b3BpYywgZXZlbnQsIHBheWxvYWQsIGpvaW5SZWYgfSk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICBqb2luUmVmKCkge1xuICAgICAgcmV0dXJuIHRoaXMuam9pblB1c2gucmVmO1xuICAgIH1cbiAgICByZWpvaW4odGltZW91dCA9IHRoaXMudGltZW91dCkge1xuICAgICAgaWYgKHRoaXMuaXNMZWF2aW5nKCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5zb2NrZXQubGVhdmVPcGVuVG9waWModGhpcy50b3BpYyk7XG4gICAgICB0aGlzLnN0YXRlID0gQ0hBTk5FTF9TVEFURVMuam9pbmluZztcbiAgICAgIHRoaXMuam9pblB1c2gucmVzZW5kKHRpbWVvdXQpO1xuICAgIH1cbiAgICB0cmlnZ2VyKGV2ZW50LCBwYXlsb2FkLCByZWYsIGpvaW5SZWYpIHtcbiAgICAgIGxldCBoYW5kbGVkUGF5bG9hZCA9IHRoaXMub25NZXNzYWdlKGV2ZW50LCBwYXlsb2FkLCByZWYsIGpvaW5SZWYpO1xuICAgICAgaWYgKHBheWxvYWQgJiYgIWhhbmRsZWRQYXlsb2FkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImNoYW5uZWwgb25NZXNzYWdlIGNhbGxiYWNrcyBtdXN0IHJldHVybiB0aGUgcGF5bG9hZCwgbW9kaWZpZWQgb3IgdW5tb2RpZmllZFwiKTtcbiAgICAgIH1cbiAgICAgIGxldCBldmVudEJpbmRpbmdzID0gdGhpcy5iaW5kaW5ncy5maWx0ZXIoKGJpbmQpID0+IGJpbmQuZXZlbnQgPT09IGV2ZW50KTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZXZlbnRCaW5kaW5ncy5sZW5ndGg7IGkrKykge1xuICAgICAgICBsZXQgYmluZCA9IGV2ZW50QmluZGluZ3NbaV07XG4gICAgICAgIGJpbmQuY2FsbGJhY2soaGFuZGxlZFBheWxvYWQsIHJlZiwgam9pblJlZiB8fCB0aGlzLmpvaW5SZWYoKSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJlcGx5RXZlbnROYW1lKHJlZikge1xuICAgICAgcmV0dXJuIGBjaGFuX3JlcGx5XyR7cmVmfWA7XG4gICAgfVxuICAgIGlzQ2xvc2VkKCkge1xuICAgICAgcmV0dXJuIHRoaXMuc3RhdGUgPT09IENIQU5ORUxfU1RBVEVTLmNsb3NlZDtcbiAgICB9XG4gICAgaXNFcnJvcmVkKCkge1xuICAgICAgcmV0dXJuIHRoaXMuc3RhdGUgPT09IENIQU5ORUxfU1RBVEVTLmVycm9yZWQ7XG4gICAgfVxuICAgIGlzSm9pbmVkKCkge1xuICAgICAgcmV0dXJuIHRoaXMuc3RhdGUgPT09IENIQU5ORUxfU1RBVEVTLmpvaW5lZDtcbiAgICB9XG4gICAgaXNKb2luaW5nKCkge1xuICAgICAgcmV0dXJuIHRoaXMuc3RhdGUgPT09IENIQU5ORUxfU1RBVEVTLmpvaW5pbmc7XG4gICAgfVxuICAgIGlzTGVhdmluZygpIHtcbiAgICAgIHJldHVybiB0aGlzLnN0YXRlID09PSBDSEFOTkVMX1NUQVRFUy5sZWF2aW5nO1xuICAgIH1cbiAgfTtcblxuICAvLyBqcy9waG9lbml4L2FqYXguanNcbiAgdmFyIEFqYXggPSBjbGFzcyB7XG4gICAgc3RhdGljIHJlcXVlc3QobWV0aG9kLCBlbmRQb2ludCwgYWNjZXB0LCBib2R5LCB0aW1lb3V0LCBvbnRpbWVvdXQsIGNhbGxiYWNrKSB7XG4gICAgICBpZiAoZ2xvYmFsLlhEb21haW5SZXF1ZXN0KSB7XG4gICAgICAgIGxldCByZXEgPSBuZXcgZ2xvYmFsLlhEb21haW5SZXF1ZXN0KCk7XG4gICAgICAgIHRoaXMueGRvbWFpblJlcXVlc3QocmVxLCBtZXRob2QsIGVuZFBvaW50LCBib2R5LCB0aW1lb3V0LCBvbnRpbWVvdXQsIGNhbGxiYWNrKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxldCByZXEgPSBuZXcgZ2xvYmFsLlhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgICAgIHRoaXMueGhyUmVxdWVzdChyZXEsIG1ldGhvZCwgZW5kUG9pbnQsIGFjY2VwdCwgYm9keSwgdGltZW91dCwgb250aW1lb3V0LCBjYWxsYmFjayk7XG4gICAgICB9XG4gICAgfVxuICAgIHN0YXRpYyB4ZG9tYWluUmVxdWVzdChyZXEsIG1ldGhvZCwgZW5kUG9pbnQsIGJvZHksIHRpbWVvdXQsIG9udGltZW91dCwgY2FsbGJhY2spIHtcbiAgICAgIHJlcS50aW1lb3V0ID0gdGltZW91dDtcbiAgICAgIHJlcS5vcGVuKG1ldGhvZCwgZW5kUG9pbnQpO1xuICAgICAgcmVxLm9ubG9hZCA9ICgpID0+IHtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gdGhpcy5wYXJzZUpTT04ocmVxLnJlc3BvbnNlVGV4dCk7XG4gICAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKHJlc3BvbnNlKTtcbiAgICAgIH07XG4gICAgICBpZiAob250aW1lb3V0KSB7XG4gICAgICAgIHJlcS5vbnRpbWVvdXQgPSBvbnRpbWVvdXQ7XG4gICAgICB9XG4gICAgICByZXEub25wcm9ncmVzcyA9ICgpID0+IHtcbiAgICAgIH07XG4gICAgICByZXEuc2VuZChib2R5KTtcbiAgICB9XG4gICAgc3RhdGljIHhoclJlcXVlc3QocmVxLCBtZXRob2QsIGVuZFBvaW50LCBhY2NlcHQsIGJvZHksIHRpbWVvdXQsIG9udGltZW91dCwgY2FsbGJhY2spIHtcbiAgICAgIHJlcS5vcGVuKG1ldGhvZCwgZW5kUG9pbnQsIHRydWUpO1xuICAgICAgcmVxLnRpbWVvdXQgPSB0aW1lb3V0O1xuICAgICAgcmVxLnNldFJlcXVlc3RIZWFkZXIoXCJDb250ZW50LVR5cGVcIiwgYWNjZXB0KTtcbiAgICAgIHJlcS5vbmVycm9yID0gKCkgPT4ge1xuICAgICAgICBjYWxsYmFjayAmJiBjYWxsYmFjayhudWxsKTtcbiAgICAgIH07XG4gICAgICByZXEub25yZWFkeXN0YXRlY2hhbmdlID0gKCkgPT4ge1xuICAgICAgICBpZiAocmVxLnJlYWR5U3RhdGUgPT09IFhIUl9TVEFURVMuY29tcGxldGUgJiYgY2FsbGJhY2spIHtcbiAgICAgICAgICBsZXQgcmVzcG9uc2UgPSB0aGlzLnBhcnNlSlNPTihyZXEucmVzcG9uc2VUZXh0KTtcbiAgICAgICAgICBjYWxsYmFjayhyZXNwb25zZSk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBpZiAob250aW1lb3V0KSB7XG4gICAgICAgIHJlcS5vbnRpbWVvdXQgPSBvbnRpbWVvdXQ7XG4gICAgICB9XG4gICAgICByZXEuc2VuZChib2R5KTtcbiAgICB9XG4gICAgc3RhdGljIHBhcnNlSlNPTihyZXNwKSB7XG4gICAgICBpZiAoIXJlc3AgfHwgcmVzcCA9PT0gXCJcIikge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBKU09OLnBhcnNlKHJlc3ApO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjb25zb2xlICYmIGNvbnNvbGUubG9nKFwiZmFpbGVkIHRvIHBhcnNlIEpTT04gcmVzcG9uc2VcIiwgcmVzcCk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgICBzdGF0aWMgc2VyaWFsaXplKG9iaiwgcGFyZW50S2V5KSB7XG4gICAgICBsZXQgcXVlcnlTdHIgPSBbXTtcbiAgICAgIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHBhcmFtS2V5ID0gcGFyZW50S2V5ID8gYCR7cGFyZW50S2V5fVske2tleX1dYCA6IGtleTtcbiAgICAgICAgbGV0IHBhcmFtVmFsID0gb2JqW2tleV07XG4gICAgICAgIGlmICh0eXBlb2YgcGFyYW1WYWwgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICBxdWVyeVN0ci5wdXNoKHRoaXMuc2VyaWFsaXplKHBhcmFtVmFsLCBwYXJhbUtleSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHF1ZXJ5U3RyLnB1c2goZW5jb2RlVVJJQ29tcG9uZW50KHBhcmFtS2V5KSArIFwiPVwiICsgZW5jb2RlVVJJQ29tcG9uZW50KHBhcmFtVmFsKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBxdWVyeVN0ci5qb2luKFwiJlwiKTtcbiAgICB9XG4gICAgc3RhdGljIGFwcGVuZFBhcmFtcyh1cmwsIHBhcmFtcykge1xuICAgICAgaWYgKE9iamVjdC5rZXlzKHBhcmFtcykubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiB1cmw7XG4gICAgICB9XG4gICAgICBsZXQgcHJlZml4ID0gdXJsLm1hdGNoKC9cXD8vKSA/IFwiJlwiIDogXCI/XCI7XG4gICAgICByZXR1cm4gYCR7dXJsfSR7cHJlZml4fSR7dGhpcy5zZXJpYWxpemUocGFyYW1zKX1gO1xuICAgIH1cbiAgfTtcblxuICAvLyBqcy9waG9lbml4L2xvbmdwb2xsLmpzXG4gIHZhciBMb25nUG9sbCA9IGNsYXNzIHtcbiAgICBjb25zdHJ1Y3RvcihlbmRQb2ludCkge1xuICAgICAgdGhpcy5lbmRQb2ludCA9IG51bGw7XG4gICAgICB0aGlzLnRva2VuID0gbnVsbDtcbiAgICAgIHRoaXMuc2tpcEhlYXJ0YmVhdCA9IHRydWU7XG4gICAgICB0aGlzLm9ub3BlbiA9IGZ1bmN0aW9uKCkge1xuICAgICAgfTtcbiAgICAgIHRoaXMub25lcnJvciA9IGZ1bmN0aW9uKCkge1xuICAgICAgfTtcbiAgICAgIHRoaXMub25tZXNzYWdlID0gZnVuY3Rpb24oKSB7XG4gICAgICB9O1xuICAgICAgdGhpcy5vbmNsb3NlID0gZnVuY3Rpb24oKSB7XG4gICAgICB9O1xuICAgICAgdGhpcy5wb2xsRW5kcG9pbnQgPSB0aGlzLm5vcm1hbGl6ZUVuZHBvaW50KGVuZFBvaW50KTtcbiAgICAgIHRoaXMucmVhZHlTdGF0ZSA9IFNPQ0tFVF9TVEFURVMuY29ubmVjdGluZztcbiAgICAgIHRoaXMucG9sbCgpO1xuICAgIH1cbiAgICBub3JtYWxpemVFbmRwb2ludChlbmRQb2ludCkge1xuICAgICAgcmV0dXJuIGVuZFBvaW50LnJlcGxhY2UoXCJ3czovL1wiLCBcImh0dHA6Ly9cIikucmVwbGFjZShcIndzczovL1wiLCBcImh0dHBzOi8vXCIpLnJlcGxhY2UobmV3IFJlZ0V4cChcIiguKikvXCIgKyBUUkFOU1BPUlRTLndlYnNvY2tldCksIFwiJDEvXCIgKyBUUkFOU1BPUlRTLmxvbmdwb2xsKTtcbiAgICB9XG4gICAgZW5kcG9pbnRVUkwoKSB7XG4gICAgICByZXR1cm4gQWpheC5hcHBlbmRQYXJhbXModGhpcy5wb2xsRW5kcG9pbnQsIHsgdG9rZW46IHRoaXMudG9rZW4gfSk7XG4gICAgfVxuICAgIGNsb3NlQW5kUmV0cnkoKSB7XG4gICAgICB0aGlzLmNsb3NlKCk7XG4gICAgICB0aGlzLnJlYWR5U3RhdGUgPSBTT0NLRVRfU1RBVEVTLmNvbm5lY3Rpbmc7XG4gICAgfVxuICAgIG9udGltZW91dCgpIHtcbiAgICAgIHRoaXMub25lcnJvcihcInRpbWVvdXRcIik7XG4gICAgICB0aGlzLmNsb3NlQW5kUmV0cnkoKTtcbiAgICB9XG4gICAgcG9sbCgpIHtcbiAgICAgIGlmICghKHRoaXMucmVhZHlTdGF0ZSA9PT0gU09DS0VUX1NUQVRFUy5vcGVuIHx8IHRoaXMucmVhZHlTdGF0ZSA9PT0gU09DS0VUX1NUQVRFUy5jb25uZWN0aW5nKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBBamF4LnJlcXVlc3QoXCJHRVRcIiwgdGhpcy5lbmRwb2ludFVSTCgpLCBcImFwcGxpY2F0aW9uL2pzb25cIiwgbnVsbCwgdGhpcy50aW1lb3V0LCB0aGlzLm9udGltZW91dC5iaW5kKHRoaXMpLCAocmVzcCkgPT4ge1xuICAgICAgICBpZiAocmVzcCkge1xuICAgICAgICAgIHZhciB7IHN0YXR1cywgdG9rZW4sIG1lc3NhZ2VzIH0gPSByZXNwO1xuICAgICAgICAgIHRoaXMudG9rZW4gPSB0b2tlbjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdGF0dXMgPSAwO1xuICAgICAgICB9XG4gICAgICAgIHN3aXRjaCAoc3RhdHVzKSB7XG4gICAgICAgICAgY2FzZSAyMDA6XG4gICAgICAgICAgICBtZXNzYWdlcy5mb3JFYWNoKChtc2cpID0+IHtcbiAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5vbm1lc3NhZ2UoeyBkYXRhOiBtc2cgfSk7XG4gICAgICAgICAgICAgIH0sIDApO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLnBvbGwoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMjA0OlxuICAgICAgICAgICAgdGhpcy5wb2xsKCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDQxMDpcbiAgICAgICAgICAgIHRoaXMucmVhZHlTdGF0ZSA9IFNPQ0tFVF9TVEFURVMub3BlbjtcbiAgICAgICAgICAgIHRoaXMub25vcGVuKCk7XG4gICAgICAgICAgICB0aGlzLnBvbGwoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgNDAzOlxuICAgICAgICAgICAgdGhpcy5vbmVycm9yKCk7XG4gICAgICAgICAgICB0aGlzLmNsb3NlKCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgY2FzZSA1MDA6XG4gICAgICAgICAgICB0aGlzLm9uZXJyb3IoKTtcbiAgICAgICAgICAgIHRoaXMuY2xvc2VBbmRSZXRyeSgpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgdW5oYW5kbGVkIHBvbGwgc3RhdHVzICR7c3RhdHVzfWApO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgc2VuZChib2R5KSB7XG4gICAgICBBamF4LnJlcXVlc3QoXCJQT1NUXCIsIHRoaXMuZW5kcG9pbnRVUkwoKSwgXCJhcHBsaWNhdGlvbi9qc29uXCIsIGJvZHksIHRoaXMudGltZW91dCwgdGhpcy5vbmVycm9yLmJpbmQodGhpcywgXCJ0aW1lb3V0XCIpLCAocmVzcCkgPT4ge1xuICAgICAgICBpZiAoIXJlc3AgfHwgcmVzcC5zdGF0dXMgIT09IDIwMCkge1xuICAgICAgICAgIHRoaXMub25lcnJvcihyZXNwICYmIHJlc3Auc3RhdHVzKTtcbiAgICAgICAgICB0aGlzLmNsb3NlQW5kUmV0cnkoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIGNsb3NlKF9jb2RlLCBfcmVhc29uKSB7XG4gICAgICB0aGlzLnJlYWR5U3RhdGUgPSBTT0NLRVRfU1RBVEVTLmNsb3NlZDtcbiAgICAgIHRoaXMub25jbG9zZSgpO1xuICAgIH1cbiAgfTtcblxuICAvLyBqcy9waG9lbml4L3ByZXNlbmNlLmpzXG4gIHZhciBQcmVzZW5jZSA9IGNsYXNzIHtcbiAgICBjb25zdHJ1Y3RvcihjaGFubmVsLCBvcHRzID0ge30pIHtcbiAgICAgIGxldCBldmVudHMgPSBvcHRzLmV2ZW50cyB8fCB7IHN0YXRlOiBcInByZXNlbmNlX3N0YXRlXCIsIGRpZmY6IFwicHJlc2VuY2VfZGlmZlwiIH07XG4gICAgICB0aGlzLnN0YXRlID0ge307XG4gICAgICB0aGlzLnBlbmRpbmdEaWZmcyA9IFtdO1xuICAgICAgdGhpcy5jaGFubmVsID0gY2hhbm5lbDtcbiAgICAgIHRoaXMuam9pblJlZiA9IG51bGw7XG4gICAgICB0aGlzLmNhbGxlciA9IHtcbiAgICAgICAgb25Kb2luOiBmdW5jdGlvbigpIHtcbiAgICAgICAgfSxcbiAgICAgICAgb25MZWF2ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIH0sXG4gICAgICAgIG9uU3luYzogZnVuY3Rpb24oKSB7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICB0aGlzLmNoYW5uZWwub24oZXZlbnRzLnN0YXRlLCAobmV3U3RhdGUpID0+IHtcbiAgICAgICAgbGV0IHsgb25Kb2luLCBvbkxlYXZlLCBvblN5bmMgfSA9IHRoaXMuY2FsbGVyO1xuICAgICAgICB0aGlzLmpvaW5SZWYgPSB0aGlzLmNoYW5uZWwuam9pblJlZigpO1xuICAgICAgICB0aGlzLnN0YXRlID0gUHJlc2VuY2Uuc3luY1N0YXRlKHRoaXMuc3RhdGUsIG5ld1N0YXRlLCBvbkpvaW4sIG9uTGVhdmUpO1xuICAgICAgICB0aGlzLnBlbmRpbmdEaWZmcy5mb3JFYWNoKChkaWZmKSA9PiB7XG4gICAgICAgICAgdGhpcy5zdGF0ZSA9IFByZXNlbmNlLnN5bmNEaWZmKHRoaXMuc3RhdGUsIGRpZmYsIG9uSm9pbiwgb25MZWF2ZSk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnBlbmRpbmdEaWZmcyA9IFtdO1xuICAgICAgICBvblN5bmMoKTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5jaGFubmVsLm9uKGV2ZW50cy5kaWZmLCAoZGlmZikgPT4ge1xuICAgICAgICBsZXQgeyBvbkpvaW4sIG9uTGVhdmUsIG9uU3luYyB9ID0gdGhpcy5jYWxsZXI7XG4gICAgICAgIGlmICh0aGlzLmluUGVuZGluZ1N5bmNTdGF0ZSgpKSB7XG4gICAgICAgICAgdGhpcy5wZW5kaW5nRGlmZnMucHVzaChkaWZmKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnN0YXRlID0gUHJlc2VuY2Uuc3luY0RpZmYodGhpcy5zdGF0ZSwgZGlmZiwgb25Kb2luLCBvbkxlYXZlKTtcbiAgICAgICAgICBvblN5bmMoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIG9uSm9pbihjYWxsYmFjaykge1xuICAgICAgdGhpcy5jYWxsZXIub25Kb2luID0gY2FsbGJhY2s7XG4gICAgfVxuICAgIG9uTGVhdmUoY2FsbGJhY2spIHtcbiAgICAgIHRoaXMuY2FsbGVyLm9uTGVhdmUgPSBjYWxsYmFjaztcbiAgICB9XG4gICAgb25TeW5jKGNhbGxiYWNrKSB7XG4gICAgICB0aGlzLmNhbGxlci5vblN5bmMgPSBjYWxsYmFjaztcbiAgICB9XG4gICAgbGlzdChieSkge1xuICAgICAgcmV0dXJuIFByZXNlbmNlLmxpc3QodGhpcy5zdGF0ZSwgYnkpO1xuICAgIH1cbiAgICBpblBlbmRpbmdTeW5jU3RhdGUoKSB7XG4gICAgICByZXR1cm4gIXRoaXMuam9pblJlZiB8fCB0aGlzLmpvaW5SZWYgIT09IHRoaXMuY2hhbm5lbC5qb2luUmVmKCk7XG4gICAgfVxuICAgIHN0YXRpYyBzeW5jU3RhdGUoY3VycmVudFN0YXRlLCBuZXdTdGF0ZSwgb25Kb2luLCBvbkxlYXZlKSB7XG4gICAgICBsZXQgc3RhdGUgPSB0aGlzLmNsb25lKGN1cnJlbnRTdGF0ZSk7XG4gICAgICBsZXQgam9pbnMgPSB7fTtcbiAgICAgIGxldCBsZWF2ZXMgPSB7fTtcbiAgICAgIHRoaXMubWFwKHN0YXRlLCAoa2V5LCBwcmVzZW5jZSkgPT4ge1xuICAgICAgICBpZiAoIW5ld1N0YXRlW2tleV0pIHtcbiAgICAgICAgICBsZWF2ZXNba2V5XSA9IHByZXNlbmNlO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHRoaXMubWFwKG5ld1N0YXRlLCAoa2V5LCBuZXdQcmVzZW5jZSkgPT4ge1xuICAgICAgICBsZXQgY3VycmVudFByZXNlbmNlID0gc3RhdGVba2V5XTtcbiAgICAgICAgaWYgKGN1cnJlbnRQcmVzZW5jZSkge1xuICAgICAgICAgIGxldCBuZXdSZWZzID0gbmV3UHJlc2VuY2UubWV0YXMubWFwKChtKSA9PiBtLnBoeF9yZWYpO1xuICAgICAgICAgIGxldCBjdXJSZWZzID0gY3VycmVudFByZXNlbmNlLm1ldGFzLm1hcCgobSkgPT4gbS5waHhfcmVmKTtcbiAgICAgICAgICBsZXQgam9pbmVkTWV0YXMgPSBuZXdQcmVzZW5jZS5tZXRhcy5maWx0ZXIoKG0pID0+IGN1clJlZnMuaW5kZXhPZihtLnBoeF9yZWYpIDwgMCk7XG4gICAgICAgICAgbGV0IGxlZnRNZXRhcyA9IGN1cnJlbnRQcmVzZW5jZS5tZXRhcy5maWx0ZXIoKG0pID0+IG5ld1JlZnMuaW5kZXhPZihtLnBoeF9yZWYpIDwgMCk7XG4gICAgICAgICAgaWYgKGpvaW5lZE1ldGFzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGpvaW5zW2tleV0gPSBuZXdQcmVzZW5jZTtcbiAgICAgICAgICAgIGpvaW5zW2tleV0ubWV0YXMgPSBqb2luZWRNZXRhcztcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGxlZnRNZXRhcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBsZWF2ZXNba2V5XSA9IHRoaXMuY2xvbmUoY3VycmVudFByZXNlbmNlKTtcbiAgICAgICAgICAgIGxlYXZlc1trZXldLm1ldGFzID0gbGVmdE1ldGFzO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBqb2luc1trZXldID0gbmV3UHJlc2VuY2U7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHRoaXMuc3luY0RpZmYoc3RhdGUsIHsgam9pbnMsIGxlYXZlcyB9LCBvbkpvaW4sIG9uTGVhdmUpO1xuICAgIH1cbiAgICBzdGF0aWMgc3luY0RpZmYoc3RhdGUsIGRpZmYsIG9uSm9pbiwgb25MZWF2ZSkge1xuICAgICAgbGV0IHsgam9pbnMsIGxlYXZlcyB9ID0gdGhpcy5jbG9uZShkaWZmKTtcbiAgICAgIGlmICghb25Kb2luKSB7XG4gICAgICAgIG9uSm9pbiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgaWYgKCFvbkxlYXZlKSB7XG4gICAgICAgIG9uTGVhdmUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHRoaXMubWFwKGpvaW5zLCAoa2V5LCBuZXdQcmVzZW5jZSkgPT4ge1xuICAgICAgICBsZXQgY3VycmVudFByZXNlbmNlID0gc3RhdGVba2V5XTtcbiAgICAgICAgc3RhdGVba2V5XSA9IHRoaXMuY2xvbmUobmV3UHJlc2VuY2UpO1xuICAgICAgICBpZiAoY3VycmVudFByZXNlbmNlKSB7XG4gICAgICAgICAgbGV0IGpvaW5lZFJlZnMgPSBzdGF0ZVtrZXldLm1ldGFzLm1hcCgobSkgPT4gbS5waHhfcmVmKTtcbiAgICAgICAgICBsZXQgY3VyTWV0YXMgPSBjdXJyZW50UHJlc2VuY2UubWV0YXMuZmlsdGVyKChtKSA9PiBqb2luZWRSZWZzLmluZGV4T2YobS5waHhfcmVmKSA8IDApO1xuICAgICAgICAgIHN0YXRlW2tleV0ubWV0YXMudW5zaGlmdCguLi5jdXJNZXRhcyk7XG4gICAgICAgIH1cbiAgICAgICAgb25Kb2luKGtleSwgY3VycmVudFByZXNlbmNlLCBuZXdQcmVzZW5jZSk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMubWFwKGxlYXZlcywgKGtleSwgbGVmdFByZXNlbmNlKSA9PiB7XG4gICAgICAgIGxldCBjdXJyZW50UHJlc2VuY2UgPSBzdGF0ZVtrZXldO1xuICAgICAgICBpZiAoIWN1cnJlbnRQcmVzZW5jZSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcmVmc1RvUmVtb3ZlID0gbGVmdFByZXNlbmNlLm1ldGFzLm1hcCgobSkgPT4gbS5waHhfcmVmKTtcbiAgICAgICAgY3VycmVudFByZXNlbmNlLm1ldGFzID0gY3VycmVudFByZXNlbmNlLm1ldGFzLmZpbHRlcigocCkgPT4ge1xuICAgICAgICAgIHJldHVybiByZWZzVG9SZW1vdmUuaW5kZXhPZihwLnBoeF9yZWYpIDwgMDtcbiAgICAgICAgfSk7XG4gICAgICAgIG9uTGVhdmUoa2V5LCBjdXJyZW50UHJlc2VuY2UsIGxlZnRQcmVzZW5jZSk7XG4gICAgICAgIGlmIChjdXJyZW50UHJlc2VuY2UubWV0YXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgZGVsZXRlIHN0YXRlW2tleV07XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHN0YXRlO1xuICAgIH1cbiAgICBzdGF0aWMgbGlzdChwcmVzZW5jZXMsIGNob29zZXIpIHtcbiAgICAgIGlmICghY2hvb3Nlcikge1xuICAgICAgICBjaG9vc2VyID0gZnVuY3Rpb24oa2V5LCBwcmVzKSB7XG4gICAgICAgICAgcmV0dXJuIHByZXM7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5tYXAocHJlc2VuY2VzLCAoa2V5LCBwcmVzZW5jZSkgPT4ge1xuICAgICAgICByZXR1cm4gY2hvb3NlcihrZXksIHByZXNlbmNlKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBzdGF0aWMgbWFwKG9iaiwgZnVuYykge1xuICAgICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKG9iaikubWFwKChrZXkpID0+IGZ1bmMoa2V5LCBvYmpba2V5XSkpO1xuICAgIH1cbiAgICBzdGF0aWMgY2xvbmUob2JqKSB7XG4gICAgICByZXR1cm4gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShvYmopKTtcbiAgICB9XG4gIH07XG5cbiAgLy8ganMvcGhvZW5peC9zZXJpYWxpemVyLmpzXG4gIHZhciBzZXJpYWxpemVyX2RlZmF1bHQgPSB7XG4gICAgSEVBREVSX0xFTkdUSDogMSxcbiAgICBNRVRBX0xFTkdUSDogNCxcbiAgICBLSU5EUzogeyBwdXNoOiAwLCByZXBseTogMSwgYnJvYWRjYXN0OiAyIH0sXG4gICAgZW5jb2RlKG1zZywgY2FsbGJhY2spIHtcbiAgICAgIGlmIChtc2cucGF5bG9hZC5jb25zdHJ1Y3RvciA9PT0gQXJyYXlCdWZmZXIpIHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKHRoaXMuYmluYXJ5RW5jb2RlKG1zZykpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGV0IHBheWxvYWQgPSBbbXNnLmpvaW5fcmVmLCBtc2cucmVmLCBtc2cudG9waWMsIG1zZy5ldmVudCwgbXNnLnBheWxvYWRdO1xuICAgICAgICByZXR1cm4gY2FsbGJhY2soSlNPTi5zdHJpbmdpZnkocGF5bG9hZCkpO1xuICAgICAgfVxuICAgIH0sXG4gICAgZGVjb2RlKHJhd1BheWxvYWQsIGNhbGxiYWNrKSB7XG4gICAgICBpZiAocmF3UGF5bG9hZC5jb25zdHJ1Y3RvciA9PT0gQXJyYXlCdWZmZXIpIHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKHRoaXMuYmluYXJ5RGVjb2RlKHJhd1BheWxvYWQpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxldCBbam9pbl9yZWYsIHJlZiwgdG9waWMsIGV2ZW50LCBwYXlsb2FkXSA9IEpTT04ucGFyc2UocmF3UGF5bG9hZCk7XG4gICAgICAgIHJldHVybiBjYWxsYmFjayh7IGpvaW5fcmVmLCByZWYsIHRvcGljLCBldmVudCwgcGF5bG9hZCB9KTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGJpbmFyeUVuY29kZShtZXNzYWdlKSB7XG4gICAgICBsZXQgeyBqb2luX3JlZiwgcmVmLCBldmVudCwgdG9waWMsIHBheWxvYWQgfSA9IG1lc3NhZ2U7XG4gICAgICBsZXQgbWV0YUxlbmd0aCA9IHRoaXMuTUVUQV9MRU5HVEggKyBqb2luX3JlZi5sZW5ndGggKyByZWYubGVuZ3RoICsgdG9waWMubGVuZ3RoICsgZXZlbnQubGVuZ3RoO1xuICAgICAgbGV0IGhlYWRlciA9IG5ldyBBcnJheUJ1ZmZlcih0aGlzLkhFQURFUl9MRU5HVEggKyBtZXRhTGVuZ3RoKTtcbiAgICAgIGxldCB2aWV3ID0gbmV3IERhdGFWaWV3KGhlYWRlcik7XG4gICAgICBsZXQgb2Zmc2V0ID0gMDtcbiAgICAgIHZpZXcuc2V0VWludDgob2Zmc2V0KyssIHRoaXMuS0lORFMucHVzaCk7XG4gICAgICB2aWV3LnNldFVpbnQ4KG9mZnNldCsrLCBqb2luX3JlZi5sZW5ndGgpO1xuICAgICAgdmlldy5zZXRVaW50OChvZmZzZXQrKywgcmVmLmxlbmd0aCk7XG4gICAgICB2aWV3LnNldFVpbnQ4KG9mZnNldCsrLCB0b3BpYy5sZW5ndGgpO1xuICAgICAgdmlldy5zZXRVaW50OChvZmZzZXQrKywgZXZlbnQubGVuZ3RoKTtcbiAgICAgIEFycmF5LmZyb20oam9pbl9yZWYsIChjaGFyKSA9PiB2aWV3LnNldFVpbnQ4KG9mZnNldCsrLCBjaGFyLmNoYXJDb2RlQXQoMCkpKTtcbiAgICAgIEFycmF5LmZyb20ocmVmLCAoY2hhcikgPT4gdmlldy5zZXRVaW50OChvZmZzZXQrKywgY2hhci5jaGFyQ29kZUF0KDApKSk7XG4gICAgICBBcnJheS5mcm9tKHRvcGljLCAoY2hhcikgPT4gdmlldy5zZXRVaW50OChvZmZzZXQrKywgY2hhci5jaGFyQ29kZUF0KDApKSk7XG4gICAgICBBcnJheS5mcm9tKGV2ZW50LCAoY2hhcikgPT4gdmlldy5zZXRVaW50OChvZmZzZXQrKywgY2hhci5jaGFyQ29kZUF0KDApKSk7XG4gICAgICB2YXIgY29tYmluZWQgPSBuZXcgVWludDhBcnJheShoZWFkZXIuYnl0ZUxlbmd0aCArIHBheWxvYWQuYnl0ZUxlbmd0aCk7XG4gICAgICBjb21iaW5lZC5zZXQobmV3IFVpbnQ4QXJyYXkoaGVhZGVyKSwgMCk7XG4gICAgICBjb21iaW5lZC5zZXQobmV3IFVpbnQ4QXJyYXkocGF5bG9hZCksIGhlYWRlci5ieXRlTGVuZ3RoKTtcbiAgICAgIHJldHVybiBjb21iaW5lZC5idWZmZXI7XG4gICAgfSxcbiAgICBiaW5hcnlEZWNvZGUoYnVmZmVyKSB7XG4gICAgICBsZXQgdmlldyA9IG5ldyBEYXRhVmlldyhidWZmZXIpO1xuICAgICAgbGV0IGtpbmQgPSB2aWV3LmdldFVpbnQ4KDApO1xuICAgICAgbGV0IGRlY29kZXIgPSBuZXcgVGV4dERlY29kZXIoKTtcbiAgICAgIHN3aXRjaCAoa2luZCkge1xuICAgICAgICBjYXNlIHRoaXMuS0lORFMucHVzaDpcbiAgICAgICAgICByZXR1cm4gdGhpcy5kZWNvZGVQdXNoKGJ1ZmZlciwgdmlldywgZGVjb2Rlcik7XG4gICAgICAgIGNhc2UgdGhpcy5LSU5EUy5yZXBseTpcbiAgICAgICAgICByZXR1cm4gdGhpcy5kZWNvZGVSZXBseShidWZmZXIsIHZpZXcsIGRlY29kZXIpO1xuICAgICAgICBjYXNlIHRoaXMuS0lORFMuYnJvYWRjYXN0OlxuICAgICAgICAgIHJldHVybiB0aGlzLmRlY29kZUJyb2FkY2FzdChidWZmZXIsIHZpZXcsIGRlY29kZXIpO1xuICAgICAgfVxuICAgIH0sXG4gICAgZGVjb2RlUHVzaChidWZmZXIsIHZpZXcsIGRlY29kZXIpIHtcbiAgICAgIGxldCBqb2luUmVmU2l6ZSA9IHZpZXcuZ2V0VWludDgoMSk7XG4gICAgICBsZXQgdG9waWNTaXplID0gdmlldy5nZXRVaW50OCgyKTtcbiAgICAgIGxldCBldmVudFNpemUgPSB2aWV3LmdldFVpbnQ4KDMpO1xuICAgICAgbGV0IG9mZnNldCA9IHRoaXMuSEVBREVSX0xFTkdUSCArIHRoaXMuTUVUQV9MRU5HVEggLSAxO1xuICAgICAgbGV0IGpvaW5SZWYgPSBkZWNvZGVyLmRlY29kZShidWZmZXIuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyBqb2luUmVmU2l6ZSkpO1xuICAgICAgb2Zmc2V0ID0gb2Zmc2V0ICsgam9pblJlZlNpemU7XG4gICAgICBsZXQgdG9waWMgPSBkZWNvZGVyLmRlY29kZShidWZmZXIuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyB0b3BpY1NpemUpKTtcbiAgICAgIG9mZnNldCA9IG9mZnNldCArIHRvcGljU2l6ZTtcbiAgICAgIGxldCBldmVudCA9IGRlY29kZXIuZGVjb2RlKGJ1ZmZlci5zbGljZShvZmZzZXQsIG9mZnNldCArIGV2ZW50U2l6ZSkpO1xuICAgICAgb2Zmc2V0ID0gb2Zmc2V0ICsgZXZlbnRTaXplO1xuICAgICAgbGV0IGRhdGEgPSBidWZmZXIuc2xpY2Uob2Zmc2V0LCBidWZmZXIuYnl0ZUxlbmd0aCk7XG4gICAgICByZXR1cm4geyBqb2luX3JlZjogam9pblJlZiwgcmVmOiBudWxsLCB0b3BpYywgZXZlbnQsIHBheWxvYWQ6IGRhdGEgfTtcbiAgICB9LFxuICAgIGRlY29kZVJlcGx5KGJ1ZmZlciwgdmlldywgZGVjb2Rlcikge1xuICAgICAgbGV0IGpvaW5SZWZTaXplID0gdmlldy5nZXRVaW50OCgxKTtcbiAgICAgIGxldCByZWZTaXplID0gdmlldy5nZXRVaW50OCgyKTtcbiAgICAgIGxldCB0b3BpY1NpemUgPSB2aWV3LmdldFVpbnQ4KDMpO1xuICAgICAgbGV0IGV2ZW50U2l6ZSA9IHZpZXcuZ2V0VWludDgoNCk7XG4gICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5IRUFERVJfTEVOR1RIICsgdGhpcy5NRVRBX0xFTkdUSDtcbiAgICAgIGxldCBqb2luUmVmID0gZGVjb2Rlci5kZWNvZGUoYnVmZmVyLnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgam9pblJlZlNpemUpKTtcbiAgICAgIG9mZnNldCA9IG9mZnNldCArIGpvaW5SZWZTaXplO1xuICAgICAgbGV0IHJlZiA9IGRlY29kZXIuZGVjb2RlKGJ1ZmZlci5zbGljZShvZmZzZXQsIG9mZnNldCArIHJlZlNpemUpKTtcbiAgICAgIG9mZnNldCA9IG9mZnNldCArIHJlZlNpemU7XG4gICAgICBsZXQgdG9waWMgPSBkZWNvZGVyLmRlY29kZShidWZmZXIuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyB0b3BpY1NpemUpKTtcbiAgICAgIG9mZnNldCA9IG9mZnNldCArIHRvcGljU2l6ZTtcbiAgICAgIGxldCBldmVudCA9IGRlY29kZXIuZGVjb2RlKGJ1ZmZlci5zbGljZShvZmZzZXQsIG9mZnNldCArIGV2ZW50U2l6ZSkpO1xuICAgICAgb2Zmc2V0ID0gb2Zmc2V0ICsgZXZlbnRTaXplO1xuICAgICAgbGV0IGRhdGEgPSBidWZmZXIuc2xpY2Uob2Zmc2V0LCBidWZmZXIuYnl0ZUxlbmd0aCk7XG4gICAgICBsZXQgcGF5bG9hZCA9IHsgc3RhdHVzOiBldmVudCwgcmVzcG9uc2U6IGRhdGEgfTtcbiAgICAgIHJldHVybiB7IGpvaW5fcmVmOiBqb2luUmVmLCByZWYsIHRvcGljLCBldmVudDogQ0hBTk5FTF9FVkVOVFMucmVwbHksIHBheWxvYWQgfTtcbiAgICB9LFxuICAgIGRlY29kZUJyb2FkY2FzdChidWZmZXIsIHZpZXcsIGRlY29kZXIpIHtcbiAgICAgIGxldCB0b3BpY1NpemUgPSB2aWV3LmdldFVpbnQ4KDEpO1xuICAgICAgbGV0IGV2ZW50U2l6ZSA9IHZpZXcuZ2V0VWludDgoMik7XG4gICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5IRUFERVJfTEVOR1RIICsgMjtcbiAgICAgIGxldCB0b3BpYyA9IGRlY29kZXIuZGVjb2RlKGJ1ZmZlci5zbGljZShvZmZzZXQsIG9mZnNldCArIHRvcGljU2l6ZSkpO1xuICAgICAgb2Zmc2V0ID0gb2Zmc2V0ICsgdG9waWNTaXplO1xuICAgICAgbGV0IGV2ZW50ID0gZGVjb2Rlci5kZWNvZGUoYnVmZmVyLnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgZXZlbnRTaXplKSk7XG4gICAgICBvZmZzZXQgPSBvZmZzZXQgKyBldmVudFNpemU7XG4gICAgICBsZXQgZGF0YSA9IGJ1ZmZlci5zbGljZShvZmZzZXQsIGJ1ZmZlci5ieXRlTGVuZ3RoKTtcbiAgICAgIHJldHVybiB7IGpvaW5fcmVmOiBudWxsLCByZWY6IG51bGwsIHRvcGljLCBldmVudCwgcGF5bG9hZDogZGF0YSB9O1xuICAgIH1cbiAgfTtcblxuICAvLyBqcy9waG9lbml4L3NvY2tldC5qc1xuICB2YXIgU29ja2V0ID0gY2xhc3Mge1xuICAgIGNvbnN0cnVjdG9yKGVuZFBvaW50LCBvcHRzID0ge30pIHtcbiAgICAgIHRoaXMuc3RhdGVDaGFuZ2VDYWxsYmFja3MgPSB7IG9wZW46IFtdLCBjbG9zZTogW10sIGVycm9yOiBbXSwgbWVzc2FnZTogW10gfTtcbiAgICAgIHRoaXMuY2hhbm5lbHMgPSBbXTtcbiAgICAgIHRoaXMuc2VuZEJ1ZmZlciA9IFtdO1xuICAgICAgdGhpcy5yZWYgPSAwO1xuICAgICAgdGhpcy50aW1lb3V0ID0gb3B0cy50aW1lb3V0IHx8IERFRkFVTFRfVElNRU9VVDtcbiAgICAgIHRoaXMudHJhbnNwb3J0ID0gb3B0cy50cmFuc3BvcnQgfHwgZ2xvYmFsLldlYlNvY2tldCB8fCBMb25nUG9sbDtcbiAgICAgIHRoaXMuZXN0YWJsaXNoZWRDb25uZWN0aW9ucyA9IDA7XG4gICAgICB0aGlzLmRlZmF1bHRFbmNvZGVyID0gc2VyaWFsaXplcl9kZWZhdWx0LmVuY29kZS5iaW5kKHNlcmlhbGl6ZXJfZGVmYXVsdCk7XG4gICAgICB0aGlzLmRlZmF1bHREZWNvZGVyID0gc2VyaWFsaXplcl9kZWZhdWx0LmRlY29kZS5iaW5kKHNlcmlhbGl6ZXJfZGVmYXVsdCk7XG4gICAgICB0aGlzLmNsb3NlV2FzQ2xlYW4gPSBmYWxzZTtcbiAgICAgIHRoaXMuYmluYXJ5VHlwZSA9IG9wdHMuYmluYXJ5VHlwZSB8fCBcImFycmF5YnVmZmVyXCI7XG4gICAgICB0aGlzLmNvbm5lY3RDbG9jayA9IDE7XG4gICAgICBpZiAodGhpcy50cmFuc3BvcnQgIT09IExvbmdQb2xsKSB7XG4gICAgICAgIHRoaXMuZW5jb2RlID0gb3B0cy5lbmNvZGUgfHwgdGhpcy5kZWZhdWx0RW5jb2RlcjtcbiAgICAgICAgdGhpcy5kZWNvZGUgPSBvcHRzLmRlY29kZSB8fCB0aGlzLmRlZmF1bHREZWNvZGVyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5lbmNvZGUgPSB0aGlzLmRlZmF1bHRFbmNvZGVyO1xuICAgICAgICB0aGlzLmRlY29kZSA9IHRoaXMuZGVmYXVsdERlY29kZXI7XG4gICAgICB9XG4gICAgICBsZXQgYXdhaXRpbmdDb25uZWN0aW9uT25QYWdlU2hvdyA9IG51bGw7XG4gICAgICBpZiAocGh4V2luZG93ICYmIHBoeFdpbmRvdy5hZGRFdmVudExpc3RlbmVyKSB7XG4gICAgICAgIHBoeFdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwicGFnZWhpZGVcIiwgKF9lKSA9PiB7XG4gICAgICAgICAgaWYgKHRoaXMuY29ubikge1xuICAgICAgICAgICAgdGhpcy5kaXNjb25uZWN0KCk7XG4gICAgICAgICAgICBhd2FpdGluZ0Nvbm5lY3Rpb25PblBhZ2VTaG93ID0gdGhpcy5jb25uZWN0Q2xvY2s7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcGh4V2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJwYWdlc2hvd1wiLCAoX2UpID0+IHtcbiAgICAgICAgICBpZiAoYXdhaXRpbmdDb25uZWN0aW9uT25QYWdlU2hvdyA9PT0gdGhpcy5jb25uZWN0Q2xvY2spIHtcbiAgICAgICAgICAgIGF3YWl0aW5nQ29ubmVjdGlvbk9uUGFnZVNob3cgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5jb25uZWN0KCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHRoaXMuaGVhcnRiZWF0SW50ZXJ2YWxNcyA9IG9wdHMuaGVhcnRiZWF0SW50ZXJ2YWxNcyB8fCAzZTQ7XG4gICAgICB0aGlzLnJlam9pbkFmdGVyTXMgPSAodHJpZXMpID0+IHtcbiAgICAgICAgaWYgKG9wdHMucmVqb2luQWZ0ZXJNcykge1xuICAgICAgICAgIHJldHVybiBvcHRzLnJlam9pbkFmdGVyTXModHJpZXMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBbMWUzLCAyZTMsIDVlM11bdHJpZXMgLSAxXSB8fCAxZTQ7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICB0aGlzLnJlY29ubmVjdEFmdGVyTXMgPSAodHJpZXMpID0+IHtcbiAgICAgICAgaWYgKG9wdHMucmVjb25uZWN0QWZ0ZXJNcykge1xuICAgICAgICAgIHJldHVybiBvcHRzLnJlY29ubmVjdEFmdGVyTXModHJpZXMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBbMTAsIDUwLCAxMDAsIDE1MCwgMjAwLCAyNTAsIDUwMCwgMWUzLCAyZTNdW3RyaWVzIC0gMV0gfHwgNWUzO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgdGhpcy5sb2dnZXIgPSBvcHRzLmxvZ2dlciB8fCBudWxsO1xuICAgICAgdGhpcy5sb25ncG9sbGVyVGltZW91dCA9IG9wdHMubG9uZ3BvbGxlclRpbWVvdXQgfHwgMmU0O1xuICAgICAgdGhpcy5wYXJhbXMgPSBjbG9zdXJlKG9wdHMucGFyYW1zIHx8IHt9KTtcbiAgICAgIHRoaXMuZW5kUG9pbnQgPSBgJHtlbmRQb2ludH0vJHtUUkFOU1BPUlRTLndlYnNvY2tldH1gO1xuICAgICAgdGhpcy52c24gPSBvcHRzLnZzbiB8fCBERUZBVUxUX1ZTTjtcbiAgICAgIHRoaXMuaGVhcnRiZWF0VGltZXIgPSBudWxsO1xuICAgICAgdGhpcy5wZW5kaW5nSGVhcnRiZWF0UmVmID0gbnVsbDtcbiAgICAgIHRoaXMucmVjb25uZWN0VGltZXIgPSBuZXcgVGltZXIoKCkgPT4ge1xuICAgICAgICB0aGlzLnRlYXJkb3duKCgpID0+IHRoaXMuY29ubmVjdCgpKTtcbiAgICAgIH0sIHRoaXMucmVjb25uZWN0QWZ0ZXJNcyk7XG4gICAgfVxuICAgIHJlcGxhY2VUcmFuc3BvcnQobmV3VHJhbnNwb3J0KSB7XG4gICAgICB0aGlzLmRpc2Nvbm5lY3QoKTtcbiAgICAgIHRoaXMudHJhbnNwb3J0ID0gbmV3VHJhbnNwb3J0O1xuICAgIH1cbiAgICBwcm90b2NvbCgpIHtcbiAgICAgIHJldHVybiBsb2NhdGlvbi5wcm90b2NvbC5tYXRjaCgvXmh0dHBzLykgPyBcIndzc1wiIDogXCJ3c1wiO1xuICAgIH1cbiAgICBlbmRQb2ludFVSTCgpIHtcbiAgICAgIGxldCB1cmkgPSBBamF4LmFwcGVuZFBhcmFtcyhBamF4LmFwcGVuZFBhcmFtcyh0aGlzLmVuZFBvaW50LCB0aGlzLnBhcmFtcygpKSwgeyB2c246IHRoaXMudnNuIH0pO1xuICAgICAgaWYgKHVyaS5jaGFyQXQoMCkgIT09IFwiL1wiKSB7XG4gICAgICAgIHJldHVybiB1cmk7XG4gICAgICB9XG4gICAgICBpZiAodXJpLmNoYXJBdCgxKSA9PT0gXCIvXCIpIHtcbiAgICAgICAgcmV0dXJuIGAke3RoaXMucHJvdG9jb2woKX06JHt1cml9YDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBgJHt0aGlzLnByb3RvY29sKCl9Oi8vJHtsb2NhdGlvbi5ob3N0fSR7dXJpfWA7XG4gICAgfVxuICAgIGRpc2Nvbm5lY3QoY2FsbGJhY2ssIGNvZGUsIHJlYXNvbikge1xuICAgICAgdGhpcy5jb25uZWN0Q2xvY2srKztcbiAgICAgIHRoaXMuY2xvc2VXYXNDbGVhbiA9IHRydWU7XG4gICAgICB0aGlzLnJlY29ubmVjdFRpbWVyLnJlc2V0KCk7XG4gICAgICB0aGlzLnRlYXJkb3duKGNhbGxiYWNrLCBjb2RlLCByZWFzb24pO1xuICAgIH1cbiAgICBjb25uZWN0KHBhcmFtcykge1xuICAgICAgdGhpcy5jb25uZWN0Q2xvY2srKztcbiAgICAgIGlmIChwYXJhbXMpIHtcbiAgICAgICAgY29uc29sZSAmJiBjb25zb2xlLmxvZyhcInBhc3NpbmcgcGFyYW1zIHRvIGNvbm5lY3QgaXMgZGVwcmVjYXRlZC4gSW5zdGVhZCBwYXNzIDpwYXJhbXMgdG8gdGhlIFNvY2tldCBjb25zdHJ1Y3RvclwiKTtcbiAgICAgICAgdGhpcy5wYXJhbXMgPSBjbG9zdXJlKHBhcmFtcyk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5jb25uKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMuY2xvc2VXYXNDbGVhbiA9IGZhbHNlO1xuICAgICAgdGhpcy5jb25uID0gbmV3IHRoaXMudHJhbnNwb3J0KHRoaXMuZW5kUG9pbnRVUkwoKSk7XG4gICAgICB0aGlzLmNvbm4uYmluYXJ5VHlwZSA9IHRoaXMuYmluYXJ5VHlwZTtcbiAgICAgIHRoaXMuY29ubi50aW1lb3V0ID0gdGhpcy5sb25ncG9sbGVyVGltZW91dDtcbiAgICAgIHRoaXMuY29ubi5vbm9wZW4gPSAoKSA9PiB0aGlzLm9uQ29ubk9wZW4oKTtcbiAgICAgIHRoaXMuY29ubi5vbmVycm9yID0gKGVycm9yKSA9PiB0aGlzLm9uQ29ubkVycm9yKGVycm9yKTtcbiAgICAgIHRoaXMuY29ubi5vbm1lc3NhZ2UgPSAoZXZlbnQpID0+IHRoaXMub25Db25uTWVzc2FnZShldmVudCk7XG4gICAgICB0aGlzLmNvbm4ub25jbG9zZSA9IChldmVudCkgPT4gdGhpcy5vbkNvbm5DbG9zZShldmVudCk7XG4gICAgfVxuICAgIGxvZyhraW5kLCBtc2csIGRhdGEpIHtcbiAgICAgIHRoaXMubG9nZ2VyKGtpbmQsIG1zZywgZGF0YSk7XG4gICAgfVxuICAgIGhhc0xvZ2dlcigpIHtcbiAgICAgIHJldHVybiB0aGlzLmxvZ2dlciAhPT0gbnVsbDtcbiAgICB9XG4gICAgb25PcGVuKGNhbGxiYWNrKSB7XG4gICAgICBsZXQgcmVmID0gdGhpcy5tYWtlUmVmKCk7XG4gICAgICB0aGlzLnN0YXRlQ2hhbmdlQ2FsbGJhY2tzLm9wZW4ucHVzaChbcmVmLCBjYWxsYmFja10pO1xuICAgICAgcmV0dXJuIHJlZjtcbiAgICB9XG4gICAgb25DbG9zZShjYWxsYmFjaykge1xuICAgICAgbGV0IHJlZiA9IHRoaXMubWFrZVJlZigpO1xuICAgICAgdGhpcy5zdGF0ZUNoYW5nZUNhbGxiYWNrcy5jbG9zZS5wdXNoKFtyZWYsIGNhbGxiYWNrXSk7XG4gICAgICByZXR1cm4gcmVmO1xuICAgIH1cbiAgICBvbkVycm9yKGNhbGxiYWNrKSB7XG4gICAgICBsZXQgcmVmID0gdGhpcy5tYWtlUmVmKCk7XG4gICAgICB0aGlzLnN0YXRlQ2hhbmdlQ2FsbGJhY2tzLmVycm9yLnB1c2goW3JlZiwgY2FsbGJhY2tdKTtcbiAgICAgIHJldHVybiByZWY7XG4gICAgfVxuICAgIG9uTWVzc2FnZShjYWxsYmFjaykge1xuICAgICAgbGV0IHJlZiA9IHRoaXMubWFrZVJlZigpO1xuICAgICAgdGhpcy5zdGF0ZUNoYW5nZUNhbGxiYWNrcy5tZXNzYWdlLnB1c2goW3JlZiwgY2FsbGJhY2tdKTtcbiAgICAgIHJldHVybiByZWY7XG4gICAgfVxuICAgIG9uQ29ubk9wZW4oKSB7XG4gICAgICBpZiAodGhpcy5oYXNMb2dnZXIoKSlcbiAgICAgICAgdGhpcy5sb2coXCJ0cmFuc3BvcnRcIiwgYGNvbm5lY3RlZCB0byAke3RoaXMuZW5kUG9pbnRVUkwoKX1gKTtcbiAgICAgIHRoaXMuY2xvc2VXYXNDbGVhbiA9IGZhbHNlO1xuICAgICAgdGhpcy5lc3RhYmxpc2hlZENvbm5lY3Rpb25zKys7XG4gICAgICB0aGlzLmZsdXNoU2VuZEJ1ZmZlcigpO1xuICAgICAgdGhpcy5yZWNvbm5lY3RUaW1lci5yZXNldCgpO1xuICAgICAgdGhpcy5yZXNldEhlYXJ0YmVhdCgpO1xuICAgICAgdGhpcy5zdGF0ZUNoYW5nZUNhbGxiYWNrcy5vcGVuLmZvckVhY2goKFssIGNhbGxiYWNrXSkgPT4gY2FsbGJhY2soKSk7XG4gICAgfVxuICAgIGhlYXJ0YmVhdFRpbWVvdXQoKSB7XG4gICAgICBpZiAodGhpcy5wZW5kaW5nSGVhcnRiZWF0UmVmKSB7XG4gICAgICAgIHRoaXMucGVuZGluZ0hlYXJ0YmVhdFJlZiA9IG51bGw7XG4gICAgICAgIGlmICh0aGlzLmhhc0xvZ2dlcigpKSB7XG4gICAgICAgICAgdGhpcy5sb2coXCJ0cmFuc3BvcnRcIiwgXCJoZWFydGJlYXQgdGltZW91dC4gQXR0ZW1wdGluZyB0byByZS1lc3RhYmxpc2ggY29ubmVjdGlvblwiKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFibm9ybWFsQ2xvc2UoXCJoZWFydGJlYXQgdGltZW91dFwiKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmVzZXRIZWFydGJlYXQoKSB7XG4gICAgICBpZiAodGhpcy5jb25uICYmIHRoaXMuY29ubi5za2lwSGVhcnRiZWF0KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMucGVuZGluZ0hlYXJ0YmVhdFJlZiA9IG51bGw7XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy5oZWFydGJlYXRUaW1lcik7XG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHRoaXMuc2VuZEhlYXJ0YmVhdCgpLCB0aGlzLmhlYXJ0YmVhdEludGVydmFsTXMpO1xuICAgIH1cbiAgICB0ZWFyZG93bihjYWxsYmFjaywgY29kZSwgcmVhc29uKSB7XG4gICAgICBpZiAoIXRoaXMuY29ubikge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2sgJiYgY2FsbGJhY2soKTtcbiAgICAgIH1cbiAgICAgIHRoaXMud2FpdEZvckJ1ZmZlckRvbmUoKCkgPT4ge1xuICAgICAgICBpZiAodGhpcy5jb25uKSB7XG4gICAgICAgICAgaWYgKGNvZGUpIHtcbiAgICAgICAgICAgIHRoaXMuY29ubi5jbG9zZShjb2RlLCByZWFzb24gfHwgXCJcIik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuY29ubi5jbG9zZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLndhaXRGb3JTb2NrZXRDbG9zZWQoKCkgPT4ge1xuICAgICAgICAgIGlmICh0aGlzLmNvbm4pIHtcbiAgICAgICAgICAgIHRoaXMuY29ubi5vbmNsb3NlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGhpcy5jb25uID0gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2soKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgd2FpdEZvckJ1ZmZlckRvbmUoY2FsbGJhY2ssIHRyaWVzID0gMSkge1xuICAgICAgaWYgKHRyaWVzID09PSA1IHx8ICF0aGlzLmNvbm4gfHwgIXRoaXMuY29ubi5idWZmZXJlZEFtb3VudCkge1xuICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgdGhpcy53YWl0Rm9yQnVmZmVyRG9uZShjYWxsYmFjaywgdHJpZXMgKyAxKTtcbiAgICAgIH0sIDE1MCAqIHRyaWVzKTtcbiAgICB9XG4gICAgd2FpdEZvclNvY2tldENsb3NlZChjYWxsYmFjaywgdHJpZXMgPSAxKSB7XG4gICAgICBpZiAodHJpZXMgPT09IDUgfHwgIXRoaXMuY29ubiB8fCB0aGlzLmNvbm4ucmVhZHlTdGF0ZSA9PT0gU09DS0VUX1NUQVRFUy5jbG9zZWQpIHtcbiAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIHRoaXMud2FpdEZvclNvY2tldENsb3NlZChjYWxsYmFjaywgdHJpZXMgKyAxKTtcbiAgICAgIH0sIDE1MCAqIHRyaWVzKTtcbiAgICB9XG4gICAgb25Db25uQ2xvc2UoZXZlbnQpIHtcbiAgICAgIGlmICh0aGlzLmhhc0xvZ2dlcigpKVxuICAgICAgICB0aGlzLmxvZyhcInRyYW5zcG9ydFwiLCBcImNsb3NlXCIsIGV2ZW50KTtcbiAgICAgIHRoaXMudHJpZ2dlckNoYW5FcnJvcigpO1xuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuaGVhcnRiZWF0VGltZXIpO1xuICAgICAgaWYgKCF0aGlzLmNsb3NlV2FzQ2xlYW4pIHtcbiAgICAgICAgdGhpcy5yZWNvbm5lY3RUaW1lci5zY2hlZHVsZVRpbWVvdXQoKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuc3RhdGVDaGFuZ2VDYWxsYmFja3MuY2xvc2UuZm9yRWFjaCgoWywgY2FsbGJhY2tdKSA9PiBjYWxsYmFjayhldmVudCkpO1xuICAgIH1cbiAgICBvbkNvbm5FcnJvcihlcnJvcikge1xuICAgICAgaWYgKHRoaXMuaGFzTG9nZ2VyKCkpXG4gICAgICAgIHRoaXMubG9nKFwidHJhbnNwb3J0XCIsIGVycm9yKTtcbiAgICAgIGxldCB0cmFuc3BvcnRCZWZvcmUgPSB0aGlzLnRyYW5zcG9ydDtcbiAgICAgIGxldCBlc3RhYmxpc2hlZEJlZm9yZSA9IHRoaXMuZXN0YWJsaXNoZWRDb25uZWN0aW9ucztcbiAgICAgIHRoaXMuc3RhdGVDaGFuZ2VDYWxsYmFja3MuZXJyb3IuZm9yRWFjaCgoWywgY2FsbGJhY2tdKSA9PiB7XG4gICAgICAgIGNhbGxiYWNrKGVycm9yLCB0cmFuc3BvcnRCZWZvcmUsIGVzdGFibGlzaGVkQmVmb3JlKTtcbiAgICAgIH0pO1xuICAgICAgaWYgKHRyYW5zcG9ydEJlZm9yZSA9PT0gdGhpcy50cmFuc3BvcnQgfHwgZXN0YWJsaXNoZWRCZWZvcmUgPiAwKSB7XG4gICAgICAgIHRoaXMudHJpZ2dlckNoYW5FcnJvcigpO1xuICAgICAgfVxuICAgIH1cbiAgICB0cmlnZ2VyQ2hhbkVycm9yKCkge1xuICAgICAgdGhpcy5jaGFubmVscy5mb3JFYWNoKChjaGFubmVsKSA9PiB7XG4gICAgICAgIGlmICghKGNoYW5uZWwuaXNFcnJvcmVkKCkgfHwgY2hhbm5lbC5pc0xlYXZpbmcoKSB8fCBjaGFubmVsLmlzQ2xvc2VkKCkpKSB7XG4gICAgICAgICAgY2hhbm5lbC50cmlnZ2VyKENIQU5ORUxfRVZFTlRTLmVycm9yKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIGNvbm5lY3Rpb25TdGF0ZSgpIHtcbiAgICAgIHN3aXRjaCAodGhpcy5jb25uICYmIHRoaXMuY29ubi5yZWFkeVN0YXRlKSB7XG4gICAgICAgIGNhc2UgU09DS0VUX1NUQVRFUy5jb25uZWN0aW5nOlxuICAgICAgICAgIHJldHVybiBcImNvbm5lY3RpbmdcIjtcbiAgICAgICAgY2FzZSBTT0NLRVRfU1RBVEVTLm9wZW46XG4gICAgICAgICAgcmV0dXJuIFwib3BlblwiO1xuICAgICAgICBjYXNlIFNPQ0tFVF9TVEFURVMuY2xvc2luZzpcbiAgICAgICAgICByZXR1cm4gXCJjbG9zaW5nXCI7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuIFwiY2xvc2VkXCI7XG4gICAgICB9XG4gICAgfVxuICAgIGlzQ29ubmVjdGVkKCkge1xuICAgICAgcmV0dXJuIHRoaXMuY29ubmVjdGlvblN0YXRlKCkgPT09IFwib3BlblwiO1xuICAgIH1cbiAgICByZW1vdmUoY2hhbm5lbCkge1xuICAgICAgdGhpcy5vZmYoY2hhbm5lbC5zdGF0ZUNoYW5nZVJlZnMpO1xuICAgICAgdGhpcy5jaGFubmVscyA9IHRoaXMuY2hhbm5lbHMuZmlsdGVyKChjKSA9PiBjLmpvaW5SZWYoKSAhPT0gY2hhbm5lbC5qb2luUmVmKCkpO1xuICAgIH1cbiAgICBvZmYocmVmcykge1xuICAgICAgZm9yIChsZXQga2V5IGluIHRoaXMuc3RhdGVDaGFuZ2VDYWxsYmFja3MpIHtcbiAgICAgICAgdGhpcy5zdGF0ZUNoYW5nZUNhbGxiYWNrc1trZXldID0gdGhpcy5zdGF0ZUNoYW5nZUNhbGxiYWNrc1trZXldLmZpbHRlcigoW3JlZl0pID0+IHtcbiAgICAgICAgICByZXR1cm4gcmVmcy5pbmRleE9mKHJlZikgPT09IC0xO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgY2hhbm5lbCh0b3BpYywgY2hhblBhcmFtcyA9IHt9KSB7XG4gICAgICBsZXQgY2hhbiA9IG5ldyBDaGFubmVsKHRvcGljLCBjaGFuUGFyYW1zLCB0aGlzKTtcbiAgICAgIHRoaXMuY2hhbm5lbHMucHVzaChjaGFuKTtcbiAgICAgIHJldHVybiBjaGFuO1xuICAgIH1cbiAgICBwdXNoKGRhdGEpIHtcbiAgICAgIGlmICh0aGlzLmhhc0xvZ2dlcigpKSB7XG4gICAgICAgIGxldCB7IHRvcGljLCBldmVudCwgcGF5bG9hZCwgcmVmLCBqb2luX3JlZiB9ID0gZGF0YTtcbiAgICAgICAgdGhpcy5sb2coXCJwdXNoXCIsIGAke3RvcGljfSAke2V2ZW50fSAoJHtqb2luX3JlZn0sICR7cmVmfSlgLCBwYXlsb2FkKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmlzQ29ubmVjdGVkKCkpIHtcbiAgICAgICAgdGhpcy5lbmNvZGUoZGF0YSwgKHJlc3VsdCkgPT4gdGhpcy5jb25uLnNlbmQocmVzdWx0KSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnNlbmRCdWZmZXIucHVzaCgoKSA9PiB0aGlzLmVuY29kZShkYXRhLCAocmVzdWx0KSA9PiB0aGlzLmNvbm4uc2VuZChyZXN1bHQpKSk7XG4gICAgICB9XG4gICAgfVxuICAgIG1ha2VSZWYoKSB7XG4gICAgICBsZXQgbmV3UmVmID0gdGhpcy5yZWYgKyAxO1xuICAgICAgaWYgKG5ld1JlZiA9PT0gdGhpcy5yZWYpIHtcbiAgICAgICAgdGhpcy5yZWYgPSAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5yZWYgPSBuZXdSZWY7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5yZWYudG9TdHJpbmcoKTtcbiAgICB9XG4gICAgc2VuZEhlYXJ0YmVhdCgpIHtcbiAgICAgIGlmICh0aGlzLnBlbmRpbmdIZWFydGJlYXRSZWYgJiYgIXRoaXMuaXNDb25uZWN0ZWQoKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLnBlbmRpbmdIZWFydGJlYXRSZWYgPSB0aGlzLm1ha2VSZWYoKTtcbiAgICAgIHRoaXMucHVzaCh7IHRvcGljOiBcInBob2VuaXhcIiwgZXZlbnQ6IFwiaGVhcnRiZWF0XCIsIHBheWxvYWQ6IHt9LCByZWY6IHRoaXMucGVuZGluZ0hlYXJ0YmVhdFJlZiB9KTtcbiAgICAgIHRoaXMuaGVhcnRiZWF0VGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHRoaXMuaGVhcnRiZWF0VGltZW91dCgpLCB0aGlzLmhlYXJ0YmVhdEludGVydmFsTXMpO1xuICAgIH1cbiAgICBhYm5vcm1hbENsb3NlKHJlYXNvbikge1xuICAgICAgdGhpcy5jbG9zZVdhc0NsZWFuID0gZmFsc2U7XG4gICAgICBpZiAodGhpcy5pc0Nvbm5lY3RlZCgpKSB7XG4gICAgICAgIHRoaXMuY29ubi5jbG9zZShXU19DTE9TRV9OT1JNQUwsIHJlYXNvbik7XG4gICAgICB9XG4gICAgfVxuICAgIGZsdXNoU2VuZEJ1ZmZlcigpIHtcbiAgICAgIGlmICh0aGlzLmlzQ29ubmVjdGVkKCkgJiYgdGhpcy5zZW5kQnVmZmVyLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdGhpcy5zZW5kQnVmZmVyLmZvckVhY2goKGNhbGxiYWNrKSA9PiBjYWxsYmFjaygpKTtcbiAgICAgICAgdGhpcy5zZW5kQnVmZmVyID0gW107XG4gICAgICB9XG4gICAgfVxuICAgIG9uQ29ubk1lc3NhZ2UocmF3TWVzc2FnZSkge1xuICAgICAgdGhpcy5kZWNvZGUocmF3TWVzc2FnZS5kYXRhLCAobXNnKSA9PiB7XG4gICAgICAgIGxldCB7IHRvcGljLCBldmVudCwgcGF5bG9hZCwgcmVmLCBqb2luX3JlZiB9ID0gbXNnO1xuICAgICAgICBpZiAocmVmICYmIHJlZiA9PT0gdGhpcy5wZW5kaW5nSGVhcnRiZWF0UmVmKSB7XG4gICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuaGVhcnRiZWF0VGltZXIpO1xuICAgICAgICAgIHRoaXMucGVuZGluZ0hlYXJ0YmVhdFJlZiA9IG51bGw7XG4gICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB0aGlzLnNlbmRIZWFydGJlYXQoKSwgdGhpcy5oZWFydGJlYXRJbnRlcnZhbE1zKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5oYXNMb2dnZXIoKSlcbiAgICAgICAgICB0aGlzLmxvZyhcInJlY2VpdmVcIiwgYCR7cGF5bG9hZC5zdGF0dXMgfHwgXCJcIn0gJHt0b3BpY30gJHtldmVudH0gJHtyZWYgJiYgXCIoXCIgKyByZWYgKyBcIilcIiB8fCBcIlwifWAsIHBheWxvYWQpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuY2hhbm5lbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBjb25zdCBjaGFubmVsID0gdGhpcy5jaGFubmVsc1tpXTtcbiAgICAgICAgICBpZiAoIWNoYW5uZWwuaXNNZW1iZXIodG9waWMsIGV2ZW50LCBwYXlsb2FkLCBqb2luX3JlZikpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjaGFubmVsLnRyaWdnZXIoZXZlbnQsIHBheWxvYWQsIHJlZiwgam9pbl9yZWYpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5zdGF0ZUNoYW5nZUNhbGxiYWNrcy5tZXNzYWdlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgbGV0IFssIGNhbGxiYWNrXSA9IHRoaXMuc3RhdGVDaGFuZ2VDYWxsYmFja3MubWVzc2FnZVtpXTtcbiAgICAgICAgICBjYWxsYmFjayhtc2cpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgbGVhdmVPcGVuVG9waWModG9waWMpIHtcbiAgICAgIGxldCBkdXBDaGFubmVsID0gdGhpcy5jaGFubmVscy5maW5kKChjKSA9PiBjLnRvcGljID09PSB0b3BpYyAmJiAoYy5pc0pvaW5lZCgpIHx8IGMuaXNKb2luaW5nKCkpKTtcbiAgICAgIGlmIChkdXBDaGFubmVsKSB7XG4gICAgICAgIGlmICh0aGlzLmhhc0xvZ2dlcigpKVxuICAgICAgICAgIHRoaXMubG9nKFwidHJhbnNwb3J0XCIsIGBsZWF2aW5nIGR1cGxpY2F0ZSB0b3BpYyBcIiR7dG9waWN9XCJgKTtcbiAgICAgICAgZHVwQ2hhbm5lbC5sZWF2ZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgcmV0dXJuIHBob2VuaXhfZXhwb3J0cztcbn0pKCk7XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTEE7QUFDQTtBQUNBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFMQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUxBO0FBT0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBREE7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFMQTtBQU9BO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQWpGQTtBQUNBO0FBbUZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQWxCQTtBQUNBO0FBb0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUEzTEE7QUFDQTtBQTZMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBNUVBO0FBQ0E7QUE4RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUEzQkE7QUE2QkE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQXJGQTtBQUNBO0FBdUZBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFMQTtBQVFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQXBJQTtBQUNBO0FBc0lBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFOQTtBQVFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQWhHQTtBQUNBO0FBa0dBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQVJBO0FBVUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUF2VUE7QUF3VUE7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../deps/phoenix/priv/static/phoenix.js\n");

/***/ }),

/***/ "../deps/phoenix_html/priv/static/phoenix_html.js":
/*!********************************************************!*\
  !*** ../deps/phoenix_html/priv/static/phoenix_html.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n(function () {\n  var PolyfillEvent = eventConstructor();\n\n  function eventConstructor() {\n    if (typeof window.CustomEvent === \"function\") return window.CustomEvent; // IE<=9 Support\n\n    function CustomEvent(event, params) {\n      params = params || {\n        bubbles: false,\n        cancelable: false,\n        detail: undefined\n      };\n      var evt = document.createEvent('CustomEvent');\n      evt.initCustomEvent(event, params.bubbles, params.cancelable, params.detail);\n      return evt;\n    }\n\n    CustomEvent.prototype = window.Event.prototype;\n    return CustomEvent;\n  }\n\n  function buildHiddenInput(name, value) {\n    var input = document.createElement(\"input\");\n    input.type = \"hidden\";\n    input.name = name;\n    input.value = value;\n    return input;\n  }\n\n  function handleClick(element, targetModifierKey) {\n    var to = element.getAttribute(\"data-to\"),\n        method = buildHiddenInput(\"_method\", element.getAttribute(\"data-method\")),\n        csrf = buildHiddenInput(\"_csrf_token\", element.getAttribute(\"data-csrf\")),\n        form = document.createElement(\"form\"),\n        target = element.getAttribute(\"target\");\n    form.method = element.getAttribute(\"data-method\") === \"get\" ? \"get\" : \"post\";\n    form.action = to;\n    form.style.display = \"hidden\";\n    if (target) form.target = target;else if (targetModifierKey) form.target = \"_blank\";\n    form.appendChild(csrf);\n    form.appendChild(method);\n    document.body.appendChild(form);\n    form.submit();\n  }\n\n  window.addEventListener(\"click\", function (e) {\n    var element = e.target;\n\n    if (e.defaultPrevented) {\n      return;\n    }\n\n    while (element && element.getAttribute) {\n      var phoenixLinkEvent = new PolyfillEvent('phoenix.link.click', {\n        \"bubbles\": true,\n        \"cancelable\": true\n      });\n\n      if (!element.dispatchEvent(phoenixLinkEvent)) {\n        e.preventDefault();\n        e.stopImmediatePropagation();\n        return false;\n      }\n\n      if (element.getAttribute(\"data-method\")) {\n        handleClick(element, e.metaKey || e.shiftKey);\n        e.preventDefault();\n        return false;\n      } else {\n        element = element.parentNode;\n      }\n    }\n  }, false);\n  window.addEventListener('phoenix.link.click', function (e) {\n    var message = e.target.getAttribute(\"data-confirm\");\n\n    if (message && !window.confirm(message)) {\n      e.preventDefault();\n    }\n  }, false);\n})();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vZGVwcy9waG9lbml4X2h0bWwvcHJpdi9zdGF0aWMvcGhvZW5peF9odG1sLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4uL2RlcHMvcGhvZW5peF9odG1sL3ByaXYvc3RhdGljL3Bob2VuaXhfaHRtbC5qcz80N2Q4Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG4oZnVuY3Rpb24oKSB7XG4gIHZhciBQb2x5ZmlsbEV2ZW50ID0gZXZlbnRDb25zdHJ1Y3RvcigpO1xuXG4gIGZ1bmN0aW9uIGV2ZW50Q29uc3RydWN0b3IoKSB7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cuQ3VzdG9tRXZlbnQgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHdpbmRvdy5DdXN0b21FdmVudDtcbiAgICAvLyBJRTw9OSBTdXBwb3J0XG4gICAgZnVuY3Rpb24gQ3VzdG9tRXZlbnQoZXZlbnQsIHBhcmFtcykge1xuICAgICAgcGFyYW1zID0gcGFyYW1zIHx8IHtidWJibGVzOiBmYWxzZSwgY2FuY2VsYWJsZTogZmFsc2UsIGRldGFpbDogdW5kZWZpbmVkfTtcbiAgICAgIHZhciBldnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnQ3VzdG9tRXZlbnQnKTtcbiAgICAgIGV2dC5pbml0Q3VzdG9tRXZlbnQoZXZlbnQsIHBhcmFtcy5idWJibGVzLCBwYXJhbXMuY2FuY2VsYWJsZSwgcGFyYW1zLmRldGFpbCk7XG4gICAgICByZXR1cm4gZXZ0O1xuICAgIH1cbiAgICBDdXN0b21FdmVudC5wcm90b3R5cGUgPSB3aW5kb3cuRXZlbnQucHJvdG90eXBlO1xuICAgIHJldHVybiBDdXN0b21FdmVudDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGJ1aWxkSGlkZGVuSW5wdXQobmFtZSwgdmFsdWUpIHtcbiAgICB2YXIgaW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW5wdXRcIik7XG4gICAgaW5wdXQudHlwZSA9IFwiaGlkZGVuXCI7XG4gICAgaW5wdXQubmFtZSA9IG5hbWU7XG4gICAgaW5wdXQudmFsdWUgPSB2YWx1ZTtcbiAgICByZXR1cm4gaW5wdXQ7XG4gIH1cblxuICBmdW5jdGlvbiBoYW5kbGVDbGljayhlbGVtZW50LCB0YXJnZXRNb2RpZmllcktleSkge1xuICAgIHZhciB0byA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKFwiZGF0YS10b1wiKSxcbiAgICAgICAgbWV0aG9kID0gYnVpbGRIaWRkZW5JbnB1dChcIl9tZXRob2RcIiwgZWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJkYXRhLW1ldGhvZFwiKSksXG4gICAgICAgIGNzcmYgPSBidWlsZEhpZGRlbklucHV0KFwiX2NzcmZfdG9rZW5cIiwgZWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJkYXRhLWNzcmZcIikpLFxuICAgICAgICBmb3JtID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImZvcm1cIiksXG4gICAgICAgIHRhcmdldCA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKFwidGFyZ2V0XCIpO1xuXG4gICAgZm9ybS5tZXRob2QgPSAoZWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJkYXRhLW1ldGhvZFwiKSA9PT0gXCJnZXRcIikgPyBcImdldFwiIDogXCJwb3N0XCI7XG4gICAgZm9ybS5hY3Rpb24gPSB0bztcbiAgICBmb3JtLnN0eWxlLmRpc3BsYXkgPSBcImhpZGRlblwiO1xuXG4gICAgaWYgKHRhcmdldCkgZm9ybS50YXJnZXQgPSB0YXJnZXQ7XG4gICAgZWxzZSBpZiAodGFyZ2V0TW9kaWZpZXJLZXkpIGZvcm0udGFyZ2V0ID0gXCJfYmxhbmtcIjtcblxuICAgIGZvcm0uYXBwZW5kQ2hpbGQoY3NyZik7XG4gICAgZm9ybS5hcHBlbmRDaGlsZChtZXRob2QpO1xuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoZm9ybSk7XG4gICAgZm9ybS5zdWJtaXQoKTtcbiAgfVxuXG4gIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgZnVuY3Rpb24oZSkge1xuICAgIHZhciBlbGVtZW50ID0gZS50YXJnZXQ7XG5cbiAgICBpZiAoZS5kZWZhdWx0UHJldmVudGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgd2hpbGUgKGVsZW1lbnQgJiYgZWxlbWVudC5nZXRBdHRyaWJ1dGUpIHtcbiAgICAgIHZhciBwaG9lbml4TGlua0V2ZW50ID0gbmV3IFBvbHlmaWxsRXZlbnQoJ3Bob2VuaXgubGluay5jbGljaycsIHtcbiAgICAgICAgXCJidWJibGVzXCI6IHRydWUsIFwiY2FuY2VsYWJsZVwiOiB0cnVlXG4gICAgICB9KTtcblxuICAgICAgaWYgKCFlbGVtZW50LmRpc3BhdGNoRXZlbnQocGhvZW5peExpbmtFdmVudCkpIHtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGlmIChlbGVtZW50LmdldEF0dHJpYnV0ZShcImRhdGEtbWV0aG9kXCIpKSB7XG4gICAgICAgIGhhbmRsZUNsaWNrKGVsZW1lbnQsIGUubWV0YUtleSB8fCBlLnNoaWZ0S2V5KTtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbGVtZW50ID0gZWxlbWVudC5wYXJlbnROb2RlO1xuICAgICAgfVxuICAgIH1cbiAgfSwgZmFsc2UpO1xuXG4gIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdwaG9lbml4LmxpbmsuY2xpY2snLCBmdW5jdGlvbiAoZSkge1xuICAgIHZhciBtZXNzYWdlID0gZS50YXJnZXQuZ2V0QXR0cmlidXRlKFwiZGF0YS1jb25maXJtXCIpO1xuICAgIGlmKG1lc3NhZ2UgJiYgIXdpbmRvdy5jb25maXJtKG1lc3NhZ2UpKSB7XG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgfVxuICB9LCBmYWxzZSk7XG59KSgpO1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQU1BO0FBQ0E7QUFDQTtBQUVBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQURBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../deps/phoenix_html/priv/static/phoenix_html.js\n");

/***/ }),

/***/ "../deps/phoenix_live_view/priv/static/phoenix_live_view.js":
/*!******************************************************************!*\
  !*** ../deps/phoenix_live_view/priv/static/phoenix_live_view.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var LiveView = (() => {\n  var __defProp = Object.defineProperty;\n  var __getOwnPropSymbols = Object.getOwnPropertySymbols;\n  var __hasOwnProp = Object.prototype.hasOwnProperty;\n  var __propIsEnum = Object.prototype.propertyIsEnumerable;\n\n  var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value\n  }) : obj[key] = value;\n\n  var __spreadValues = (a, b) => {\n    for (var prop in b || (b = {})) if (__hasOwnProp.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n\n    if (__getOwnPropSymbols) for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n    }\n    return a;\n  };\n\n  var __markAsModule = target => __defProp(target, \"__esModule\", {\n    value: true\n  });\n\n  var __export = (target, all) => {\n    __markAsModule(target);\n\n    for (var name in all) __defProp(target, name, {\n      get: all[name],\n      enumerable: true\n    });\n  }; // js/phoenix_live_view/index.js\n\n\n  var phoenix_live_view_exports = {};\n\n  __export(phoenix_live_view_exports, {\n    LiveSocket: () => LiveSocket\n  }); // js/phoenix_live_view/constants.js\n\n\n  var CONSECUTIVE_RELOADS = \"consecutive-reloads\";\n  var MAX_RELOADS = 10;\n  var RELOAD_JITTER = [1e3, 3e3];\n  var FAILSAFE_JITTER = 3e4;\n  var PHX_EVENT_CLASSES = [\"phx-click-loading\", \"phx-change-loading\", \"phx-submit-loading\", \"phx-keydown-loading\", \"phx-keyup-loading\", \"phx-blur-loading\", \"phx-focus-loading\"];\n  var PHX_COMPONENT = \"data-phx-component\";\n  var PHX_LIVE_LINK = \"data-phx-link\";\n  var PHX_TRACK_STATIC = \"track-static\";\n  var PHX_LINK_STATE = \"data-phx-link-state\";\n  var PHX_REF = \"data-phx-ref\";\n  var PHX_TRACK_UPLOADS = \"track-uploads\";\n  var PHX_UPLOAD_REF = \"data-phx-upload-ref\";\n  var PHX_PREFLIGHTED_REFS = \"data-phx-preflighted-refs\";\n  var PHX_DONE_REFS = \"data-phx-done-refs\";\n  var PHX_DROP_TARGET = \"drop-target\";\n  var PHX_ACTIVE_ENTRY_REFS = \"data-phx-active-refs\";\n  var PHX_LIVE_FILE_UPDATED = \"phx:live-file:updated\";\n  var PHX_SKIP = \"data-phx-skip\";\n  var PHX_PRUNE = \"data-phx-prune\";\n  var PHX_PAGE_LOADING = \"page-loading\";\n  var PHX_CONNECTED_CLASS = \"phx-connected\";\n  var PHX_DISCONNECTED_CLASS = \"phx-loading\";\n  var PHX_NO_FEEDBACK_CLASS = \"phx-no-feedback\";\n  var PHX_ERROR_CLASS = \"phx-error\";\n  var PHX_PARENT_ID = \"data-phx-parent-id\";\n  var PHX_MAIN = \"data-phx-main\";\n  var PHX_ROOT_ID = \"data-phx-root-id\";\n  var PHX_TRIGGER_ACTION = \"trigger-action\";\n  var PHX_FEEDBACK_FOR = \"feedback-for\";\n  var PHX_HAS_FOCUSED = \"phx-has-focused\";\n  var FOCUSABLE_INPUTS = [\"text\", \"textarea\", \"number\", \"email\", \"password\", \"search\", \"tel\", \"url\", \"date\", \"time\"];\n  var CHECKABLE_INPUTS = [\"checkbox\", \"radio\"];\n  var PHX_HAS_SUBMITTED = \"phx-has-submitted\";\n  var PHX_SESSION = \"data-phx-session\";\n  var PHX_VIEW_SELECTOR = `[${PHX_SESSION}]`;\n  var PHX_STATIC = \"data-phx-static\";\n  var PHX_READONLY = \"data-phx-readonly\";\n  var PHX_DISABLED = \"data-phx-disabled\";\n  var PHX_DISABLE_WITH = \"disable-with\";\n  var PHX_DISABLE_WITH_RESTORE = \"data-phx-disable-with-restore\";\n  var PHX_HOOK = \"hook\";\n  var PHX_DEBOUNCE = \"debounce\";\n  var PHX_THROTTLE = \"throttle\";\n  var PHX_UPDATE = \"update\";\n  var PHX_KEY = \"key\";\n  var PHX_PRIVATE = \"phxPrivate\";\n  var PHX_AUTO_RECOVER = \"auto-recover\";\n  var PHX_LV_DEBUG = \"phx:live-socket:debug\";\n  var PHX_LV_PROFILE = \"phx:live-socket:profiling\";\n  var PHX_LV_LATENCY_SIM = \"phx:live-socket:latency-sim\";\n  var PHX_PROGRESS = \"progress\";\n  var LOADER_TIMEOUT = 1;\n  var BEFORE_UNLOAD_LOADER_TIMEOUT = 200;\n  var BINDING_PREFIX = \"phx-\";\n  var PUSH_TIMEOUT = 3e4;\n  var DEBOUNCE_TRIGGER = \"debounce-trigger\";\n  var THROTTLED = \"throttled\";\n  var DEBOUNCE_PREV_KEY = \"debounce-prev-key\";\n  var DEFAULTS = {\n    debounce: 300,\n    throttle: 300\n  };\n  var DYNAMICS = \"d\";\n  var STATIC = \"s\";\n  var COMPONENTS = \"c\";\n  var EVENTS = \"e\";\n  var REPLY = \"r\";\n  var TITLE = \"t\";\n  var TEMPLATES = \"p\"; // js/phoenix_live_view/entry_uploader.js\n\n  var EntryUploader = class {\n    constructor(entry, chunkSize, liveSocket) {\n      this.liveSocket = liveSocket;\n      this.entry = entry;\n      this.offset = 0;\n      this.chunkSize = chunkSize;\n      this.chunkTimer = null;\n      this.uploadChannel = liveSocket.channel(`lvu:${entry.ref}`, {\n        token: entry.metadata()\n      });\n    }\n\n    error(reason) {\n      clearTimeout(this.chunkTimer);\n      this.uploadChannel.leave();\n      this.entry.error(reason);\n    }\n\n    upload() {\n      this.uploadChannel.onError(reason => this.error(reason));\n      this.uploadChannel.join().receive(\"ok\", _data => this.readNextChunk()).receive(\"error\", reason => this.error(reason));\n    }\n\n    isDone() {\n      return this.offset >= this.entry.file.size;\n    }\n\n    readNextChunk() {\n      let reader = new window.FileReader();\n      let blob = this.entry.file.slice(this.offset, this.chunkSize + this.offset);\n\n      reader.onload = e => {\n        if (e.target.error === null) {\n          this.offset += e.target.result.byteLength;\n          this.pushChunk(e.target.result);\n        } else {\n          return logError(\"Read error: \" + e.target.error);\n        }\n      };\n\n      reader.readAsArrayBuffer(blob);\n    }\n\n    pushChunk(chunk) {\n      if (!this.uploadChannel.isJoined()) {\n        return;\n      }\n\n      this.uploadChannel.push(\"chunk\", chunk).receive(\"ok\", () => {\n        this.entry.progress(this.offset / this.entry.file.size * 100);\n\n        if (!this.isDone()) {\n          this.chunkTimer = setTimeout(() => this.readNextChunk(), this.liveSocket.getLatencySim() || 0);\n        }\n      });\n    }\n\n  }; // js/phoenix_live_view/utils.js\n\n  var logError = (msg, obj) => console.error && console.error(msg, obj);\n\n  var isCid = cid => {\n    let type = typeof cid;\n    return type === \"number\" || type === \"string\" && /^(0|[1-9]\\d*)$/.test(cid);\n  };\n\n  function detectDuplicateIds() {\n    let ids = new Set();\n    let elems = document.querySelectorAll(\"*[id]\");\n\n    for (let i = 0, len = elems.length; i < len; i++) {\n      if (ids.has(elems[i].id)) {\n        console.error(`Multiple IDs detected: ${elems[i].id}. Ensure unique element ids.`);\n      } else {\n        ids.add(elems[i].id);\n      }\n    }\n  }\n\n  var debug = (view, kind, msg, obj) => {\n    if (view.liveSocket.isDebugEnabled()) {\n      console.log(`${view.id} ${kind}: ${msg} - `, obj);\n    }\n  };\n\n  var closure = val => typeof val === \"function\" ? val : function () {\n    return val;\n  };\n\n  var clone = obj => {\n    return JSON.parse(JSON.stringify(obj));\n  };\n\n  var closestPhxBinding = (el, binding, borderEl) => {\n    do {\n      if (el.matches(`[${binding}]`)) {\n        return el;\n      }\n\n      el = el.parentElement || el.parentNode;\n    } while (el !== null && el.nodeType === 1 && !(borderEl && borderEl.isSameNode(el) || el.matches(PHX_VIEW_SELECTOR)));\n\n    return null;\n  };\n\n  var isObject = obj => {\n    return obj !== null && typeof obj === \"object\" && !(obj instanceof Array);\n  };\n\n  var isEqualObj = (obj1, obj2) => JSON.stringify(obj1) === JSON.stringify(obj2);\n\n  var isEmpty = obj => {\n    for (let x in obj) {\n      return false;\n    }\n\n    return true;\n  };\n\n  var maybe = (el, callback) => el && callback(el);\n\n  var channelUploader = function (entries, onError, resp, liveSocket) {\n    entries.forEach(entry => {\n      let entryUploader = new EntryUploader(entry, resp.config.chunk_size, liveSocket);\n      entryUploader.upload();\n    });\n  }; // js/phoenix_live_view/browser.js\n\n\n  var Browser = {\n    canPushState() {\n      return typeof history.pushState !== \"undefined\";\n    },\n\n    dropLocal(localStorage, namespace, subkey) {\n      return localStorage.removeItem(this.localKey(namespace, subkey));\n    },\n\n    updateLocal(localStorage, namespace, subkey, initial, func) {\n      let current = this.getLocal(localStorage, namespace, subkey);\n      let key = this.localKey(namespace, subkey);\n      let newVal = current === null ? initial : func(current);\n      localStorage.setItem(key, JSON.stringify(newVal));\n      return newVal;\n    },\n\n    getLocal(localStorage, namespace, subkey) {\n      return JSON.parse(localStorage.getItem(this.localKey(namespace, subkey)));\n    },\n\n    updateCurrentState(callback) {\n      if (!this.canPushState()) {\n        return;\n      }\n\n      history.replaceState(callback(history.state || {}), \"\", window.location.href);\n    },\n\n    pushState(kind, meta, to) {\n      if (this.canPushState()) {\n        if (to !== window.location.href) {\n          if (meta.type == \"redirect\" && meta.scroll) {\n            let currentState = history.state || {};\n            currentState.scroll = meta.scroll;\n            history.replaceState(currentState, \"\", window.location.href);\n          }\n\n          delete meta.scroll;\n          history[kind + \"State\"](meta, \"\", to || null);\n          let hashEl = this.getHashTargetEl(window.location.hash);\n\n          if (hashEl) {\n            hashEl.scrollIntoView();\n          } else if (meta.type === \"redirect\") {\n            window.scroll(0, 0);\n          }\n        }\n      } else {\n        this.redirect(to);\n      }\n    },\n\n    setCookie(name, value) {\n      document.cookie = `${name}=${value}`;\n    },\n\n    getCookie(name) {\n      return document.cookie.replace(new RegExp(`(?:(?:^|.*;s*)${name}s*=s*([^;]*).*$)|^.*$`), \"$1\");\n    },\n\n    redirect(toURL, flash) {\n      if (flash) {\n        Browser.setCookie(\"__phoenix_flash__\", flash + \"; max-age=60000; path=/\");\n      }\n\n      window.location = toURL;\n    },\n\n    localKey(namespace, subkey) {\n      return `${namespace}-${subkey}`;\n    },\n\n    getHashTargetEl(maybeHash) {\n      let hash = maybeHash.toString().substring(1);\n\n      if (hash === \"\") {\n        return;\n      }\n\n      return document.getElementById(hash) || document.querySelector(`a[name=\"${hash}\"]`);\n    }\n\n  };\n  var browser_default = Browser; // js/phoenix_live_view/dom.js\n\n  var DOM = {\n    byId(id) {\n      return document.getElementById(id) || logError(`no id found for ${id}`);\n    },\n\n    removeClass(el, className) {\n      el.classList.remove(className);\n\n      if (el.classList.length === 0) {\n        el.removeAttribute(\"class\");\n      }\n    },\n\n    all(node, query, callback) {\n      if (!node) {\n        return [];\n      }\n\n      let array = Array.from(node.querySelectorAll(query));\n      return callback ? array.forEach(callback) : array;\n    },\n\n    childNodeLength(html) {\n      let template = document.createElement(\"template\");\n      template.innerHTML = html;\n      return template.content.childElementCount;\n    },\n\n    isUploadInput(el) {\n      return el.type === \"file\" && el.getAttribute(PHX_UPLOAD_REF) !== null;\n    },\n\n    findUploadInputs(node) {\n      return this.all(node, `input[type=\"file\"][${PHX_UPLOAD_REF}]`);\n    },\n\n    findComponentNodeList(node, cid) {\n      return this.filterWithinSameLiveView(this.all(node, `[${PHX_COMPONENT}=\"${cid}\"]`), node);\n    },\n\n    isPhxDestroyed(node) {\n      return node.id && DOM.private(node, \"destroyed\") ? true : false;\n    },\n\n    markPhxChildDestroyed(el) {\n      if (this.isPhxChild(el)) {\n        el.setAttribute(PHX_SESSION, \"\");\n      }\n\n      this.putPrivate(el, \"destroyed\", true);\n    },\n\n    findPhxChildrenInFragment(html, parentId) {\n      let template = document.createElement(\"template\");\n      template.innerHTML = html;\n      return this.findPhxChildren(template.content, parentId);\n    },\n\n    isIgnored(el, phxUpdate) {\n      return (el.getAttribute(phxUpdate) || el.getAttribute(\"data-phx-update\")) === \"ignore\";\n    },\n\n    isPhxUpdate(el, phxUpdate, updateTypes) {\n      return el.getAttribute && updateTypes.indexOf(el.getAttribute(phxUpdate)) >= 0;\n    },\n\n    findPhxChildren(el, parentId) {\n      return this.all(el, `${PHX_VIEW_SELECTOR}[${PHX_PARENT_ID}=\"${parentId}\"]`);\n    },\n\n    findParentCIDs(node, cids) {\n      let initial = new Set(cids);\n      return cids.reduce((acc, cid) => {\n        let selector = `[${PHX_COMPONENT}=\"${cid}\"] [${PHX_COMPONENT}]`;\n        this.filterWithinSameLiveView(this.all(node, selector), node).map(el => parseInt(el.getAttribute(PHX_COMPONENT))).forEach(childCID => acc.delete(childCID));\n        return acc;\n      }, initial);\n    },\n\n    filterWithinSameLiveView(nodes, parent) {\n      if (parent.querySelector(PHX_VIEW_SELECTOR)) {\n        return nodes.filter(el => this.withinSameLiveView(el, parent));\n      } else {\n        return nodes;\n      }\n    },\n\n    withinSameLiveView(node, parent) {\n      while (node = node.parentNode) {\n        if (node.isSameNode(parent)) {\n          return true;\n        }\n\n        if (node.getAttribute(PHX_SESSION) !== null) {\n          return false;\n        }\n      }\n    },\n\n    private(el, key) {\n      return el[PHX_PRIVATE] && el[PHX_PRIVATE][key];\n    },\n\n    deletePrivate(el, key) {\n      el[PHX_PRIVATE] && delete el[PHX_PRIVATE][key];\n    },\n\n    putPrivate(el, key, value) {\n      if (!el[PHX_PRIVATE]) {\n        el[PHX_PRIVATE] = {};\n      }\n\n      el[PHX_PRIVATE][key] = value;\n    },\n\n    updatePrivate(el, key, defaultVal, updateFunc) {\n      let existing = this.private(el, key);\n\n      if (existing === void 0) {\n        this.putPrivate(el, key, updateFunc(defaultVal));\n      } else {\n        this.putPrivate(el, key, updateFunc(existing));\n      }\n    },\n\n    copyPrivates(target, source) {\n      if (source[PHX_PRIVATE]) {\n        target[PHX_PRIVATE] = source[PHX_PRIVATE];\n      }\n    },\n\n    putTitle(str) {\n      let titleEl = document.querySelector(\"title\");\n      let {\n        prefix,\n        suffix\n      } = titleEl.dataset;\n      document.title = `${prefix || \"\"}${str}${suffix || \"\"}`;\n    },\n\n    debounce(el, event, phxDebounce, defaultDebounce, phxThrottle, defaultThrottle, callback) {\n      let debounce = el.getAttribute(phxDebounce);\n      let throttle = el.getAttribute(phxThrottle);\n\n      if (debounce === \"\") {\n        debounce = defaultDebounce;\n      }\n\n      if (throttle === \"\") {\n        throttle = defaultThrottle;\n      }\n\n      let value = debounce || throttle;\n\n      switch (value) {\n        case null:\n          return callback();\n\n        case \"blur\":\n          if (this.once(el, \"debounce-blur\")) {\n            el.addEventListener(\"blur\", () => callback());\n          }\n\n          return;\n\n        default:\n          let timeout = parseInt(value);\n\n          let trigger = () => throttle ? this.deletePrivate(el, THROTTLED) : callback();\n\n          let currentCycle = this.incCycle(el, DEBOUNCE_TRIGGER, trigger);\n\n          if (isNaN(timeout)) {\n            return logError(`invalid throttle/debounce value: ${value}`);\n          }\n\n          if (throttle) {\n            let newKeyDown = false;\n\n            if (event.type === \"keydown\") {\n              let prevKey = this.private(el, DEBOUNCE_PREV_KEY);\n              this.putPrivate(el, DEBOUNCE_PREV_KEY, event.key);\n              newKeyDown = prevKey !== event.key;\n            }\n\n            if (!newKeyDown && this.private(el, THROTTLED)) {\n              return false;\n            } else {\n              callback();\n              this.putPrivate(el, THROTTLED, true);\n              setTimeout(() => this.triggerCycle(el, DEBOUNCE_TRIGGER), timeout);\n            }\n          } else {\n            setTimeout(() => this.triggerCycle(el, DEBOUNCE_TRIGGER, currentCycle), timeout);\n          }\n\n          let form = el.form;\n\n          if (form && this.once(form, \"bind-debounce\")) {\n            form.addEventListener(\"submit\", () => {\n              Array.from(new FormData(form).entries(), ([name]) => {\n                let input = form.querySelector(`[name=\"${name}\"]`);\n                this.incCycle(input, DEBOUNCE_TRIGGER);\n                this.deletePrivate(input, THROTTLED);\n              });\n            });\n          }\n\n          if (this.once(el, \"bind-debounce\")) {\n            el.addEventListener(\"blur\", () => this.triggerCycle(el, DEBOUNCE_TRIGGER));\n          }\n\n      }\n    },\n\n    triggerCycle(el, key, currentCycle) {\n      let [cycle, trigger] = this.private(el, key);\n\n      if (!currentCycle) {\n        currentCycle = cycle;\n      }\n\n      if (currentCycle === cycle) {\n        this.incCycle(el, key);\n        trigger();\n      }\n    },\n\n    once(el, key) {\n      if (this.private(el, key) === true) {\n        return false;\n      }\n\n      this.putPrivate(el, key, true);\n      return true;\n    },\n\n    incCycle(el, key, trigger = function () {}) {\n      let [currentCycle] = this.private(el, key) || [0, trigger];\n      currentCycle++;\n      this.putPrivate(el, key, [currentCycle, trigger]);\n      return currentCycle;\n    },\n\n    discardError(container, el, phxFeedbackFor) {\n      let field = el.getAttribute && el.getAttribute(phxFeedbackFor);\n      let input = field && container.querySelector(`[id=\"${field}\"], [name=\"${field}\"]`);\n\n      if (!input) {\n        return;\n      }\n\n      if (!(this.private(input, PHX_HAS_FOCUSED) || this.private(input.form, PHX_HAS_SUBMITTED))) {\n        el.classList.add(PHX_NO_FEEDBACK_CLASS);\n      }\n    },\n\n    showError(inputEl, phxFeedbackFor) {\n      if (inputEl.id || inputEl.name) {\n        this.all(inputEl.form, `[${phxFeedbackFor}=\"${inputEl.id}\"], [${phxFeedbackFor}=\"${inputEl.name}\"]`, el => {\n          this.removeClass(el, PHX_NO_FEEDBACK_CLASS);\n        });\n      }\n    },\n\n    isPhxChild(node) {\n      return node.getAttribute && node.getAttribute(PHX_PARENT_ID);\n    },\n\n    firstPhxChild(el) {\n      return this.isPhxChild(el) ? el : this.all(el, `[${PHX_PARENT_ID}]`)[0];\n    },\n\n    dispatchEvent(target, eventString, detail = {}) {\n      let event = new CustomEvent(eventString, {\n        bubbles: true,\n        cancelable: true,\n        detail\n      });\n      target.dispatchEvent(event);\n    },\n\n    cloneNode(node, html) {\n      if (typeof html === \"undefined\") {\n        return node.cloneNode(true);\n      } else {\n        let cloned = node.cloneNode(false);\n        cloned.innerHTML = html;\n        return cloned;\n      }\n    },\n\n    mergeAttrs(target, source, opts = {}) {\n      let exclude = opts.exclude || [];\n      let isIgnored = opts.isIgnored;\n      let sourceAttrs = source.attributes;\n\n      for (let i = sourceAttrs.length - 1; i >= 0; i--) {\n        let name = sourceAttrs[i].name;\n\n        if (exclude.indexOf(name) < 0) {\n          target.setAttribute(name, source.getAttribute(name));\n        }\n      }\n\n      let targetAttrs = target.attributes;\n\n      for (let i = targetAttrs.length - 1; i >= 0; i--) {\n        let name = targetAttrs[i].name;\n\n        if (isIgnored) {\n          if (name.startsWith(\"data-\") && !source.hasAttribute(name)) {\n            target.removeAttribute(name);\n          }\n        } else {\n          if (!source.hasAttribute(name)) {\n            target.removeAttribute(name);\n          }\n        }\n      }\n    },\n\n    mergeFocusedInput(target, source) {\n      if (!(target instanceof HTMLSelectElement)) {\n        DOM.mergeAttrs(target, source, {\n          except: [\"value\"]\n        });\n      }\n\n      if (source.readOnly) {\n        target.setAttribute(\"readonly\", true);\n      } else {\n        target.removeAttribute(\"readonly\");\n      }\n    },\n\n    hasSelectionRange(el) {\n      return el.setSelectionRange && (el.type === \"text\" || el.type === \"textarea\");\n    },\n\n    restoreFocus(focused, selectionStart, selectionEnd) {\n      if (!DOM.isTextualInput(focused)) {\n        return;\n      }\n\n      let wasFocused = focused.matches(\":focus\");\n\n      if (focused.readOnly) {\n        focused.blur();\n      }\n\n      if (!wasFocused) {\n        focused.focus();\n      }\n\n      if (this.hasSelectionRange(focused)) {\n        focused.setSelectionRange(selectionStart, selectionEnd);\n      }\n    },\n\n    isFormInput(el) {\n      return /^(?:input|select|textarea)$/i.test(el.tagName) && el.type !== \"button\";\n    },\n\n    syncAttrsToProps(el) {\n      if (el instanceof HTMLInputElement && CHECKABLE_INPUTS.indexOf(el.type.toLocaleLowerCase()) >= 0) {\n        el.checked = el.getAttribute(\"checked\") !== null;\n      }\n    },\n\n    isTextualInput(el) {\n      return FOCUSABLE_INPUTS.indexOf(el.type) >= 0;\n    },\n\n    isNowTriggerFormExternal(el, phxTriggerExternal) {\n      return el.getAttribute && el.getAttribute(phxTriggerExternal) !== null;\n    },\n\n    syncPendingRef(fromEl, toEl, disableWith) {\n      let ref = fromEl.getAttribute(PHX_REF);\n\n      if (ref === null) {\n        return true;\n      }\n\n      if (DOM.isFormInput(fromEl) || fromEl.getAttribute(disableWith) !== null) {\n        if (DOM.isUploadInput(fromEl)) {\n          DOM.mergeAttrs(fromEl, toEl, {\n            isIgnored: true\n          });\n        }\n\n        DOM.putPrivate(fromEl, PHX_REF, toEl);\n        return false;\n      } else {\n        PHX_EVENT_CLASSES.forEach(className => {\n          fromEl.classList.contains(className) && toEl.classList.add(className);\n        });\n        toEl.setAttribute(PHX_REF, ref);\n        return true;\n      }\n    },\n\n    cleanChildNodes(container, phxUpdate) {\n      if (DOM.isPhxUpdate(container, phxUpdate, [\"append\", \"prepend\"])) {\n        let toRemove = [];\n        container.childNodes.forEach(childNode => {\n          if (!childNode.id) {\n            let isEmptyTextNode = childNode.nodeType === Node.TEXT_NODE && childNode.nodeValue.trim() === \"\";\n\n            if (!isEmptyTextNode) {\n              logError(`only HTML element tags with an id are allowed inside containers with phx-update.\n\nremoving illegal node: \"${(childNode.outerHTML || childNode.nodeValue).trim()}\"\n\n`);\n            }\n\n            toRemove.push(childNode);\n          }\n        });\n        toRemove.forEach(childNode => childNode.remove());\n      }\n    },\n\n    replaceRootContainer(container, tagName, attrs) {\n      let retainedAttrs = new Set([\"id\", PHX_SESSION, PHX_STATIC, PHX_MAIN, PHX_ROOT_ID]);\n\n      if (container.tagName.toLowerCase() === tagName.toLowerCase()) {\n        Array.from(container.attributes).filter(attr => !retainedAttrs.has(attr.name.toLowerCase())).forEach(attr => container.removeAttribute(attr.name));\n        Object.keys(attrs).filter(name => !retainedAttrs.has(name.toLowerCase())).forEach(attr => container.setAttribute(attr, attrs[attr]));\n        return container;\n      } else {\n        let newContainer = document.createElement(tagName);\n        Object.keys(attrs).forEach(attr => newContainer.setAttribute(attr, attrs[attr]));\n        retainedAttrs.forEach(attr => newContainer.setAttribute(attr, container.getAttribute(attr)));\n        newContainer.innerHTML = container.innerHTML;\n        container.replaceWith(newContainer);\n        return newContainer;\n      }\n    },\n\n    getSticky(el, name, defaultVal) {\n      let op = (DOM.private(el, \"sticky\") || []).find(([existingName]) => name === existingName);\n\n      if (op) {\n        let [_name, _op, stashedResult] = op;\n        return stashedResult;\n      } else {\n        return typeof defaultVal === \"function\" ? defaultVal() : defaultVal;\n      }\n    },\n\n    deleteSticky(el, name) {\n      this.updatePrivate(el, \"sticky\", [], ops => {\n        return ops.filter(([existingName, _]) => existingName !== name);\n      });\n    },\n\n    putSticky(el, name, op) {\n      let stashedResult = op(el);\n      this.updatePrivate(el, \"sticky\", [], ops => {\n        let existingIndex = ops.findIndex(([existingName]) => name === existingName);\n\n        if (existingIndex >= 0) {\n          ops[existingIndex] = [name, op, stashedResult];\n        } else {\n          ops.push([name, op, stashedResult]);\n        }\n\n        return ops;\n      });\n    },\n\n    applyStickyOperations(el) {\n      let ops = DOM.private(el, \"sticky\");\n\n      if (!ops) {\n        return;\n      }\n\n      ops.forEach(([name, op, _stashed]) => this.putSticky(el, name, op));\n    }\n\n  };\n  var dom_default = DOM; // js/phoenix_live_view/upload_entry.js\n\n  var UploadEntry = class {\n    static isActive(fileEl, file) {\n      let isNew = file._phxRef === void 0;\n      let activeRefs = fileEl.getAttribute(PHX_ACTIVE_ENTRY_REFS).split(\",\");\n      let isActive = activeRefs.indexOf(LiveUploader.genFileRef(file)) >= 0;\n      return file.size > 0 && (isNew || isActive);\n    }\n\n    static isPreflighted(fileEl, file) {\n      let preflightedRefs = fileEl.getAttribute(PHX_PREFLIGHTED_REFS).split(\",\");\n      let isPreflighted = preflightedRefs.indexOf(LiveUploader.genFileRef(file)) >= 0;\n      return isPreflighted && this.isActive(fileEl, file);\n    }\n\n    constructor(fileEl, file, view) {\n      this.ref = LiveUploader.genFileRef(file);\n      this.fileEl = fileEl;\n      this.file = file;\n      this.view = view;\n      this.meta = null;\n      this._isCancelled = false;\n      this._isDone = false;\n      this._progress = 0;\n      this._lastProgressSent = -1;\n\n      this._onDone = function () {};\n\n      this._onElUpdated = this.onElUpdated.bind(this);\n      this.fileEl.addEventListener(PHX_LIVE_FILE_UPDATED, this._onElUpdated);\n    }\n\n    metadata() {\n      return this.meta;\n    }\n\n    progress(progress) {\n      this._progress = Math.floor(progress);\n\n      if (this._progress > this._lastProgressSent) {\n        if (this._progress >= 100) {\n          this._progress = 100;\n          this._lastProgressSent = 100;\n          this._isDone = true;\n          this.view.pushFileProgress(this.fileEl, this.ref, 100, () => {\n            LiveUploader.untrackFile(this.fileEl, this.file);\n\n            this._onDone();\n          });\n        } else {\n          this._lastProgressSent = this._progress;\n          this.view.pushFileProgress(this.fileEl, this.ref, this._progress);\n        }\n      }\n    }\n\n    cancel() {\n      this._isCancelled = true;\n      this._isDone = true;\n\n      this._onDone();\n    }\n\n    isDone() {\n      return this._isDone;\n    }\n\n    error(reason = \"failed\") {\n      this.view.pushFileProgress(this.fileEl, this.ref, {\n        error: reason\n      });\n      LiveUploader.clearFiles(this.fileEl);\n    }\n\n    onDone(callback) {\n      this._onDone = () => {\n        this.fileEl.removeEventListener(PHX_LIVE_FILE_UPDATED, this._onElUpdated);\n        callback();\n      };\n    }\n\n    onElUpdated() {\n      let activeRefs = this.fileEl.getAttribute(PHX_ACTIVE_ENTRY_REFS).split(\",\");\n\n      if (activeRefs.indexOf(this.ref) === -1) {\n        this.cancel();\n      }\n    }\n\n    toPreflightPayload() {\n      return {\n        last_modified: this.file.lastModified,\n        name: this.file.name,\n        size: this.file.size,\n        type: this.file.type,\n        ref: this.ref\n      };\n    }\n\n    uploader(uploaders) {\n      if (this.meta.uploader) {\n        let callback = uploaders[this.meta.uploader] || logError(`no uploader configured for ${this.meta.uploader}`);\n        return {\n          name: this.meta.uploader,\n          callback\n        };\n      } else {\n        return {\n          name: \"channel\",\n          callback: channelUploader\n        };\n      }\n    }\n\n    zipPostFlight(resp) {\n      this.meta = resp.entries[this.ref];\n\n      if (!this.meta) {\n        logError(`no preflight upload response returned with ref ${this.ref}`, {\n          input: this.fileEl,\n          response: resp\n        });\n      }\n    }\n\n  }; // js/phoenix_live_view/live_uploader.js\n\n  var liveUploaderFileRef = 0;\n  var LiveUploader = class {\n    static genFileRef(file) {\n      let ref = file._phxRef;\n\n      if (ref !== void 0) {\n        return ref;\n      } else {\n        file._phxRef = (liveUploaderFileRef++).toString();\n        return file._phxRef;\n      }\n    }\n\n    static getEntryDataURL(inputEl, ref, callback) {\n      let file = this.activeFiles(inputEl).find(file2 => this.genFileRef(file2) === ref);\n      callback(URL.createObjectURL(file));\n    }\n\n    static hasUploadsInProgress(formEl) {\n      let active = 0;\n      dom_default.findUploadInputs(formEl).forEach(input => {\n        if (input.getAttribute(PHX_PREFLIGHTED_REFS) !== input.getAttribute(PHX_DONE_REFS)) {\n          active++;\n        }\n      });\n      return active > 0;\n    }\n\n    static serializeUploads(inputEl) {\n      let files = this.activeFiles(inputEl);\n      let fileData = {};\n      files.forEach(file => {\n        let entry = {\n          path: inputEl.name\n        };\n        let uploadRef = inputEl.getAttribute(PHX_UPLOAD_REF);\n        fileData[uploadRef] = fileData[uploadRef] || [];\n        entry.ref = this.genFileRef(file);\n        entry.name = file.name || entry.ref;\n        entry.type = file.type;\n        entry.size = file.size;\n        fileData[uploadRef].push(entry);\n      });\n      return fileData;\n    }\n\n    static clearFiles(inputEl) {\n      inputEl.value = null;\n      inputEl.removeAttribute(PHX_UPLOAD_REF);\n      dom_default.putPrivate(inputEl, \"files\", []);\n    }\n\n    static untrackFile(inputEl, file) {\n      dom_default.putPrivate(inputEl, \"files\", dom_default.private(inputEl, \"files\").filter(f => !Object.is(f, file)));\n    }\n\n    static trackFiles(inputEl, files) {\n      if (inputEl.getAttribute(\"multiple\") !== null) {\n        let newFiles = files.filter(file => !this.activeFiles(inputEl).find(f => Object.is(f, file)));\n        dom_default.putPrivate(inputEl, \"files\", this.activeFiles(inputEl).concat(newFiles));\n        inputEl.value = null;\n      } else {\n        dom_default.putPrivate(inputEl, \"files\", files);\n      }\n    }\n\n    static activeFileInputs(formEl) {\n      let fileInputs = dom_default.findUploadInputs(formEl);\n      return Array.from(fileInputs).filter(el => el.files && this.activeFiles(el).length > 0);\n    }\n\n    static activeFiles(input) {\n      return (dom_default.private(input, \"files\") || []).filter(f => UploadEntry.isActive(input, f));\n    }\n\n    static inputsAwaitingPreflight(formEl) {\n      let fileInputs = dom_default.findUploadInputs(formEl);\n      return Array.from(fileInputs).filter(input => this.filesAwaitingPreflight(input).length > 0);\n    }\n\n    static filesAwaitingPreflight(input) {\n      return this.activeFiles(input).filter(f => !UploadEntry.isPreflighted(input, f));\n    }\n\n    constructor(inputEl, view, onComplete) {\n      this.view = view;\n      this.onComplete = onComplete;\n      this._entries = Array.from(LiveUploader.filesAwaitingPreflight(inputEl) || []).map(file => new UploadEntry(inputEl, file, view));\n      this.numEntriesInProgress = this._entries.length;\n    }\n\n    entries() {\n      return this._entries;\n    }\n\n    initAdapterUpload(resp, onError, liveSocket) {\n      this._entries = this._entries.map(entry => {\n        entry.zipPostFlight(resp);\n        entry.onDone(() => {\n          this.numEntriesInProgress--;\n\n          if (this.numEntriesInProgress === 0) {\n            this.onComplete();\n          }\n        });\n        return entry;\n      });\n\n      let groupedEntries = this._entries.reduce((acc, entry) => {\n        let {\n          name,\n          callback\n        } = entry.uploader(liveSocket.uploaders);\n        acc[name] = acc[name] || {\n          callback,\n          entries: []\n        };\n        acc[name].entries.push(entry);\n        return acc;\n      }, {});\n\n      for (let name in groupedEntries) {\n        let {\n          callback,\n          entries\n        } = groupedEntries[name];\n        callback(entries, onError, resp, liveSocket);\n      }\n    }\n\n  }; // js/phoenix_live_view/hooks.js\n\n  var Hooks = {\n    LiveFileUpload: {\n      activeRefs() {\n        return this.el.getAttribute(PHX_ACTIVE_ENTRY_REFS);\n      },\n\n      preflightedRefs() {\n        return this.el.getAttribute(PHX_PREFLIGHTED_REFS);\n      },\n\n      mounted() {\n        this.preflightedWas = this.preflightedRefs();\n      },\n\n      updated() {\n        let newPreflights = this.preflightedRefs();\n\n        if (this.preflightedWas !== newPreflights) {\n          this.preflightedWas = newPreflights;\n\n          if (newPreflights === \"\") {\n            this.__view.cancelSubmit(this.el.form);\n          }\n        }\n\n        if (this.activeRefs() === \"\") {\n          this.el.value = null;\n        }\n\n        this.el.dispatchEvent(new CustomEvent(PHX_LIVE_FILE_UPDATED));\n      }\n\n    },\n    LiveImgPreview: {\n      mounted() {\n        this.ref = this.el.getAttribute(\"data-phx-entry-ref\");\n        this.inputEl = document.getElementById(this.el.getAttribute(PHX_UPLOAD_REF));\n        LiveUploader.getEntryDataURL(this.inputEl, this.ref, url => {\n          this.url = url;\n          this.el.src = url;\n        });\n      },\n\n      destroyed() {\n        URL.revokeObjectURL(this.url);\n      }\n\n    }\n  };\n  var hooks_default = Hooks; // js/phoenix_live_view/dom_post_morph_restorer.js\n\n  var DOMPostMorphRestorer = class {\n    constructor(containerBefore, containerAfter, updateType) {\n      let idsBefore = new Set();\n      let idsAfter = new Set([...containerAfter.children].map(child => child.id));\n      let elementsToModify = [];\n      Array.from(containerBefore.children).forEach(child => {\n        if (child.id) {\n          idsBefore.add(child.id);\n\n          if (idsAfter.has(child.id)) {\n            let previousElementId = child.previousElementSibling && child.previousElementSibling.id;\n            elementsToModify.push({\n              elementId: child.id,\n              previousElementId\n            });\n          }\n        }\n      });\n      this.containerId = containerAfter.id;\n      this.updateType = updateType;\n      this.elementsToModify = elementsToModify;\n      this.elementIdsToAdd = [...idsAfter].filter(id => !idsBefore.has(id));\n    }\n\n    perform() {\n      let container = dom_default.byId(this.containerId);\n      this.elementsToModify.forEach(elementToModify => {\n        if (elementToModify.previousElementId) {\n          maybe(document.getElementById(elementToModify.previousElementId), previousElem => {\n            maybe(document.getElementById(elementToModify.elementId), elem => {\n              let isInRightPlace = elem.previousElementSibling && elem.previousElementSibling.id == previousElem.id;\n\n              if (!isInRightPlace) {\n                previousElem.insertAdjacentElement(\"afterend\", elem);\n              }\n            });\n          });\n        } else {\n          maybe(document.getElementById(elementToModify.elementId), elem => {\n            let isInRightPlace = elem.previousElementSibling == null;\n\n            if (!isInRightPlace) {\n              container.insertAdjacentElement(\"afterbegin\", elem);\n            }\n          });\n        }\n      });\n\n      if (this.updateType == \"prepend\") {\n        this.elementIdsToAdd.reverse().forEach(elemId => {\n          maybe(document.getElementById(elemId), elem => container.insertAdjacentElement(\"afterbegin\", elem));\n        });\n      }\n    }\n\n  }; // node_modules/morphdom/dist/morphdom-esm.js\n\n  var DOCUMENT_FRAGMENT_NODE = 11;\n\n  function morphAttrs(fromNode, toNode) {\n    var toNodeAttrs = toNode.attributes;\n    var attr;\n    var attrName;\n    var attrNamespaceURI;\n    var attrValue;\n    var fromValue;\n\n    if (toNode.nodeType === DOCUMENT_FRAGMENT_NODE || fromNode.nodeType === DOCUMENT_FRAGMENT_NODE) {\n      return;\n    }\n\n    for (var i = toNodeAttrs.length - 1; i >= 0; i--) {\n      attr = toNodeAttrs[i];\n      attrName = attr.name;\n      attrNamespaceURI = attr.namespaceURI;\n      attrValue = attr.value;\n\n      if (attrNamespaceURI) {\n        attrName = attr.localName || attrName;\n        fromValue = fromNode.getAttributeNS(attrNamespaceURI, attrName);\n\n        if (fromValue !== attrValue) {\n          if (attr.prefix === \"xmlns\") {\n            attrName = attr.name;\n          }\n\n          fromNode.setAttributeNS(attrNamespaceURI, attrName, attrValue);\n        }\n      } else {\n        fromValue = fromNode.getAttribute(attrName);\n\n        if (fromValue !== attrValue) {\n          fromNode.setAttribute(attrName, attrValue);\n        }\n      }\n    }\n\n    var fromNodeAttrs = fromNode.attributes;\n\n    for (var d = fromNodeAttrs.length - 1; d >= 0; d--) {\n      attr = fromNodeAttrs[d];\n      attrName = attr.name;\n      attrNamespaceURI = attr.namespaceURI;\n\n      if (attrNamespaceURI) {\n        attrName = attr.localName || attrName;\n\n        if (!toNode.hasAttributeNS(attrNamespaceURI, attrName)) {\n          fromNode.removeAttributeNS(attrNamespaceURI, attrName);\n        }\n      } else {\n        if (!toNode.hasAttribute(attrName)) {\n          fromNode.removeAttribute(attrName);\n        }\n      }\n    }\n  }\n\n  var range;\n  var NS_XHTML = \"http://www.w3.org/1999/xhtml\";\n  var doc = typeof document === \"undefined\" ? void 0 : document;\n  var HAS_TEMPLATE_SUPPORT = !!doc && \"content\" in doc.createElement(\"template\");\n  var HAS_RANGE_SUPPORT = !!doc && doc.createRange && \"createContextualFragment\" in doc.createRange();\n\n  function createFragmentFromTemplate(str) {\n    var template = doc.createElement(\"template\");\n    template.innerHTML = str;\n    return template.content.childNodes[0];\n  }\n\n  function createFragmentFromRange(str) {\n    if (!range) {\n      range = doc.createRange();\n      range.selectNode(doc.body);\n    }\n\n    var fragment = range.createContextualFragment(str);\n    return fragment.childNodes[0];\n  }\n\n  function createFragmentFromWrap(str) {\n    var fragment = doc.createElement(\"body\");\n    fragment.innerHTML = str;\n    return fragment.childNodes[0];\n  }\n\n  function toElement(str) {\n    str = str.trim();\n\n    if (HAS_TEMPLATE_SUPPORT) {\n      return createFragmentFromTemplate(str);\n    } else if (HAS_RANGE_SUPPORT) {\n      return createFragmentFromRange(str);\n    }\n\n    return createFragmentFromWrap(str);\n  }\n\n  function compareNodeNames(fromEl, toEl) {\n    var fromNodeName = fromEl.nodeName;\n    var toNodeName = toEl.nodeName;\n    var fromCodeStart, toCodeStart;\n\n    if (fromNodeName === toNodeName) {\n      return true;\n    }\n\n    fromCodeStart = fromNodeName.charCodeAt(0);\n    toCodeStart = toNodeName.charCodeAt(0);\n\n    if (fromCodeStart <= 90 && toCodeStart >= 97) {\n      return fromNodeName === toNodeName.toUpperCase();\n    } else if (toCodeStart <= 90 && fromCodeStart >= 97) {\n      return toNodeName === fromNodeName.toUpperCase();\n    } else {\n      return false;\n    }\n  }\n\n  function createElementNS(name, namespaceURI) {\n    return !namespaceURI || namespaceURI === NS_XHTML ? doc.createElement(name) : doc.createElementNS(namespaceURI, name);\n  }\n\n  function moveChildren(fromEl, toEl) {\n    var curChild = fromEl.firstChild;\n\n    while (curChild) {\n      var nextChild = curChild.nextSibling;\n      toEl.appendChild(curChild);\n      curChild = nextChild;\n    }\n\n    return toEl;\n  }\n\n  function syncBooleanAttrProp(fromEl, toEl, name) {\n    if (fromEl[name] !== toEl[name]) {\n      fromEl[name] = toEl[name];\n\n      if (fromEl[name]) {\n        fromEl.setAttribute(name, \"\");\n      } else {\n        fromEl.removeAttribute(name);\n      }\n    }\n  }\n\n  var specialElHandlers = {\n    OPTION: function (fromEl, toEl) {\n      var parentNode = fromEl.parentNode;\n\n      if (parentNode) {\n        var parentName = parentNode.nodeName.toUpperCase();\n\n        if (parentName === \"OPTGROUP\") {\n          parentNode = parentNode.parentNode;\n          parentName = parentNode && parentNode.nodeName.toUpperCase();\n        }\n\n        if (parentName === \"SELECT\" && !parentNode.hasAttribute(\"multiple\")) {\n          if (fromEl.hasAttribute(\"selected\") && !toEl.selected) {\n            fromEl.setAttribute(\"selected\", \"selected\");\n            fromEl.removeAttribute(\"selected\");\n          }\n\n          parentNode.selectedIndex = -1;\n        }\n      }\n\n      syncBooleanAttrProp(fromEl, toEl, \"selected\");\n    },\n    INPUT: function (fromEl, toEl) {\n      syncBooleanAttrProp(fromEl, toEl, \"checked\");\n      syncBooleanAttrProp(fromEl, toEl, \"disabled\");\n\n      if (fromEl.value !== toEl.value) {\n        fromEl.value = toEl.value;\n      }\n\n      if (!toEl.hasAttribute(\"value\")) {\n        fromEl.removeAttribute(\"value\");\n      }\n    },\n    TEXTAREA: function (fromEl, toEl) {\n      var newValue = toEl.value;\n\n      if (fromEl.value !== newValue) {\n        fromEl.value = newValue;\n      }\n\n      var firstChild = fromEl.firstChild;\n\n      if (firstChild) {\n        var oldValue = firstChild.nodeValue;\n\n        if (oldValue == newValue || !newValue && oldValue == fromEl.placeholder) {\n          return;\n        }\n\n        firstChild.nodeValue = newValue;\n      }\n    },\n    SELECT: function (fromEl, toEl) {\n      if (!toEl.hasAttribute(\"multiple\")) {\n        var selectedIndex = -1;\n        var i = 0;\n        var curChild = fromEl.firstChild;\n        var optgroup;\n        var nodeName;\n\n        while (curChild) {\n          nodeName = curChild.nodeName && curChild.nodeName.toUpperCase();\n\n          if (nodeName === \"OPTGROUP\") {\n            optgroup = curChild;\n            curChild = optgroup.firstChild;\n          } else {\n            if (nodeName === \"OPTION\") {\n              if (curChild.hasAttribute(\"selected\")) {\n                selectedIndex = i;\n                break;\n              }\n\n              i++;\n            }\n\n            curChild = curChild.nextSibling;\n\n            if (!curChild && optgroup) {\n              curChild = optgroup.nextSibling;\n              optgroup = null;\n            }\n          }\n        }\n\n        fromEl.selectedIndex = selectedIndex;\n      }\n    }\n  };\n  var ELEMENT_NODE = 1;\n  var DOCUMENT_FRAGMENT_NODE$1 = 11;\n  var TEXT_NODE = 3;\n  var COMMENT_NODE = 8;\n\n  function noop() {}\n\n  function defaultGetNodeKey(node) {\n    if (node) {\n      return node.getAttribute && node.getAttribute(\"id\") || node.id;\n    }\n  }\n\n  function morphdomFactory(morphAttrs2) {\n    return function morphdom2(fromNode, toNode, options) {\n      if (!options) {\n        options = {};\n      }\n\n      if (typeof toNode === \"string\") {\n        if (fromNode.nodeName === \"#document\" || fromNode.nodeName === \"HTML\" || fromNode.nodeName === \"BODY\") {\n          var toNodeHtml = toNode;\n          toNode = doc.createElement(\"html\");\n          toNode.innerHTML = toNodeHtml;\n        } else {\n          toNode = toElement(toNode);\n        }\n      }\n\n      var getNodeKey = options.getNodeKey || defaultGetNodeKey;\n      var onBeforeNodeAdded = options.onBeforeNodeAdded || noop;\n      var onNodeAdded = options.onNodeAdded || noop;\n      var onBeforeElUpdated = options.onBeforeElUpdated || noop;\n      var onElUpdated = options.onElUpdated || noop;\n      var onBeforeNodeDiscarded = options.onBeforeNodeDiscarded || noop;\n      var onNodeDiscarded = options.onNodeDiscarded || noop;\n      var onBeforeElChildrenUpdated = options.onBeforeElChildrenUpdated || noop;\n      var childrenOnly = options.childrenOnly === true;\n      var fromNodesLookup = Object.create(null);\n      var keyedRemovalList = [];\n\n      function addKeyedRemoval(key) {\n        keyedRemovalList.push(key);\n      }\n\n      function walkDiscardedChildNodes(node, skipKeyedNodes) {\n        if (node.nodeType === ELEMENT_NODE) {\n          var curChild = node.firstChild;\n\n          while (curChild) {\n            var key = void 0;\n\n            if (skipKeyedNodes && (key = getNodeKey(curChild))) {\n              addKeyedRemoval(key);\n            } else {\n              onNodeDiscarded(curChild);\n\n              if (curChild.firstChild) {\n                walkDiscardedChildNodes(curChild, skipKeyedNodes);\n              }\n            }\n\n            curChild = curChild.nextSibling;\n          }\n        }\n      }\n\n      function removeNode(node, parentNode, skipKeyedNodes) {\n        if (onBeforeNodeDiscarded(node) === false) {\n          return;\n        }\n\n        if (parentNode) {\n          parentNode.removeChild(node);\n        }\n\n        onNodeDiscarded(node);\n        walkDiscardedChildNodes(node, skipKeyedNodes);\n      }\n\n      function indexTree(node) {\n        if (node.nodeType === ELEMENT_NODE || node.nodeType === DOCUMENT_FRAGMENT_NODE$1) {\n          var curChild = node.firstChild;\n\n          while (curChild) {\n            var key = getNodeKey(curChild);\n\n            if (key) {\n              fromNodesLookup[key] = curChild;\n            }\n\n            indexTree(curChild);\n            curChild = curChild.nextSibling;\n          }\n        }\n      }\n\n      indexTree(fromNode);\n\n      function handleNodeAdded(el) {\n        onNodeAdded(el);\n        var curChild = el.firstChild;\n\n        while (curChild) {\n          var nextSibling = curChild.nextSibling;\n          var key = getNodeKey(curChild);\n\n          if (key) {\n            var unmatchedFromEl = fromNodesLookup[key];\n\n            if (unmatchedFromEl && compareNodeNames(curChild, unmatchedFromEl)) {\n              curChild.parentNode.replaceChild(unmatchedFromEl, curChild);\n              morphEl(unmatchedFromEl, curChild);\n            } else {\n              handleNodeAdded(curChild);\n            }\n          } else {\n            handleNodeAdded(curChild);\n          }\n\n          curChild = nextSibling;\n        }\n      }\n\n      function cleanupFromEl(fromEl, curFromNodeChild, curFromNodeKey) {\n        while (curFromNodeChild) {\n          var fromNextSibling = curFromNodeChild.nextSibling;\n\n          if (curFromNodeKey = getNodeKey(curFromNodeChild)) {\n            addKeyedRemoval(curFromNodeKey);\n          } else {\n            removeNode(curFromNodeChild, fromEl, true);\n          }\n\n          curFromNodeChild = fromNextSibling;\n        }\n      }\n\n      function morphEl(fromEl, toEl, childrenOnly2) {\n        var toElKey = getNodeKey(toEl);\n\n        if (toElKey) {\n          delete fromNodesLookup[toElKey];\n        }\n\n        if (!childrenOnly2) {\n          if (onBeforeElUpdated(fromEl, toEl) === false) {\n            return;\n          }\n\n          morphAttrs2(fromEl, toEl);\n          onElUpdated(fromEl);\n\n          if (onBeforeElChildrenUpdated(fromEl, toEl) === false) {\n            return;\n          }\n        }\n\n        if (fromEl.nodeName !== \"TEXTAREA\") {\n          morphChildren(fromEl, toEl);\n        } else {\n          specialElHandlers.TEXTAREA(fromEl, toEl);\n        }\n      }\n\n      function morphChildren(fromEl, toEl) {\n        var curToNodeChild = toEl.firstChild;\n        var curFromNodeChild = fromEl.firstChild;\n        var curToNodeKey;\n        var curFromNodeKey;\n        var fromNextSibling;\n        var toNextSibling;\n        var matchingFromEl;\n\n        outer: while (curToNodeChild) {\n          toNextSibling = curToNodeChild.nextSibling;\n          curToNodeKey = getNodeKey(curToNodeChild);\n\n          while (curFromNodeChild) {\n            fromNextSibling = curFromNodeChild.nextSibling;\n\n            if (curToNodeChild.isSameNode && curToNodeChild.isSameNode(curFromNodeChild)) {\n              curToNodeChild = toNextSibling;\n              curFromNodeChild = fromNextSibling;\n              continue outer;\n            }\n\n            curFromNodeKey = getNodeKey(curFromNodeChild);\n            var curFromNodeType = curFromNodeChild.nodeType;\n            var isCompatible = void 0;\n\n            if (curFromNodeType === curToNodeChild.nodeType) {\n              if (curFromNodeType === ELEMENT_NODE) {\n                if (curToNodeKey) {\n                  if (curToNodeKey !== curFromNodeKey) {\n                    if (matchingFromEl = fromNodesLookup[curToNodeKey]) {\n                      if (fromNextSibling === matchingFromEl) {\n                        isCompatible = false;\n                      } else {\n                        fromEl.insertBefore(matchingFromEl, curFromNodeChild);\n\n                        if (curFromNodeKey) {\n                          addKeyedRemoval(curFromNodeKey);\n                        } else {\n                          removeNode(curFromNodeChild, fromEl, true);\n                        }\n\n                        curFromNodeChild = matchingFromEl;\n                      }\n                    } else {\n                      isCompatible = false;\n                    }\n                  }\n                } else if (curFromNodeKey) {\n                  isCompatible = false;\n                }\n\n                isCompatible = isCompatible !== false && compareNodeNames(curFromNodeChild, curToNodeChild);\n\n                if (isCompatible) {\n                  morphEl(curFromNodeChild, curToNodeChild);\n                }\n              } else if (curFromNodeType === TEXT_NODE || curFromNodeType == COMMENT_NODE) {\n                isCompatible = true;\n\n                if (curFromNodeChild.nodeValue !== curToNodeChild.nodeValue) {\n                  curFromNodeChild.nodeValue = curToNodeChild.nodeValue;\n                }\n              }\n            }\n\n            if (isCompatible) {\n              curToNodeChild = toNextSibling;\n              curFromNodeChild = fromNextSibling;\n              continue outer;\n            }\n\n            if (curFromNodeKey) {\n              addKeyedRemoval(curFromNodeKey);\n            } else {\n              removeNode(curFromNodeChild, fromEl, true);\n            }\n\n            curFromNodeChild = fromNextSibling;\n          }\n\n          if (curToNodeKey && (matchingFromEl = fromNodesLookup[curToNodeKey]) && compareNodeNames(matchingFromEl, curToNodeChild)) {\n            fromEl.appendChild(matchingFromEl);\n            morphEl(matchingFromEl, curToNodeChild);\n          } else {\n            var onBeforeNodeAddedResult = onBeforeNodeAdded(curToNodeChild);\n\n            if (onBeforeNodeAddedResult !== false) {\n              if (onBeforeNodeAddedResult) {\n                curToNodeChild = onBeforeNodeAddedResult;\n              }\n\n              if (curToNodeChild.actualize) {\n                curToNodeChild = curToNodeChild.actualize(fromEl.ownerDocument || doc);\n              }\n\n              fromEl.appendChild(curToNodeChild);\n              handleNodeAdded(curToNodeChild);\n            }\n          }\n\n          curToNodeChild = toNextSibling;\n          curFromNodeChild = fromNextSibling;\n        }\n\n        cleanupFromEl(fromEl, curFromNodeChild, curFromNodeKey);\n        var specialElHandler = specialElHandlers[fromEl.nodeName];\n\n        if (specialElHandler) {\n          specialElHandler(fromEl, toEl);\n        }\n      }\n\n      var morphedNode = fromNode;\n      var morphedNodeType = morphedNode.nodeType;\n      var toNodeType = toNode.nodeType;\n\n      if (!childrenOnly) {\n        if (morphedNodeType === ELEMENT_NODE) {\n          if (toNodeType === ELEMENT_NODE) {\n            if (!compareNodeNames(fromNode, toNode)) {\n              onNodeDiscarded(fromNode);\n              morphedNode = moveChildren(fromNode, createElementNS(toNode.nodeName, toNode.namespaceURI));\n            }\n          } else {\n            morphedNode = toNode;\n          }\n        } else if (morphedNodeType === TEXT_NODE || morphedNodeType === COMMENT_NODE) {\n          if (toNodeType === morphedNodeType) {\n            if (morphedNode.nodeValue !== toNode.nodeValue) {\n              morphedNode.nodeValue = toNode.nodeValue;\n            }\n\n            return morphedNode;\n          } else {\n            morphedNode = toNode;\n          }\n        }\n      }\n\n      if (morphedNode === toNode) {\n        onNodeDiscarded(fromNode);\n      } else {\n        if (toNode.isSameNode && toNode.isSameNode(morphedNode)) {\n          return;\n        }\n\n        morphEl(morphedNode, toNode, childrenOnly);\n\n        if (keyedRemovalList) {\n          for (var i = 0, len = keyedRemovalList.length; i < len; i++) {\n            var elToRemove = fromNodesLookup[keyedRemovalList[i]];\n\n            if (elToRemove) {\n              removeNode(elToRemove, elToRemove.parentNode, false);\n            }\n          }\n        }\n      }\n\n      if (!childrenOnly && morphedNode !== fromNode && fromNode.parentNode) {\n        if (morphedNode.actualize) {\n          morphedNode = morphedNode.actualize(fromNode.ownerDocument || doc);\n        }\n\n        fromNode.parentNode.replaceChild(morphedNode, fromNode);\n      }\n\n      return morphedNode;\n    };\n  }\n\n  var morphdom = morphdomFactory(morphAttrs);\n  var morphdom_esm_default = morphdom; // js/phoenix_live_view/dom_patch.js\n\n  var DOMPatch = class {\n    static patchEl(fromEl, toEl, activeElement) {\n      morphdom_esm_default(fromEl, toEl, {\n        childrenOnly: false,\n        onBeforeElUpdated: (fromEl2, toEl2) => {\n          if (activeElement && activeElement.isSameNode(fromEl2) && dom_default.isFormInput(fromEl2)) {\n            dom_default.mergeFocusedInput(fromEl2, toEl2);\n            return false;\n          }\n        }\n      });\n    }\n\n    constructor(view, container, id, html, targetCID) {\n      this.view = view;\n      this.liveSocket = view.liveSocket;\n      this.container = container;\n      this.id = id;\n      this.rootID = view.root.id;\n      this.html = html;\n      this.targetCID = targetCID;\n      this.cidPatch = isCid(this.targetCID);\n      this.callbacks = {\n        beforeadded: [],\n        beforeupdated: [],\n        beforephxChildAdded: [],\n        afteradded: [],\n        afterupdated: [],\n        afterdiscarded: [],\n        afterphxChildAdded: [],\n        aftertransitionsDiscarded: []\n      };\n    }\n\n    before(kind, callback) {\n      this.callbacks[`before${kind}`].push(callback);\n    }\n\n    after(kind, callback) {\n      this.callbacks[`after${kind}`].push(callback);\n    }\n\n    trackBefore(kind, ...args) {\n      this.callbacks[`before${kind}`].forEach(callback => callback(...args));\n    }\n\n    trackAfter(kind, ...args) {\n      this.callbacks[`after${kind}`].forEach(callback => callback(...args));\n    }\n\n    markPrunableContentForRemoval() {\n      dom_default.all(this.container, \"[phx-update=append] > *, [phx-update=prepend] > *\", el => {\n        el.setAttribute(PHX_PRUNE, \"\");\n      });\n    }\n\n    perform() {\n      let {\n        view,\n        liveSocket,\n        container,\n        html\n      } = this;\n      let targetContainer = this.isCIDPatch() ? this.targetCIDContainer(html) : container;\n\n      if (this.isCIDPatch() && !targetContainer) {\n        return;\n      }\n\n      let focused = liveSocket.getActiveElement();\n      let {\n        selectionStart,\n        selectionEnd\n      } = focused && dom_default.hasSelectionRange(focused) ? focused : {};\n      let phxUpdate = liveSocket.binding(PHX_UPDATE);\n      let phxFeedbackFor = liveSocket.binding(PHX_FEEDBACK_FOR);\n      let disableWith = liveSocket.binding(PHX_DISABLE_WITH);\n      let phxTriggerExternal = liveSocket.binding(PHX_TRIGGER_ACTION);\n      let phxRemove = liveSocket.binding(\"remove\");\n      let added = [];\n      let updates = [];\n      let appendPrependUpdates = [];\n      let pendingRemoves = [];\n      let externalFormTriggered = null;\n      let diffHTML = liveSocket.time(\"premorph container prep\", () => {\n        return this.buildDiffHTML(container, html, phxUpdate, targetContainer);\n      });\n      this.trackBefore(\"added\", container);\n      this.trackBefore(\"updated\", container, container);\n      liveSocket.time(\"morphdom\", () => {\n        morphdom_esm_default(targetContainer, diffHTML, {\n          childrenOnly: targetContainer.getAttribute(PHX_COMPONENT) === null,\n          getNodeKey: node => {\n            return dom_default.isPhxDestroyed(node) ? null : node.id;\n          },\n          onBeforeNodeAdded: el => {\n            this.trackBefore(\"added\", el);\n            return el;\n          },\n          onNodeAdded: el => {\n            if (el instanceof HTMLImageElement && el.srcset) {\n              el.srcset = el.srcset;\n            } else if (el instanceof HTMLVideoElement && el.autoplay) {\n              el.play();\n            }\n\n            if (dom_default.isNowTriggerFormExternal(el, phxTriggerExternal)) {\n              externalFormTriggered = el;\n            }\n\n            dom_default.discardError(targetContainer, el, phxFeedbackFor);\n\n            if (dom_default.isPhxChild(el) && view.ownsElement(el)) {\n              this.trackAfter(\"phxChildAdded\", el);\n            }\n\n            added.push(el);\n          },\n          onNodeDiscarded: el => {\n            if (dom_default.isPhxChild(el)) {\n              liveSocket.destroyViewByEl(el);\n            }\n\n            this.trackAfter(\"discarded\", el);\n          },\n          onBeforeNodeDiscarded: el => {\n            if (el.getAttribute && el.getAttribute(PHX_PRUNE) !== null) {\n              return true;\n            }\n\n            if (el.parentNode !== null && dom_default.isPhxUpdate(el.parentNode, phxUpdate, [\"append\", \"prepend\"]) && el.id) {\n              return false;\n            }\n\n            if (el.getAttribute && el.getAttribute(phxRemove)) {\n              pendingRemoves.push(el);\n              return false;\n            }\n\n            if (this.skipCIDSibling(el)) {\n              return false;\n            }\n\n            return true;\n          },\n          onElUpdated: el => {\n            if (dom_default.isNowTriggerFormExternal(el, phxTriggerExternal)) {\n              externalFormTriggered = el;\n            }\n\n            updates.push(el);\n          },\n          onBeforeElUpdated: (fromEl, toEl) => {\n            dom_default.cleanChildNodes(toEl, phxUpdate);\n\n            if (this.skipCIDSibling(toEl)) {\n              return false;\n            }\n\n            if (dom_default.isIgnored(fromEl, phxUpdate)) {\n              this.trackBefore(\"updated\", fromEl, toEl);\n              dom_default.mergeAttrs(fromEl, toEl, {\n                isIgnored: true\n              });\n              updates.push(fromEl);\n              dom_default.applyStickyOperations(fromEl);\n              return false;\n            }\n\n            if (fromEl.type === \"number\" && fromEl.validity && fromEl.validity.badInput) {\n              return false;\n            }\n\n            if (!dom_default.syncPendingRef(fromEl, toEl, disableWith)) {\n              if (dom_default.isUploadInput(fromEl)) {\n                this.trackBefore(\"updated\", fromEl, toEl);\n                updates.push(fromEl);\n              }\n\n              dom_default.applyStickyOperations(fromEl);\n              return false;\n            }\n\n            if (dom_default.isPhxChild(toEl)) {\n              let prevSession = fromEl.getAttribute(PHX_SESSION);\n              dom_default.mergeAttrs(fromEl, toEl, {\n                exclude: [PHX_STATIC]\n              });\n\n              if (prevSession !== \"\") {\n                fromEl.setAttribute(PHX_SESSION, prevSession);\n              }\n\n              fromEl.setAttribute(PHX_ROOT_ID, this.rootID);\n              dom_default.applyStickyOperations(fromEl);\n              return false;\n            }\n\n            dom_default.copyPrivates(toEl, fromEl);\n            dom_default.discardError(targetContainer, toEl, phxFeedbackFor);\n            let isFocusedFormEl = focused && fromEl.isSameNode(focused) && dom_default.isFormInput(fromEl);\n\n            if (isFocusedFormEl) {\n              this.trackBefore(\"updated\", fromEl, toEl);\n              dom_default.mergeFocusedInput(fromEl, toEl);\n              dom_default.syncAttrsToProps(fromEl);\n              updates.push(fromEl);\n              dom_default.applyStickyOperations(fromEl);\n              return false;\n            } else {\n              if (dom_default.isPhxUpdate(toEl, phxUpdate, [\"append\", \"prepend\"])) {\n                appendPrependUpdates.push(new DOMPostMorphRestorer(fromEl, toEl, toEl.getAttribute(phxUpdate)));\n              }\n\n              dom_default.syncAttrsToProps(toEl);\n              dom_default.applyStickyOperations(toEl);\n              this.trackBefore(\"updated\", fromEl, toEl);\n              return true;\n            }\n          }\n        });\n      });\n\n      if (liveSocket.isDebugEnabled()) {\n        detectDuplicateIds();\n      }\n\n      if (appendPrependUpdates.length > 0) {\n        liveSocket.time(\"post-morph append/prepend restoration\", () => {\n          appendPrependUpdates.forEach(update => update.perform());\n        });\n      }\n\n      liveSocket.silenceEvents(() => dom_default.restoreFocus(focused, selectionStart, selectionEnd));\n      dom_default.dispatchEvent(document, \"phx:update\");\n      added.forEach(el => this.trackAfter(\"added\", el));\n      updates.forEach(el => this.trackAfter(\"updated\", el));\n\n      if (pendingRemoves.length > 0) {\n        liveSocket.transitionRemoves(pendingRemoves);\n        liveSocket.requestDOMUpdate(() => {\n          pendingRemoves.forEach(el => {\n            let child = dom_default.firstPhxChild(el);\n\n            if (child) {\n              liveSocket.destroyViewByEl(child);\n            }\n\n            el.remove();\n          });\n          this.trackAfter(\"transitionsDiscarded\", pendingRemoves);\n        });\n      }\n\n      if (externalFormTriggered) {\n        liveSocket.disconnect();\n        externalFormTriggered.submit();\n      }\n\n      return true;\n    }\n\n    isCIDPatch() {\n      return this.cidPatch;\n    }\n\n    skipCIDSibling(el) {\n      return el.nodeType === Node.ELEMENT_NODE && el.getAttribute(PHX_SKIP) !== null;\n    }\n\n    targetCIDContainer(html) {\n      if (!this.isCIDPatch()) {\n        return;\n      }\n\n      let [first, ...rest] = dom_default.findComponentNodeList(this.container, this.targetCID);\n\n      if (rest.length === 0 && dom_default.childNodeLength(html) === 1) {\n        return first;\n      } else {\n        return first && first.parentNode;\n      }\n    }\n\n    buildDiffHTML(container, html, phxUpdate, targetContainer) {\n      let isCIDPatch = this.isCIDPatch();\n      let isCIDWithSingleRoot = isCIDPatch && targetContainer.getAttribute(PHX_COMPONENT) === this.targetCID.toString();\n\n      if (!isCIDPatch || isCIDWithSingleRoot) {\n        return html;\n      } else {\n        let diffContainer = null;\n        let template = document.createElement(\"template\");\n        diffContainer = dom_default.cloneNode(targetContainer);\n        let [firstComponent, ...rest] = dom_default.findComponentNodeList(diffContainer, this.targetCID);\n        template.innerHTML = html;\n        rest.forEach(el => el.remove());\n        Array.from(diffContainer.childNodes).forEach(child => {\n          if (child.id && child.nodeType === Node.ELEMENT_NODE && child.getAttribute(PHX_COMPONENT) !== this.targetCID.toString()) {\n            child.setAttribute(PHX_SKIP, \"\");\n            child.innerHTML = \"\";\n          }\n        });\n        Array.from(template.content.childNodes).forEach(el => diffContainer.insertBefore(el, firstComponent));\n        firstComponent.remove();\n        return diffContainer.outerHTML;\n      }\n    }\n\n  }; // js/phoenix_live_view/rendered.js\n\n  var Rendered = class {\n    static extract(diff) {\n      let {\n        [REPLY]: reply,\n        [EVENTS]: events,\n        [TITLE]: title\n      } = diff;\n      delete diff[REPLY];\n      delete diff[EVENTS];\n      delete diff[TITLE];\n      return {\n        diff,\n        title,\n        reply: reply || null,\n        events: events || []\n      };\n    }\n\n    constructor(viewId, rendered) {\n      this.viewId = viewId;\n      this.rendered = {};\n      this.mergeDiff(rendered);\n    }\n\n    parentViewId() {\n      return this.viewId;\n    }\n\n    toString(onlyCids) {\n      return this.recursiveToString(this.rendered, this.rendered[COMPONENTS], onlyCids);\n    }\n\n    recursiveToString(rendered, components = rendered[COMPONENTS], onlyCids) {\n      onlyCids = onlyCids ? new Set(onlyCids) : null;\n      let output = {\n        buffer: \"\",\n        components,\n        onlyCids\n      };\n      this.toOutputBuffer(rendered, null, output);\n      return output.buffer;\n    }\n\n    componentCIDs(diff) {\n      return Object.keys(diff[COMPONENTS] || {}).map(i => parseInt(i));\n    }\n\n    isComponentOnlyDiff(diff) {\n      if (!diff[COMPONENTS]) {\n        return false;\n      }\n\n      return Object.keys(diff).length === 1;\n    }\n\n    getComponent(diff, cid) {\n      return diff[COMPONENTS][cid];\n    }\n\n    mergeDiff(diff) {\n      let newc = diff[COMPONENTS];\n      let cache = {};\n      delete diff[COMPONENTS];\n      this.rendered = this.mutableMerge(this.rendered, diff);\n      this.rendered[COMPONENTS] = this.rendered[COMPONENTS] || {};\n\n      if (newc) {\n        let oldc = this.rendered[COMPONENTS];\n\n        for (let cid in newc) {\n          newc[cid] = this.cachedFindComponent(cid, newc[cid], oldc, newc, cache);\n        }\n\n        for (let cid in newc) {\n          oldc[cid] = newc[cid];\n        }\n\n        diff[COMPONENTS] = newc;\n      }\n    }\n\n    cachedFindComponent(cid, cdiff, oldc, newc, cache) {\n      if (cache[cid]) {\n        return cache[cid];\n      } else {\n        let ndiff,\n            stat,\n            scid = cdiff[STATIC];\n\n        if (isCid(scid)) {\n          let tdiff;\n\n          if (scid > 0) {\n            tdiff = this.cachedFindComponent(scid, newc[scid], oldc, newc, cache);\n          } else {\n            tdiff = oldc[-scid];\n          }\n\n          stat = tdiff[STATIC];\n          ndiff = this.cloneMerge(tdiff, cdiff);\n          ndiff[STATIC] = stat;\n        } else {\n          ndiff = cdiff[STATIC] !== void 0 ? cdiff : this.cloneMerge(oldc[cid] || {}, cdiff);\n        }\n\n        cache[cid] = ndiff;\n        return ndiff;\n      }\n    }\n\n    mutableMerge(target, source) {\n      if (source[STATIC] !== void 0) {\n        return source;\n      } else {\n        this.doMutableMerge(target, source);\n        return target;\n      }\n    }\n\n    doMutableMerge(target, source) {\n      for (let key in source) {\n        let val = source[key];\n        let targetVal = target[key];\n\n        if (isObject(val) && val[STATIC] === void 0 && isObject(targetVal)) {\n          this.doMutableMerge(targetVal, val);\n        } else {\n          target[key] = val;\n        }\n      }\n    }\n\n    cloneMerge(target, source) {\n      let merged = __spreadValues(__spreadValues({}, target), source);\n\n      for (let key in merged) {\n        let val = source[key];\n        let targetVal = target[key];\n\n        if (isObject(val) && val[STATIC] === void 0 && isObject(targetVal)) {\n          merged[key] = this.cloneMerge(targetVal, val);\n        }\n      }\n\n      return merged;\n    }\n\n    componentToString(cid) {\n      return this.recursiveCIDToString(this.rendered[COMPONENTS], cid);\n    }\n\n    pruneCIDs(cids) {\n      cids.forEach(cid => delete this.rendered[COMPONENTS][cid]);\n    }\n\n    get() {\n      return this.rendered;\n    }\n\n    isNewFingerprint(diff = {}) {\n      return !!diff[STATIC];\n    }\n\n    templateStatic(part, templates) {\n      if (typeof part === \"number\") {\n        return templates[part];\n      } else {\n        return part;\n      }\n    }\n\n    toOutputBuffer(rendered, templates, output) {\n      if (rendered[DYNAMICS]) {\n        return this.comprehensionToBuffer(rendered, templates, output);\n      }\n\n      let {\n        [STATIC]: statics\n      } = rendered;\n      statics = this.templateStatic(statics, templates);\n      output.buffer += statics[0];\n\n      for (let i = 1; i < statics.length; i++) {\n        this.dynamicToBuffer(rendered[i - 1], templates, output);\n        output.buffer += statics[i];\n      }\n    }\n\n    comprehensionToBuffer(rendered, templates, output) {\n      let {\n        [DYNAMICS]: dynamics,\n        [STATIC]: statics\n      } = rendered;\n      statics = this.templateStatic(statics, templates);\n      let compTemplates = rendered[TEMPLATES];\n\n      for (let d = 0; d < dynamics.length; d++) {\n        let dynamic = dynamics[d];\n        output.buffer += statics[0];\n\n        for (let i = 1; i < statics.length; i++) {\n          this.dynamicToBuffer(dynamic[i - 1], compTemplates, output);\n          output.buffer += statics[i];\n        }\n      }\n    }\n\n    dynamicToBuffer(rendered, templates, output) {\n      if (typeof rendered === \"number\") {\n        output.buffer += this.recursiveCIDToString(output.components, rendered, output.onlyCids);\n      } else if (isObject(rendered)) {\n        this.toOutputBuffer(rendered, templates, output);\n      } else {\n        output.buffer += rendered;\n      }\n    }\n\n    recursiveCIDToString(components, cid, onlyCids) {\n      let component = components[cid] || logError(`no component for CID ${cid}`, components);\n      let template = document.createElement(\"template\");\n      template.innerHTML = this.recursiveToString(component, components, onlyCids);\n      let container = template.content;\n      let skip = onlyCids && !onlyCids.has(cid);\n      let [hasChildNodes, hasChildComponents] = Array.from(container.childNodes).reduce(([hasNodes, hasComponents], child, i) => {\n        if (child.nodeType === Node.ELEMENT_NODE) {\n          if (child.getAttribute(PHX_COMPONENT)) {\n            return [hasNodes, true];\n          }\n\n          child.setAttribute(PHX_COMPONENT, cid);\n\n          if (!child.id) {\n            child.id = `${this.parentViewId()}-${cid}-${i}`;\n          }\n\n          if (skip) {\n            child.setAttribute(PHX_SKIP, \"\");\n            child.innerHTML = \"\";\n          }\n\n          return [true, hasComponents];\n        } else {\n          if (child.nodeValue.trim() !== \"\") {\n            logError(`only HTML element tags are allowed at the root of components.\n\ngot: \"${child.nodeValue.trim()}\"\n\nwithin:\n`, template.innerHTML.trim());\n            child.replaceWith(this.createSpan(child.nodeValue, cid));\n            return [true, hasComponents];\n          } else {\n            child.remove();\n            return [hasNodes, hasComponents];\n          }\n        }\n      }, [false, false]);\n\n      if (!hasChildNodes && !hasChildComponents) {\n        logError(\"expected at least one HTML element tag inside a component, but the component is empty:\\n\", template.innerHTML.trim());\n        return this.createSpan(\"\", cid).outerHTML;\n      } else if (!hasChildNodes && hasChildComponents) {\n        logError(\"expected at least one HTML element tag directly inside a component, but only subcomponents were found. A component must render at least one HTML tag directly inside itself.\", template.innerHTML.trim());\n        return template.innerHTML;\n      } else {\n        return template.innerHTML;\n      }\n    }\n\n    createSpan(text, cid) {\n      let span = document.createElement(\"span\");\n      span.innerText = text;\n      span.setAttribute(PHX_COMPONENT, cid);\n      return span;\n    }\n\n  }; // js/phoenix_live_view/view_hook.js\n\n  var viewHookID = 1;\n  var ViewHook = class {\n    static makeID() {\n      return viewHookID++;\n    }\n\n    static elementID(el) {\n      return el.phxHookId;\n    }\n\n    constructor(view, el, callbacks) {\n      this.__view = view;\n      this.__liveSocket = view.liveSocket;\n      this.__callbacks = callbacks;\n      this.__listeners = new Set();\n      this.__isDisconnected = false;\n      this.el = el;\n      this.el.phxHookId = this.constructor.makeID();\n\n      for (let key in this.__callbacks) {\n        this[key] = this.__callbacks[key];\n      }\n    }\n\n    __mounted() {\n      this.mounted && this.mounted();\n    }\n\n    __updated() {\n      this.updated && this.updated();\n    }\n\n    __beforeUpdate() {\n      this.beforeUpdate && this.beforeUpdate();\n    }\n\n    __destroyed() {\n      this.destroyed && this.destroyed();\n    }\n\n    __reconnected() {\n      if (this.__isDisconnected) {\n        this.__isDisconnected = false;\n        this.reconnected && this.reconnected();\n      }\n    }\n\n    __disconnected() {\n      this.__isDisconnected = true;\n      this.disconnected && this.disconnected();\n    }\n\n    pushEvent(event, payload = {}, onReply = function () {}) {\n      return this.__view.pushHookEvent(null, event, payload, onReply);\n    }\n\n    pushEventTo(phxTarget, event, payload = {}, onReply = function () {}) {\n      return this.__view.withinTargets(phxTarget, (view, targetCtx) => {\n        return view.pushHookEvent(targetCtx, event, payload, onReply);\n      });\n    }\n\n    handleEvent(event, callback) {\n      let callbackRef = (customEvent, bypass) => bypass ? event : callback(customEvent.detail);\n\n      window.addEventListener(`phx:${event}`, callbackRef);\n\n      this.__listeners.add(callbackRef);\n\n      return callbackRef;\n    }\n\n    removeHandleEvent(callbackRef) {\n      let event = callbackRef(null, true);\n      window.removeEventListener(`phx:${event}`, callbackRef);\n\n      this.__listeners.delete(callbackRef);\n    }\n\n    upload(name, files) {\n      return this.__view.dispatchUploads(name, files);\n    }\n\n    uploadTo(phxTarget, name, files) {\n      return this.__view.withinTargets(phxTarget, view => view.dispatchUploads(name, files));\n    }\n\n    __cleanup__() {\n      this.__listeners.forEach(callbackRef => this.removeHandleEvent(callbackRef));\n    }\n\n  }; // js/phoenix_live_view/js.js\n\n  var JS = {\n    exec(eventType, phxEvent, view, el, defaults) {\n      let [defaultKind, defaultArgs] = defaults || [null, {}];\n      let commands = phxEvent.charAt(0) === \"[\" ? JSON.parse(phxEvent) : [[defaultKind, defaultArgs]];\n      commands.forEach(([kind, args]) => {\n        if (kind === defaultKind && defaultArgs.data) {\n          args.data = Object.assign(args.data || {}, defaultArgs.data);\n        }\n\n        this[`exec_${kind}`](eventType, phxEvent, view, el, args);\n      });\n    },\n\n    isVisible(el) {\n      let style = window.getComputedStyle(el);\n      return !(style.opacity === 0 || style.display === \"none\");\n    },\n\n    exec_dispatch(eventType, phxEvent, view, sourceEl, {\n      to,\n      event,\n      detail\n    }) {\n      if (to) {\n        dom_default.all(document, to, el => dom_default.dispatchEvent(el, event, detail));\n      } else {\n        dom_default.dispatchEvent(sourceEl, event, detail);\n      }\n    },\n\n    exec_push(eventType, phxEvent, view, sourceEl, args) {\n      let {\n        event,\n        data,\n        target,\n        page_loading,\n        loading,\n        value\n      } = args;\n      let pushOpts = {\n        page_loading: !!page_loading,\n        loading,\n        value\n      };\n      let targetSrc = eventType === \"change\" ? sourceEl.form : sourceEl;\n      let phxTarget = target || targetSrc.getAttribute(view.binding(\"target\")) || targetSrc;\n      view.withinTargets(phxTarget, (targetView, targetCtx) => {\n        if (eventType === \"change\") {\n          let {\n            newCid,\n            _target,\n            callback\n          } = args;\n\n          if (_target) {\n            pushOpts._target = _target;\n          }\n\n          targetView.pushInput(sourceEl, targetCtx, newCid, event || phxEvent, pushOpts, callback);\n        } else if (eventType === \"submit\") {\n          targetView.submitForm(sourceEl, targetCtx, event || phxEvent, pushOpts);\n        } else {\n          targetView.pushEvent(eventType, sourceEl, targetCtx, event || phxEvent, data, pushOpts);\n        }\n      });\n    },\n\n    exec_add_class(eventType, phxEvent, view, sourceEl, {\n      to,\n      names,\n      transition,\n      time\n    }) {\n      if (to) {\n        dom_default.all(document, to, el => this.addOrRemoveClasses(el, names, [], transition, time, view));\n      } else {\n        this.addOrRemoveClasses(sourceEl, names, [], transition, view);\n      }\n    },\n\n    exec_remove_class(eventType, phxEvent, view, sourceEl, {\n      to,\n      names,\n      transition,\n      time\n    }) {\n      if (to) {\n        dom_default.all(document, to, el => this.addOrRemoveClasses(el, [], names, transition, time, view));\n      } else {\n        this.addOrRemoveClasses(sourceEl, [], names, transition, time, view);\n      }\n    },\n\n    exec_transition(eventType, phxEvent, view, sourceEl, {\n      time,\n      to,\n      transition\n    }) {\n      let els = to ? dom_default.all(document, to) : [sourceEl];\n      let [transition_start, running, transition_end] = transition;\n      els.forEach(el => {\n        let onStart = () => this.addOrRemoveClasses(el, transition_start.concat(running), []);\n\n        let onDone = () => this.addOrRemoveClasses(el, transition_end, transition_start.concat(running));\n\n        view.transition(time, onStart, onDone);\n      });\n    },\n\n    exec_toggle(eventType, phxEvent, view, sourceEl, {\n      to,\n      display,\n      ins,\n      outs,\n      time\n    }) {\n      if (to) {\n        dom_default.all(document, to, el => this.toggle(eventType, view, el, display, ins, outs, time));\n      } else {\n        this.toggle(eventType, view, sourceEl, display, ins, outs, time);\n      }\n    },\n\n    exec_show(eventType, phxEvent, view, sourceEl, {\n      to,\n      display,\n      transition,\n      time\n    }) {\n      if (to) {\n        dom_default.all(document, to, el => this.show(eventType, view, el, display, transition, time));\n      } else {\n        this.show(eventType, view, sourceEl, transition, time);\n      }\n    },\n\n    exec_hide(eventType, phxEvent, view, sourceEl, {\n      to,\n      display,\n      transition,\n      time\n    }) {\n      if (to) {\n        dom_default.all(document, to, el => this.hide(eventType, view, el, display, transition, time));\n      } else {\n        this.hide(eventType, view, sourceEl, display, transition, time);\n      }\n    },\n\n    show(eventType, view, el, display, transition, time) {\n      if (!this.isVisible(el)) {\n        this.toggle(eventType, view, el, display, transition, null, time);\n      }\n    },\n\n    hide(eventType, view, el, display, transition, time) {\n      if (this.isVisible(el)) {\n        this.toggle(eventType, view, el, display, null, transition, time);\n      }\n    },\n\n    toggle(eventType, view, el, display, ins, outs, time) {\n      let [inClasses, inStartClasses, inEndClasses] = ins || [[], [], []];\n      let [outClasses, outStartClasses, outEndClasses] = outs || [[], [], []];\n\n      if (inClasses.length > 0 || outClasses.length > 0) {\n        if (this.isVisible(el)) {\n          let onStart = () => {\n            this.addOrRemoveClasses(el, outStartClasses, inClasses.concat(inStartClasses).concat(inEndClasses));\n            window.requestAnimationFrame(() => {\n              this.addOrRemoveClasses(el, outClasses, []);\n              window.requestAnimationFrame(() => this.addOrRemoveClasses(el, outEndClasses, outStartClasses));\n            });\n          };\n\n          view.transition(time, onStart, () => {\n            this.addOrRemoveClasses(el, [], outClasses.concat(outEndClasses));\n            dom_default.putSticky(el, \"toggle\", currentEl => currentEl.style.display = \"none\");\n          });\n        } else {\n          if (eventType === \"remove\") {\n            return;\n          }\n\n          let onStart = () => {\n            this.addOrRemoveClasses(el, inStartClasses, outClasses.concat(outStartClasses).concat(outEndClasses));\n            dom_default.putSticky(el, \"toggle\", currentEl => currentEl.style.display = display || \"block\");\n            window.requestAnimationFrame(() => {\n              this.addOrRemoveClasses(el, inClasses, []);\n              window.requestAnimationFrame(() => this.addOrRemoveClasses(el, inEndClasses, inStartClasses));\n            });\n          };\n\n          view.transition(time, onStart, () => {\n            this.addOrRemoveClasses(el, [], inClasses.concat(inEndClasses));\n          });\n        }\n      } else {\n        let newDisplay = this.isVisible(el) ? \"none\" : display || \"block\";\n        dom_default.putSticky(el, \"toggle\", currentEl => currentEl.style.display = newDisplay);\n      }\n    },\n\n    addOrRemoveClasses(el, adds, removes, transition, time, view) {\n      let [transition_run, transition_start, transition_end] = transition || [[], [], []];\n\n      if (transition_run.length > 0) {\n        let onStart = () => this.addOrRemoveClasses(el, transition_start.concat(transition_run), []);\n\n        let onDone = () => this.addOrRemoveClasses(el, adds.concat(transition_end), removes.concat(transition_run).concat(transition_start));\n\n        return view.transition(time, onStart, onDone);\n      }\n\n      window.requestAnimationFrame(() => {\n        let [prevAdds, prevRemoves] = dom_default.getSticky(el, \"classes\", [[], []]);\n        let keepAdds = adds.filter(name => prevAdds.indexOf(name) < 0 && !el.classList.contains(name));\n        let keepRemoves = removes.filter(name => prevRemoves.indexOf(name) < 0 && el.classList.contains(name));\n        let newAdds = prevAdds.filter(name => removes.indexOf(name) < 0).concat(keepAdds);\n        let newRemoves = prevRemoves.filter(name => adds.indexOf(name) < 0).concat(keepRemoves);\n        dom_default.putSticky(el, \"classes\", currentEl => {\n          currentEl.classList.remove(...newRemoves);\n          currentEl.classList.add(...newAdds);\n          return [newAdds, newRemoves];\n        });\n      });\n    },\n\n    hasAllClasses(el, classes) {\n      return classes.every(name => el.classList.contains(name));\n    },\n\n    isToggledOut(el, outClasses) {\n      return !this.isVisible(el) || this.hasAllClasses(el, outClasses);\n    }\n\n  };\n  var js_default = JS; // js/phoenix_live_view/view.js\n\n  var serializeForm = (form, meta = {}) => {\n    let formData = new FormData(form);\n    let toRemove = [];\n    formData.forEach((val, key, _index) => {\n      if (val instanceof File) {\n        toRemove.push(key);\n      }\n    });\n    toRemove.forEach(key => formData.delete(key));\n    let params = new URLSearchParams();\n\n    for (let [key, val] of formData.entries()) {\n      params.append(key, val);\n    }\n\n    for (let metaKey in meta) {\n      params.append(metaKey, meta[metaKey]);\n    }\n\n    return params.toString();\n  };\n\n  var View = class {\n    constructor(el, liveSocket, parentView, flash) {\n      this.liveSocket = liveSocket;\n      this.flash = flash;\n      this.parent = parentView;\n      this.root = parentView ? parentView.root : this;\n      this.el = el;\n      this.id = this.el.id;\n      this.ref = 0;\n      this.childJoins = 0;\n      this.loaderTimer = null;\n      this.pendingDiffs = [];\n      this.pruningCIDs = [];\n      this.redirect = false;\n      this.href = null;\n      this.joinCount = this.parent ? this.parent.joinCount - 1 : 0;\n      this.joinPending = true;\n      this.destroyed = false;\n\n      this.joinCallback = function (onDone) {\n        onDone && onDone();\n      };\n\n      this.stopCallback = function () {};\n\n      this.pendingJoinOps = this.parent ? null : [];\n      this.viewHooks = {};\n      this.uploaders = {};\n      this.formSubmits = [];\n      this.children = this.parent ? null : {};\n      this.root.children[this.id] = {};\n      this.channel = this.liveSocket.channel(`lv:${this.id}`, () => {\n        return {\n          redirect: this.redirect ? this.href : void 0,\n          url: this.redirect ? void 0 : this.href || void 0,\n          params: this.connectParams(),\n          session: this.getSession(),\n          static: this.getStatic(),\n          flash: this.flash\n        };\n      });\n      this.showLoader(this.liveSocket.loaderTimeout);\n      this.bindChannel();\n    }\n\n    setHref(href) {\n      this.href = href;\n    }\n\n    setRedirect(href) {\n      this.redirect = true;\n      this.href = href;\n    }\n\n    isMain() {\n      return this.liveSocket.main === this;\n    }\n\n    connectParams() {\n      let params = this.liveSocket.params(this.el);\n      let manifest = dom_default.all(document, `[${this.binding(PHX_TRACK_STATIC)}]`).map(node => node.src || node.href).filter(url => typeof url === \"string\");\n\n      if (manifest.length > 0) {\n        params[\"_track_static\"] = manifest;\n      }\n\n      params[\"_mounts\"] = this.joinCount;\n      return params;\n    }\n\n    isConnected() {\n      return this.channel.canPush();\n    }\n\n    getSession() {\n      return this.el.getAttribute(PHX_SESSION);\n    }\n\n    getStatic() {\n      let val = this.el.getAttribute(PHX_STATIC);\n      return val === \"\" ? null : val;\n    }\n\n    destroy(callback = function () {}) {\n      this.destroyAllChildren();\n      this.destroyed = true;\n      delete this.root.children[this.id];\n\n      if (this.parent) {\n        delete this.root.children[this.parent.id][this.id];\n      }\n\n      clearTimeout(this.loaderTimer);\n\n      let onFinished = () => {\n        callback();\n\n        for (let id in this.viewHooks) {\n          this.destroyHook(this.viewHooks[id]);\n        }\n      };\n\n      dom_default.markPhxChildDestroyed(this.el);\n      this.log(\"destroyed\", () => [\"the child has been removed from the parent\"]);\n      this.channel.leave().receive(\"ok\", onFinished).receive(\"error\", onFinished).receive(\"timeout\", onFinished);\n    }\n\n    setContainerClasses(...classes) {\n      this.el.classList.remove(PHX_CONNECTED_CLASS, PHX_DISCONNECTED_CLASS, PHX_ERROR_CLASS);\n      this.el.classList.add(...classes);\n    }\n\n    showLoader(timeout) {\n      clearTimeout(this.loaderTimer);\n\n      if (timeout) {\n        this.loaderTimer = setTimeout(() => this.showLoader(), timeout);\n      } else {\n        for (let id in this.viewHooks) {\n          this.viewHooks[id].__disconnected();\n        }\n\n        this.setContainerClasses(PHX_DISCONNECTED_CLASS);\n      }\n    }\n\n    hideLoader() {\n      clearTimeout(this.loaderTimer);\n      this.setContainerClasses(PHX_CONNECTED_CLASS);\n    }\n\n    triggerReconnected() {\n      for (let id in this.viewHooks) {\n        this.viewHooks[id].__reconnected();\n      }\n    }\n\n    log(kind, msgCallback) {\n      this.liveSocket.log(this, kind, msgCallback);\n    }\n\n    transition(time, onStart, onDone = function () {}) {\n      this.liveSocket.transition(time, onStart, onDone);\n    }\n\n    withinTargets(phxTarget, callback) {\n      if (phxTarget instanceof HTMLElement || phxTarget instanceof SVGElement) {\n        return this.liveSocket.owner(phxTarget, view => callback(view, phxTarget));\n      }\n\n      if (isCid(phxTarget)) {\n        let targets = dom_default.findComponentNodeList(this.el, phxTarget);\n\n        if (targets.length === 0) {\n          logError(`no component found matching phx-target of ${phxTarget}`);\n        } else {\n          callback(this, parseInt(phxTarget));\n        }\n      } else {\n        let targets = Array.from(document.querySelectorAll(phxTarget));\n\n        if (targets.length === 0) {\n          logError(`nothing found matching the phx-target selector \"${phxTarget}\"`);\n        }\n\n        targets.forEach(target => this.liveSocket.owner(target, view => callback(view, target)));\n      }\n    }\n\n    applyDiff(type, rawDiff, callback) {\n      this.log(type, () => [\"\", clone(rawDiff)]);\n      let {\n        diff,\n        reply,\n        events,\n        title\n      } = Rendered.extract(rawDiff);\n\n      if (title) {\n        dom_default.putTitle(title);\n      }\n\n      callback({\n        diff,\n        reply,\n        events\n      });\n      return reply;\n    }\n\n    onJoin(resp) {\n      let {\n        rendered,\n        container\n      } = resp;\n\n      if (container) {\n        let [tag, attrs] = container;\n        this.el = dom_default.replaceRootContainer(this.el, tag, attrs);\n      }\n\n      this.childJoins = 0;\n      this.joinPending = true;\n      this.flash = null;\n      browser_default.dropLocal(this.liveSocket.localStorage, window.location.pathname, CONSECUTIVE_RELOADS);\n      this.applyDiff(\"mount\", rendered, ({\n        diff,\n        events\n      }) => {\n        this.rendered = new Rendered(this.id, diff);\n        let html = this.renderContainer(null, \"join\");\n        this.dropPendingRefs();\n        let forms = this.formsForRecovery(html);\n        this.joinCount++;\n\n        if (forms.length > 0) {\n          forms.forEach(([form, newForm, newCid], i) => {\n            this.pushFormRecovery(form, newCid, resp2 => {\n              if (i === forms.length - 1) {\n                this.onJoinComplete(resp2, html, events);\n              }\n            });\n          });\n        } else {\n          this.onJoinComplete(resp, html, events);\n        }\n      });\n    }\n\n    dropPendingRefs() {\n      dom_default.all(this.el, `[${PHX_REF}]`, el => el.removeAttribute(PHX_REF));\n    }\n\n    onJoinComplete({\n      live_patch\n    }, html, events) {\n      if (this.joinCount > 1 || this.parent && !this.parent.isJoinPending()) {\n        return this.applyJoinPatch(live_patch, html, events);\n      }\n\n      let newChildren = dom_default.findPhxChildrenInFragment(html, this.id).filter(toEl => {\n        let fromEl = toEl.id && this.el.querySelector(`[id=\"${toEl.id}\"]`);\n        let phxStatic = fromEl && fromEl.getAttribute(PHX_STATIC);\n\n        if (phxStatic) {\n          toEl.setAttribute(PHX_STATIC, phxStatic);\n        }\n\n        return this.joinChild(toEl);\n      });\n\n      if (newChildren.length === 0) {\n        if (this.parent) {\n          this.root.pendingJoinOps.push([this, () => this.applyJoinPatch(live_patch, html, events)]);\n          this.parent.ackJoin(this);\n        } else {\n          this.onAllChildJoinsComplete();\n          this.applyJoinPatch(live_patch, html, events);\n        }\n      } else {\n        this.root.pendingJoinOps.push([this, () => this.applyJoinPatch(live_patch, html, events)]);\n      }\n    }\n\n    attachTrueDocEl() {\n      this.el = dom_default.byId(this.id);\n      this.el.setAttribute(PHX_ROOT_ID, this.root.id);\n    }\n\n    applyJoinPatch(live_patch, html, events) {\n      this.attachTrueDocEl();\n      let patch = new DOMPatch(this, this.el, this.id, html, null);\n      patch.markPrunableContentForRemoval();\n      this.performPatch(patch, false);\n      this.joinNewChildren();\n      dom_default.all(this.el, `[${this.binding(PHX_HOOK)}], [data-phx-${PHX_HOOK}]`, hookEl => {\n        let hook = this.addHook(hookEl);\n\n        if (hook) {\n          hook.__mounted();\n        }\n      });\n      this.joinPending = false;\n      this.liveSocket.dispatchEvents(events);\n      this.applyPendingUpdates();\n\n      if (live_patch) {\n        let {\n          kind,\n          to\n        } = live_patch;\n        this.liveSocket.historyPatch(to, kind);\n      }\n\n      this.hideLoader();\n\n      if (this.joinCount > 1) {\n        this.triggerReconnected();\n      }\n\n      this.stopCallback();\n    }\n\n    triggerBeforeUpdateHook(fromEl, toEl) {\n      this.liveSocket.triggerDOM(\"onBeforeElUpdated\", [fromEl, toEl]);\n      let hook = this.getHook(fromEl);\n      let isIgnored = hook && dom_default.isIgnored(fromEl, this.binding(PHX_UPDATE));\n\n      if (hook && !fromEl.isEqualNode(toEl) && !(isIgnored && isEqualObj(fromEl.dataset, toEl.dataset))) {\n        hook.__beforeUpdate();\n\n        return hook;\n      }\n    }\n\n    performPatch(patch, pruneCids) {\n      let removedEls = [];\n      let phxChildrenAdded = false;\n      let updatedHookIds = new Set();\n      patch.after(\"added\", el => {\n        this.liveSocket.triggerDOM(\"onNodeAdded\", [el]);\n        let newHook = this.addHook(el);\n\n        if (newHook) {\n          newHook.__mounted();\n        }\n      });\n      patch.after(\"phxChildAdded\", _el => phxChildrenAdded = true);\n      patch.before(\"updated\", (fromEl, toEl) => {\n        let hook = this.triggerBeforeUpdateHook(fromEl, toEl);\n\n        if (hook) {\n          updatedHookIds.add(fromEl.id);\n        }\n      });\n      patch.after(\"updated\", el => {\n        if (updatedHookIds.has(el.id)) {\n          this.getHook(el).__updated();\n        }\n      });\n      patch.after(\"discarded\", el => {\n        if (el.nodeType === Node.ELEMENT_NODE) {\n          removedEls.push(el);\n        }\n      });\n      patch.after(\"transitionsDiscarded\", els => this.afterElementsRemoved(els, pruneCids));\n      patch.perform();\n      this.afterElementsRemoved(removedEls, pruneCids);\n      return phxChildrenAdded;\n    }\n\n    afterElementsRemoved(elements, pruneCids) {\n      let destroyedCIDs = [];\n      elements.forEach(parent => {\n        let components = dom_default.all(parent, `[${PHX_COMPONENT}]`);\n        components.concat(parent).forEach(el => {\n          let cid = this.componentID(el);\n\n          if (isCid(cid) && destroyedCIDs.indexOf(cid) === -1) {\n            destroyedCIDs.push(cid);\n          }\n\n          let hook = this.getHook(el);\n          hook && this.destroyHook(hook);\n        });\n      });\n\n      if (pruneCids) {\n        this.maybePushComponentsDestroyed(destroyedCIDs);\n      }\n    }\n\n    joinNewChildren() {\n      dom_default.findPhxChildren(this.el, this.id).forEach(el => this.joinChild(el));\n    }\n\n    getChildById(id) {\n      return this.root.children[this.id][id];\n    }\n\n    getDescendentByEl(el) {\n      if (el.id === this.id) {\n        return this;\n      } else {\n        return this.children[el.getAttribute(PHX_PARENT_ID)][el.id];\n      }\n    }\n\n    destroyDescendent(id) {\n      for (let parentId in this.root.children) {\n        for (let childId in this.root.children[parentId]) {\n          if (childId === id) {\n            return this.root.children[parentId][childId].destroy();\n          }\n        }\n      }\n    }\n\n    joinChild(el) {\n      let child = this.getChildById(el.id);\n\n      if (!child) {\n        let view = new View(el, this.liveSocket, this);\n        this.root.children[this.id][view.id] = view;\n        view.join();\n        this.childJoins++;\n        return true;\n      }\n    }\n\n    isJoinPending() {\n      return this.joinPending;\n    }\n\n    ackJoin(_child) {\n      this.childJoins--;\n\n      if (this.childJoins === 0) {\n        if (this.parent) {\n          this.parent.ackJoin(this);\n        } else {\n          this.onAllChildJoinsComplete();\n        }\n      }\n    }\n\n    onAllChildJoinsComplete() {\n      this.joinCallback(() => {\n        this.pendingJoinOps.forEach(([view, op]) => {\n          if (!view.isDestroyed()) {\n            op();\n          }\n        });\n        this.pendingJoinOps = [];\n      });\n    }\n\n    update(diff, events) {\n      if (this.isJoinPending() || this.liveSocket.hasPendingLink()) {\n        return this.pendingDiffs.push({\n          diff,\n          events\n        });\n      }\n\n      this.rendered.mergeDiff(diff);\n      let phxChildrenAdded = false;\n\n      if (this.rendered.isComponentOnlyDiff(diff)) {\n        this.liveSocket.time(\"component patch complete\", () => {\n          let parentCids = dom_default.findParentCIDs(this.el, this.rendered.componentCIDs(diff));\n          parentCids.forEach(parentCID => {\n            if (this.componentPatch(this.rendered.getComponent(diff, parentCID), parentCID)) {\n              phxChildrenAdded = true;\n            }\n          });\n        });\n      } else if (!isEmpty(diff)) {\n        this.liveSocket.time(\"full patch complete\", () => {\n          let html = this.renderContainer(diff, \"update\");\n          let patch = new DOMPatch(this, this.el, this.id, html, null);\n          phxChildrenAdded = this.performPatch(patch, true);\n        });\n      }\n\n      this.liveSocket.dispatchEvents(events);\n\n      if (phxChildrenAdded) {\n        this.joinNewChildren();\n      }\n    }\n\n    renderContainer(diff, kind) {\n      return this.liveSocket.time(`toString diff (${kind})`, () => {\n        let tag = this.el.tagName;\n        let cids = diff ? this.rendered.componentCIDs(diff).concat(this.pruningCIDs) : null;\n        let html = this.rendered.toString(cids);\n        return `<${tag}>${html}</${tag}>`;\n      });\n    }\n\n    componentPatch(diff, cid) {\n      if (isEmpty(diff)) return false;\n      let html = this.rendered.componentToString(cid);\n      let patch = new DOMPatch(this, this.el, this.id, html, cid);\n      let childrenAdded = this.performPatch(patch, true);\n      return childrenAdded;\n    }\n\n    getHook(el) {\n      return this.viewHooks[ViewHook.elementID(el)];\n    }\n\n    addHook(el) {\n      if (ViewHook.elementID(el) || !el.getAttribute) {\n        return;\n      }\n\n      let hookName = el.getAttribute(`data-phx-${PHX_HOOK}`) || el.getAttribute(this.binding(PHX_HOOK));\n\n      if (hookName && !this.ownsElement(el)) {\n        return;\n      }\n\n      let callbacks = this.liveSocket.getHookCallbacks(hookName);\n\n      if (callbacks) {\n        if (!el.id) {\n          logError(`no DOM ID for hook \"${hookName}\". Hooks require a unique ID on each element.`, el);\n        }\n\n        let hook = new ViewHook(this, el, callbacks);\n        this.viewHooks[ViewHook.elementID(hook.el)] = hook;\n        return hook;\n      } else if (hookName !== null) {\n        logError(`unknown hook found for \"${hookName}\"`, el);\n      }\n    }\n\n    destroyHook(hook) {\n      hook.__destroyed();\n\n      hook.__cleanup__();\n\n      delete this.viewHooks[ViewHook.elementID(hook.el)];\n    }\n\n    applyPendingUpdates() {\n      this.pendingDiffs.forEach(({\n        diff,\n        events\n      }) => this.update(diff, events));\n      this.pendingDiffs = [];\n    }\n\n    onChannel(event, cb) {\n      this.liveSocket.onChannel(this.channel, event, resp => {\n        if (this.isJoinPending()) {\n          this.root.pendingJoinOps.push([this, () => cb(resp)]);\n        } else {\n          this.liveSocket.requestDOMUpdate(() => cb(resp));\n        }\n      });\n    }\n\n    bindChannel() {\n      this.liveSocket.onChannel(this.channel, \"diff\", rawDiff => {\n        this.liveSocket.requestDOMUpdate(() => {\n          this.applyDiff(\"update\", rawDiff, ({\n            diff,\n            events\n          }) => this.update(diff, events));\n        });\n      });\n      this.onChannel(\"redirect\", ({\n        to,\n        flash\n      }) => this.onRedirect({\n        to,\n        flash\n      }));\n      this.onChannel(\"live_patch\", redir => this.onLivePatch(redir));\n      this.onChannel(\"live_redirect\", redir => this.onLiveRedirect(redir));\n      this.channel.onError(reason => this.onError(reason));\n      this.channel.onClose(reason => this.onClose(reason));\n    }\n\n    destroyAllChildren() {\n      for (let id in this.root.children[this.id]) {\n        this.getChildById(id).destroy();\n      }\n    }\n\n    onLiveRedirect(redir) {\n      let {\n        to,\n        kind,\n        flash\n      } = redir;\n      let url = this.expandURL(to);\n      this.liveSocket.historyRedirect(url, kind, flash);\n    }\n\n    onLivePatch(redir) {\n      let {\n        to,\n        kind\n      } = redir;\n      this.href = this.expandURL(to);\n      this.liveSocket.historyPatch(to, kind);\n    }\n\n    expandURL(to) {\n      return to.startsWith(\"/\") ? `${window.location.protocol}//${window.location.host}${to}` : to;\n    }\n\n    onRedirect({\n      to,\n      flash\n    }) {\n      this.liveSocket.redirect(to, flash);\n    }\n\n    isDestroyed() {\n      return this.destroyed;\n    }\n\n    join(callback) {\n      if (!this.parent) {\n        this.stopCallback = this.liveSocket.withPageLoading({\n          to: this.href,\n          kind: \"initial\"\n        });\n      }\n\n      this.joinCallback = onDone => {\n        onDone = onDone || function () {};\n\n        callback ? callback(this.joinCount, onDone) : onDone();\n      };\n\n      this.liveSocket.wrapPush(this, {\n        timeout: false\n      }, () => {\n        return this.channel.join().receive(\"ok\", data => {\n          if (!this.isDestroyed()) {\n            this.liveSocket.requestDOMUpdate(() => this.onJoin(data));\n          }\n        }).receive(\"error\", resp => !this.isDestroyed() && this.onJoinError(resp)).receive(\"timeout\", () => !this.isDestroyed() && this.onJoinError({\n          reason: \"timeout\"\n        }));\n      });\n    }\n\n    onJoinError(resp) {\n      if (resp.reason === \"unauthorized\" || resp.reason === \"stale\") {\n        this.log(\"error\", () => [\"unauthorized live_redirect. Falling back to page request\", resp]);\n        return this.onRedirect({\n          to: this.href\n        });\n      }\n\n      if (resp.redirect || resp.live_redirect) {\n        this.joinPending = false;\n        this.channel.leave();\n      }\n\n      if (resp.redirect) {\n        return this.onRedirect(resp.redirect);\n      }\n\n      if (resp.live_redirect) {\n        return this.onLiveRedirect(resp.live_redirect);\n      }\n\n      this.log(\"error\", () => [\"unable to join\", resp]);\n      return this.liveSocket.reloadWithJitter(this);\n    }\n\n    onClose(reason) {\n      if (this.isDestroyed()) {\n        return;\n      }\n\n      if (this.isJoinPending() && document.visibilityState !== \"hidden\" || this.liveSocket.hasPendingLink() && reason !== \"leave\") {\n        return this.liveSocket.reloadWithJitter(this);\n      }\n\n      this.destroyAllChildren();\n      this.liveSocket.dropActiveElement(this);\n\n      if (document.activeElement) {\n        document.activeElement.blur();\n      }\n\n      if (this.liveSocket.isUnloaded()) {\n        this.showLoader(BEFORE_UNLOAD_LOADER_TIMEOUT);\n      }\n    }\n\n    onError(reason) {\n      this.onClose(reason);\n      this.log(\"error\", () => [\"view crashed\", reason]);\n\n      if (!this.liveSocket.isUnloaded()) {\n        this.displayError();\n      }\n    }\n\n    displayError() {\n      if (this.isMain()) {\n        dom_default.dispatchEvent(window, \"phx:page-loading-start\", {\n          to: this.href,\n          kind: \"error\"\n        });\n      }\n\n      this.showLoader();\n      this.setContainerClasses(PHX_DISCONNECTED_CLASS, PHX_ERROR_CLASS);\n    }\n\n    pushWithReply(refGenerator, event, payload, onReply = function () {}) {\n      if (!this.isConnected()) {\n        return;\n      }\n\n      let [ref, [el], opts] = refGenerator ? refGenerator() : [null, [], {}];\n\n      let onLoadingDone = function () {};\n\n      if (opts.page_loading || el && el.getAttribute(this.binding(PHX_PAGE_LOADING)) !== null) {\n        onLoadingDone = this.liveSocket.withPageLoading({\n          kind: \"element\",\n          target: el\n        });\n      }\n\n      if (typeof payload.cid !== \"number\") {\n        delete payload.cid;\n      }\n\n      return this.liveSocket.wrapPush(this, {\n        timeout: true\n      }, () => {\n        return this.channel.push(event, payload, PUSH_TIMEOUT).receive(\"ok\", resp => {\n          this.liveSocket.requestDOMUpdate(() => {\n            let hookReply = null;\n\n            if (ref !== null) {\n              this.undoRefs(ref);\n            }\n\n            if (resp.diff) {\n              hookReply = this.applyDiff(\"update\", resp.diff, ({\n                diff,\n                events\n              }) => {\n                this.update(diff, events);\n              });\n            }\n\n            if (resp.redirect) {\n              this.onRedirect(resp.redirect);\n            }\n\n            if (resp.live_patch) {\n              this.onLivePatch(resp.live_patch);\n            }\n\n            if (resp.live_redirect) {\n              this.onLiveRedirect(resp.live_redirect);\n            }\n\n            onLoadingDone();\n            onReply(resp, hookReply);\n          });\n        });\n      });\n    }\n\n    undoRefs(ref) {\n      dom_default.all(this.el, `[${PHX_REF}=\"${ref}\"]`, el => {\n        let disabledVal = el.getAttribute(PHX_DISABLED);\n        el.removeAttribute(PHX_REF);\n\n        if (el.getAttribute(PHX_READONLY) !== null) {\n          el.readOnly = false;\n          el.removeAttribute(PHX_READONLY);\n        }\n\n        if (disabledVal !== null) {\n          el.disabled = disabledVal === \"true\" ? true : false;\n          el.removeAttribute(PHX_DISABLED);\n        }\n\n        PHX_EVENT_CLASSES.forEach(className => dom_default.removeClass(el, className));\n        let disableRestore = el.getAttribute(PHX_DISABLE_WITH_RESTORE);\n\n        if (disableRestore !== null) {\n          el.innerText = disableRestore;\n          el.removeAttribute(PHX_DISABLE_WITH_RESTORE);\n        }\n\n        let toEl = dom_default.private(el, PHX_REF);\n\n        if (toEl) {\n          let hook = this.triggerBeforeUpdateHook(el, toEl);\n          DOMPatch.patchEl(el, toEl, this.liveSocket.getActiveElement());\n\n          if (hook) {\n            hook.__updated();\n          }\n\n          dom_default.deletePrivate(el, PHX_REF);\n        }\n      });\n    }\n\n    putRef(elements, event, opts = {}) {\n      let newRef = this.ref++;\n      let disableWith = this.binding(PHX_DISABLE_WITH);\n\n      if (opts.loading) {\n        elements = elements.concat(dom_default.all(document, opts.loading));\n      }\n\n      elements.forEach(el => {\n        el.classList.add(`phx-${event}-loading`);\n        el.setAttribute(PHX_REF, newRef);\n        let disableText = el.getAttribute(disableWith);\n\n        if (disableText !== null) {\n          if (!el.getAttribute(PHX_DISABLE_WITH_RESTORE)) {\n            el.setAttribute(PHX_DISABLE_WITH_RESTORE, el.innerText);\n          }\n\n          el.innerText = disableText;\n        }\n      });\n      return [newRef, elements, opts];\n    }\n\n    componentID(el) {\n      let cid = el.getAttribute && el.getAttribute(PHX_COMPONENT);\n      return cid ? parseInt(cid) : null;\n    }\n\n    targetComponentID(target, targetCtx) {\n      if (isCid(targetCtx)) {\n        return targetCtx;\n      }\n\n      let cidOrSelector = target.getAttribute(this.binding(\"target\"));\n\n      if (isCid(cidOrSelector)) {\n        return parseInt(cidOrSelector);\n      } else if (targetCtx && cidOrSelector !== null) {\n        return this.closestComponentID(targetCtx);\n      } else {\n        return null;\n      }\n    }\n\n    closestComponentID(targetCtx) {\n      if (isCid(targetCtx)) {\n        return targetCtx;\n      } else if (targetCtx) {\n        return maybe(targetCtx.closest(`[${PHX_COMPONENT}]`), el => this.ownsElement(el) && this.componentID(el));\n      } else {\n        return null;\n      }\n    }\n\n    pushHookEvent(targetCtx, event, payload, onReply) {\n      if (!this.isConnected()) {\n        this.log(\"hook\", () => [\"unable to push hook event. LiveView not connected\", event, payload]);\n        return false;\n      }\n\n      let [ref, els, opts] = this.putRef([], \"hook\");\n      this.pushWithReply(() => [ref, els, opts], \"event\", {\n        type: \"hook\",\n        event,\n        value: payload,\n        cid: this.closestComponentID(targetCtx)\n      }, (resp, reply) => onReply(reply, ref));\n      return ref;\n    }\n\n    extractMeta(el, meta, value) {\n      let prefix = this.binding(\"value-\");\n\n      for (let i = 0; i < el.attributes.length; i++) {\n        if (!meta) {\n          meta = {};\n        }\n\n        let name = el.attributes[i].name;\n\n        if (name.startsWith(prefix)) {\n          meta[name.replace(prefix, \"\")] = el.getAttribute(name);\n        }\n      }\n\n      if (el.value !== void 0) {\n        if (!meta) {\n          meta = {};\n        }\n\n        meta.value = el.value;\n\n        if (el.tagName === \"INPUT\" && CHECKABLE_INPUTS.indexOf(el.type) >= 0 && !el.checked) {\n          delete meta.value;\n        }\n      }\n\n      if (value) {\n        if (!meta) {\n          meta = {};\n        }\n\n        for (let key in value) {\n          meta[key] = value[key];\n        }\n      }\n\n      return meta;\n    }\n\n    pushEvent(type, el, targetCtx, phxEvent, meta, opts = {}) {\n      this.pushWithReply(() => this.putRef([el], type, opts), \"event\", {\n        type,\n        event: phxEvent,\n        value: this.extractMeta(el, meta, opts.value),\n        cid: this.targetComponentID(el, targetCtx)\n      });\n    }\n\n    pushFileProgress(fileEl, entryRef, progress, onReply = function () {}) {\n      this.liveSocket.withinOwners(fileEl.form, (view, targetCtx) => {\n        view.pushWithReply(null, \"progress\", {\n          event: fileEl.getAttribute(view.binding(PHX_PROGRESS)),\n          ref: fileEl.getAttribute(PHX_UPLOAD_REF),\n          entry_ref: entryRef,\n          progress,\n          cid: view.targetComponentID(fileEl.form, targetCtx)\n        }, onReply);\n      });\n    }\n\n    pushInput(inputEl, targetCtx, forceCid, phxEvent, opts, callback) {\n      let uploads;\n      let cid = isCid(forceCid) ? forceCid : this.targetComponentID(inputEl.form, targetCtx);\n\n      let refGenerator = () => this.putRef([inputEl, inputEl.form], \"change\", opts);\n\n      let formData = serializeForm(inputEl.form, {\n        _target: opts._target\n      });\n\n      if (dom_default.isUploadInput(inputEl) && inputEl.files && inputEl.files.length > 0) {\n        LiveUploader.trackFiles(inputEl, Array.from(inputEl.files));\n      }\n\n      uploads = LiveUploader.serializeUploads(inputEl);\n      let event = {\n        type: \"form\",\n        event: phxEvent,\n        value: formData,\n        uploads,\n        cid\n      };\n      this.pushWithReply(refGenerator, \"event\", event, resp => {\n        dom_default.showError(inputEl, this.liveSocket.binding(PHX_FEEDBACK_FOR));\n\n        if (dom_default.isUploadInput(inputEl) && inputEl.getAttribute(\"data-phx-auto-upload\") !== null) {\n          if (LiveUploader.filesAwaitingPreflight(inputEl).length > 0) {\n            let [ref, _els] = refGenerator();\n            this.uploadFiles(inputEl.form, targetCtx, ref, cid, _uploads => {\n              callback && callback(resp);\n              this.triggerAwaitingSubmit(inputEl.form);\n            });\n          }\n        } else {\n          callback && callback(resp);\n        }\n      });\n    }\n\n    triggerAwaitingSubmit(formEl) {\n      let awaitingSubmit = this.getScheduledSubmit(formEl);\n\n      if (awaitingSubmit) {\n        let [_el, _ref, _opts, callback] = awaitingSubmit;\n        this.cancelSubmit(formEl);\n        callback();\n      }\n    }\n\n    getScheduledSubmit(formEl) {\n      return this.formSubmits.find(([el, _ref, _opts, _callback]) => el.isSameNode(formEl));\n    }\n\n    scheduleSubmit(formEl, ref, opts, callback) {\n      if (this.getScheduledSubmit(formEl)) {\n        return true;\n      }\n\n      this.formSubmits.push([formEl, ref, opts, callback]);\n    }\n\n    cancelSubmit(formEl) {\n      this.formSubmits = this.formSubmits.filter(([el, ref, _callback]) => {\n        if (el.isSameNode(formEl)) {\n          this.undoRefs(ref);\n          return false;\n        } else {\n          return true;\n        }\n      });\n    }\n\n    pushFormSubmit(formEl, targetCtx, phxEvent, opts, onReply) {\n      let filterIgnored = el => {\n        let userIgnored = closestPhxBinding(el, `${this.binding(PHX_UPDATE)}=ignore`, el.form);\n        return !(userIgnored || closestPhxBinding(el, \"data-phx-update=ignore\", el.form));\n      };\n\n      let filterDisables = el => {\n        return el.hasAttribute(this.binding(PHX_DISABLE_WITH));\n      };\n\n      let filterButton = el => el.tagName == \"BUTTON\";\n\n      let filterInput = el => [\"INPUT\", \"TEXTAREA\", \"SELECT\"].includes(el.tagName);\n\n      let refGenerator = () => {\n        let formElements = Array.from(formEl.elements);\n        let disables = formElements.filter(filterDisables);\n        let buttons = formElements.filter(filterButton).filter(filterIgnored);\n        let inputs = formElements.filter(filterInput).filter(filterIgnored);\n        buttons.forEach(button => {\n          button.setAttribute(PHX_DISABLED, button.disabled);\n          button.disabled = true;\n        });\n        inputs.forEach(input => {\n          input.setAttribute(PHX_READONLY, input.readOnly);\n          input.readOnly = true;\n\n          if (input.files) {\n            input.setAttribute(PHX_DISABLED, input.disabled);\n            input.disabled = true;\n          }\n        });\n        formEl.setAttribute(this.binding(PHX_PAGE_LOADING), \"\");\n        return this.putRef([formEl].concat(disables).concat(buttons).concat(inputs), \"submit\", opts);\n      };\n\n      let cid = this.targetComponentID(formEl, targetCtx);\n\n      if (LiveUploader.hasUploadsInProgress(formEl)) {\n        let [ref, _els] = refGenerator();\n\n        let push = () => this.pushFormSubmit(formEl, targetCtx, phxEvent, opts, onReply);\n\n        return this.scheduleSubmit(formEl, ref, opts, push);\n      } else if (LiveUploader.inputsAwaitingPreflight(formEl).length > 0) {\n        let [ref, els] = refGenerator();\n\n        let proxyRefGen = () => [ref, els, opts];\n\n        this.uploadFiles(formEl, targetCtx, ref, cid, _uploads => {\n          let formData = serializeForm(formEl, {});\n          this.pushWithReply(proxyRefGen, \"event\", {\n            type: \"form\",\n            event: phxEvent,\n            value: formData,\n            cid\n          }, onReply);\n        });\n      } else {\n        let formData = serializeForm(formEl);\n        this.pushWithReply(refGenerator, \"event\", {\n          type: \"form\",\n          event: phxEvent,\n          value: formData,\n          cid\n        }, onReply);\n      }\n    }\n\n    uploadFiles(formEl, targetCtx, ref, cid, onComplete) {\n      let joinCountAtUpload = this.joinCount;\n      let inputEls = LiveUploader.activeFileInputs(formEl);\n      let numFileInputsInProgress = inputEls.length;\n      inputEls.forEach(inputEl => {\n        let uploader = new LiveUploader(inputEl, this, () => {\n          numFileInputsInProgress--;\n\n          if (numFileInputsInProgress === 0) {\n            onComplete();\n          }\n        });\n        this.uploaders[inputEl] = uploader;\n        let entries = uploader.entries().map(entry => entry.toPreflightPayload());\n        let payload = {\n          ref: inputEl.getAttribute(PHX_UPLOAD_REF),\n          entries,\n          cid: this.targetComponentID(inputEl.form, targetCtx)\n        };\n        this.log(\"upload\", () => [\"sending preflight request\", payload]);\n        this.pushWithReply(null, \"allow_upload\", payload, resp => {\n          this.log(\"upload\", () => [\"got preflight response\", resp]);\n\n          if (resp.error) {\n            this.undoRefs(ref);\n            let [entry_ref, reason] = resp.error;\n            this.log(\"upload\", () => [`error for entry ${entry_ref}`, reason]);\n          } else {\n            let onError = callback => {\n              this.channel.onError(() => {\n                if (this.joinCount === joinCountAtUpload) {\n                  callback();\n                }\n              });\n            };\n\n            uploader.initAdapterUpload(resp, onError, this.liveSocket);\n          }\n        });\n      });\n    }\n\n    dispatchUploads(name, filesOrBlobs) {\n      let inputs = dom_default.findUploadInputs(this.el).filter(el => el.name === name);\n\n      if (inputs.length === 0) {\n        logError(`no live file inputs found matching the name \"${name}\"`);\n      } else if (inputs.length > 1) {\n        logError(`duplicate live file inputs found matching the name \"${name}\"`);\n      } else {\n        dom_default.dispatchEvent(inputs[0], PHX_TRACK_UPLOADS, {\n          files: filesOrBlobs\n        });\n      }\n    }\n\n    pushFormRecovery(form, newCid, callback) {\n      this.liveSocket.withinOwners(form, (view, targetCtx) => {\n        let input = form.elements[0];\n        let phxEvent = form.getAttribute(this.binding(PHX_AUTO_RECOVER)) || form.getAttribute(this.binding(\"change\"));\n        js_default.exec(\"change\", phxEvent, view, input, [\"push\", {\n          _target: input.name,\n          newCid,\n          callback\n        }]);\n      });\n    }\n\n    pushLinkPatch(href, targetEl, callback) {\n      let linkRef = this.liveSocket.setPendingLink(href);\n      let refGen = targetEl ? () => this.putRef([targetEl], \"click\") : null;\n      this.pushWithReply(refGen, \"live_patch\", {\n        url: href\n      }, resp => {\n        this.liveSocket.requestDOMUpdate(() => {\n          if (resp.link_redirect) {\n            this.liveSocket.replaceMain(href, null, callback, linkRef);\n          } else {\n            if (this.liveSocket.commitPendingLink(linkRef)) {\n              this.href = href;\n            }\n\n            this.applyPendingUpdates();\n            callback && callback(linkRef);\n          }\n        });\n      }).receive(\"timeout\", () => this.liveSocket.redirect(window.location.href));\n    }\n\n    formsForRecovery(html) {\n      if (this.joinCount === 0) {\n        return [];\n      }\n\n      let phxChange = this.binding(\"change\");\n      let template = document.createElement(\"template\");\n      template.innerHTML = html;\n      return dom_default.all(this.el, `form[${phxChange}]`).filter(form => form.id && this.ownsElement(form)).filter(form => form.elements.length > 0).filter(form => form.getAttribute(this.binding(PHX_AUTO_RECOVER)) !== \"ignore\").map(form => {\n        let newForm = template.content.querySelector(`form[id=\"${form.id}\"][${phxChange}=\"${form.getAttribute(phxChange)}\"]`);\n\n        if (newForm) {\n          return [form, newForm, this.targetComponentID(newForm)];\n        } else {\n          return [form, null, null];\n        }\n      }).filter(([form, newForm, newCid]) => newForm);\n    }\n\n    maybePushComponentsDestroyed(destroyedCIDs) {\n      let willDestroyCIDs = destroyedCIDs.filter(cid => {\n        return dom_default.findComponentNodeList(this.el, cid).length === 0;\n      });\n\n      if (willDestroyCIDs.length > 0) {\n        this.pruningCIDs.push(...willDestroyCIDs);\n        this.pushWithReply(null, \"cids_will_destroy\", {\n          cids: willDestroyCIDs\n        }, () => {\n          this.pruningCIDs = this.pruningCIDs.filter(cid => willDestroyCIDs.indexOf(cid) !== -1);\n          let completelyDestroyCIDs = willDestroyCIDs.filter(cid => {\n            return dom_default.findComponentNodeList(this.el, cid).length === 0;\n          });\n\n          if (completelyDestroyCIDs.length > 0) {\n            this.pushWithReply(null, \"cids_destroyed\", {\n              cids: completelyDestroyCIDs\n            }, resp => {\n              this.rendered.pruneCIDs(resp.cids);\n            });\n          }\n        });\n      }\n    }\n\n    ownsElement(el) {\n      return el.getAttribute(PHX_PARENT_ID) === this.id || maybe(el.closest(PHX_VIEW_SELECTOR), node => node.id) === this.id;\n    }\n\n    submitForm(form, targetCtx, phxEvent, opts = {}) {\n      dom_default.putPrivate(form, PHX_HAS_SUBMITTED, true);\n      this.liveSocket.blurActiveElement(this);\n      this.pushFormSubmit(form, targetCtx, phxEvent, opts, () => {\n        this.liveSocket.restorePreviouslyActiveFocus();\n      });\n    }\n\n    binding(kind) {\n      return this.liveSocket.binding(kind);\n    }\n\n  }; // js/phoenix_live_view/live_socket.js\n\n  var LiveSocket = class {\n    constructor(url, phxSocket, opts = {}) {\n      this.unloaded = false;\n\n      if (!phxSocket || phxSocket.constructor.name === \"Object\") {\n        throw new Error(`\n      a phoenix Socket must be provided as the second argument to the LiveSocket constructor. For example:\n\n          import {Socket} from \"phoenix\"\n          import LiveSocket from \"phoenix_live_view\"\n          let liveSocket = new LiveSocket(\"/live\", Socket, {...})\n      `);\n      }\n\n      this.socket = new phxSocket(url, opts);\n      this.bindingPrefix = opts.bindingPrefix || BINDING_PREFIX;\n      this.opts = opts;\n      this.params = closure(opts.params || {});\n      this.viewLogger = opts.viewLogger;\n      this.metadataCallbacks = opts.metadata || {};\n      this.defaults = Object.assign(clone(DEFAULTS), opts.defaults || {});\n      this.activeElement = null;\n      this.prevActive = null;\n      this.silenced = false;\n      this.main = null;\n      this.linkRef = 1;\n      this.roots = {};\n      this.href = window.location.href;\n      this.pendingLink = null;\n      this.currentLocation = clone(window.location);\n      this.hooks = opts.hooks || {};\n      this.uploaders = opts.uploaders || {};\n      this.loaderTimeout = opts.loaderTimeout || LOADER_TIMEOUT;\n      this.localStorage = opts.localStorage || window.localStorage;\n      this.sessionStorage = opts.sessionStorage || window.sessionStorage;\n      this.boundTopLevelEvents = false;\n      this.domCallbacks = Object.assign({\n        onNodeAdded: closure(),\n        onBeforeElUpdated: closure()\n      }, opts.dom || {});\n      this.transitions = new TransitionSet();\n      window.addEventListener(\"pagehide\", _e => {\n        this.unloaded = true;\n      });\n      this.socket.onOpen(() => {\n        if (this.isUnloaded()) {\n          window.location.reload();\n        }\n      });\n    }\n\n    isProfileEnabled() {\n      return this.sessionStorage.getItem(PHX_LV_PROFILE) === \"true\";\n    }\n\n    isDebugEnabled() {\n      return this.sessionStorage.getItem(PHX_LV_DEBUG) === \"true\";\n    }\n\n    enableDebug() {\n      this.sessionStorage.setItem(PHX_LV_DEBUG, \"true\");\n    }\n\n    enableProfiling() {\n      this.sessionStorage.setItem(PHX_LV_PROFILE, \"true\");\n    }\n\n    disableDebug() {\n      this.sessionStorage.removeItem(PHX_LV_DEBUG);\n    }\n\n    disableProfiling() {\n      this.sessionStorage.removeItem(PHX_LV_PROFILE);\n    }\n\n    enableLatencySim(upperBoundMs) {\n      this.enableDebug();\n      console.log(\"latency simulator enabled for the duration of this browser session. Call disableLatencySim() to disable\");\n      this.sessionStorage.setItem(PHX_LV_LATENCY_SIM, upperBoundMs);\n    }\n\n    disableLatencySim() {\n      this.sessionStorage.removeItem(PHX_LV_LATENCY_SIM);\n    }\n\n    getLatencySim() {\n      let str = this.sessionStorage.getItem(PHX_LV_LATENCY_SIM);\n      return str ? parseInt(str) : null;\n    }\n\n    getSocket() {\n      return this.socket;\n    }\n\n    connect() {\n      let doConnect = () => {\n        if (this.joinRootViews()) {\n          this.bindTopLevelEvents();\n          this.socket.connect();\n        }\n      };\n\n      if ([\"complete\", \"loaded\", \"interactive\"].indexOf(document.readyState) >= 0) {\n        doConnect();\n      } else {\n        document.addEventListener(\"DOMContentLoaded\", () => doConnect());\n      }\n    }\n\n    disconnect(callback) {\n      this.socket.disconnect(callback);\n    }\n\n    execJS(el, encodedJS, eventType = null) {\n      this.owner(el, view => js_default.exec(eventType, encodedJS, view, el));\n    }\n\n    triggerDOM(kind, args) {\n      this.domCallbacks[kind](...args);\n    }\n\n    time(name, func) {\n      if (!this.isProfileEnabled() || !console.time) {\n        return func();\n      }\n\n      console.time(name);\n      let result = func();\n      console.timeEnd(name);\n      return result;\n    }\n\n    log(view, kind, msgCallback) {\n      if (this.viewLogger) {\n        let [msg, obj] = msgCallback();\n        this.viewLogger(view, kind, msg, obj);\n      } else if (this.isDebugEnabled()) {\n        let [msg, obj] = msgCallback();\n        debug(view, kind, msg, obj);\n      }\n    }\n\n    requestDOMUpdate(callback) {\n      this.transitions.after(callback);\n    }\n\n    transition(time, onStart, onDone = function () {}) {\n      this.transitions.addTransition(time, onStart, onDone);\n    }\n\n    onChannel(channel, event, cb) {\n      channel.on(event, data => {\n        let latency = this.getLatencySim();\n\n        if (!latency) {\n          cb(data);\n        } else {\n          console.log(`simulating ${latency}ms of latency from server to client`);\n          setTimeout(() => cb(data), latency);\n        }\n      });\n    }\n\n    wrapPush(view, opts, push) {\n      let latency = this.getLatencySim();\n      let oldJoinCount = view.joinCount;\n\n      if (!latency) {\n        if (opts.timeout) {\n          return push().receive(\"timeout\", () => {\n            if (view.joinCount === oldJoinCount && !view.isDestroyed()) {\n              this.reloadWithJitter(view, () => {\n                this.log(view, \"timeout\", () => [\"received timeout while communicating with server. Falling back to hard refresh for recovery\"]);\n              });\n            }\n          });\n        } else {\n          return push();\n        }\n      }\n\n      console.log(`simulating ${latency}ms of latency from client to server`);\n      let fakePush = {\n        receives: [],\n\n        receive(kind, cb) {\n          this.receives.push([kind, cb]);\n        }\n\n      };\n      setTimeout(() => {\n        if (view.isDestroyed()) {\n          return;\n        }\n\n        fakePush.receives.reduce((acc, [kind, cb]) => acc.receive(kind, cb), push());\n      }, latency);\n      return fakePush;\n    }\n\n    reloadWithJitter(view, log) {\n      view.destroy();\n      this.disconnect();\n      let [minMs, maxMs] = RELOAD_JITTER;\n      let afterMs = Math.floor(Math.random() * (maxMs - minMs + 1)) + minMs;\n      let tries = browser_default.updateLocal(this.localStorage, window.location.pathname, CONSECUTIVE_RELOADS, 0, count => count + 1);\n      log ? log() : this.log(view, \"join\", () => [`encountered ${tries} consecutive reloads`]);\n\n      if (tries > MAX_RELOADS) {\n        this.log(view, \"join\", () => [`exceeded ${MAX_RELOADS} consecutive reloads. Entering failsafe mode`]);\n        afterMs = FAILSAFE_JITTER;\n      }\n\n      setTimeout(() => {\n        if (this.hasPendingLink()) {\n          window.location = this.pendingLink;\n        } else {\n          window.location.reload();\n        }\n      }, afterMs);\n    }\n\n    getHookCallbacks(name) {\n      return name && name.startsWith(\"Phoenix.\") ? hooks_default[name.split(\".\")[1]] : this.hooks[name];\n    }\n\n    isUnloaded() {\n      return this.unloaded;\n    }\n\n    isConnected() {\n      return this.socket.isConnected();\n    }\n\n    getBindingPrefix() {\n      return this.bindingPrefix;\n    }\n\n    binding(kind) {\n      return `${this.getBindingPrefix()}${kind}`;\n    }\n\n    channel(topic, params) {\n      return this.socket.channel(topic, params);\n    }\n\n    joinRootViews() {\n      let rootsFound = false;\n      dom_default.all(document, `${PHX_VIEW_SELECTOR}:not([${PHX_PARENT_ID}])`, rootEl => {\n        if (!this.getRootById(rootEl.id)) {\n          let view = this.newRootView(rootEl);\n          view.setHref(this.getHref());\n          view.join();\n\n          if (rootEl.getAttribute(PHX_MAIN)) {\n            this.main = view;\n          }\n        }\n\n        rootsFound = true;\n      });\n      return rootsFound;\n    }\n\n    redirect(to, flash) {\n      this.disconnect();\n      browser_default.redirect(to, flash);\n    }\n\n    replaceMain(href, flash, callback = null, linkRef = this.setPendingLink(href)) {\n      let oldMainEl = this.main.el;\n      let newMainEl = dom_default.cloneNode(oldMainEl, \"\");\n      this.main.showLoader(this.loaderTimeout);\n      this.main.destroy();\n      this.main = this.newRootView(newMainEl, flash);\n      this.main.setRedirect(href);\n      this.transitionRemoves();\n      this.main.join((joinCount, onDone) => {\n        if (joinCount === 1 && this.commitPendingLink(linkRef)) {\n          this.requestDOMUpdate(() => {\n            oldMainEl.replaceWith(newMainEl);\n            callback && callback();\n            onDone();\n          });\n        }\n      });\n    }\n\n    transitionRemoves(elements) {\n      let removeAttr = this.binding(\"remove\");\n      elements = elements || dom_default.all(document, `[${removeAttr}]`);\n      elements.forEach(el => {\n        if (document.body.contains(el)) {\n          this.execJS(el, el.getAttribute(removeAttr), \"remove\");\n        }\n      });\n    }\n\n    isPhxView(el) {\n      return el.getAttribute && el.getAttribute(PHX_SESSION) !== null;\n    }\n\n    newRootView(el, flash) {\n      let view = new View(el, this, null, flash);\n      this.roots[view.id] = view;\n      return view;\n    }\n\n    owner(childEl, callback) {\n      let view = maybe(childEl.closest(PHX_VIEW_SELECTOR), el => this.getViewByEl(el)) || this.main;\n\n      if (view) {\n        callback(view);\n      }\n    }\n\n    withinOwners(childEl, callback) {\n      this.owner(childEl, view => callback(view, childEl));\n    }\n\n    getViewByEl(el) {\n      let rootId = el.getAttribute(PHX_ROOT_ID);\n      return maybe(this.getRootById(rootId), root => root.getDescendentByEl(el));\n    }\n\n    getRootById(id) {\n      return this.roots[id];\n    }\n\n    destroyAllViews() {\n      for (let id in this.roots) {\n        this.roots[id].destroy();\n        delete this.roots[id];\n      }\n    }\n\n    destroyViewByEl(el) {\n      let root = this.getRootById(el.getAttribute(PHX_ROOT_ID));\n\n      if (root) {\n        root.destroyDescendent(el.id);\n      }\n    }\n\n    setActiveElement(target) {\n      if (this.activeElement === target) {\n        return;\n      }\n\n      this.activeElement = target;\n\n      let cancel = () => {\n        if (target === this.activeElement) {\n          this.activeElement = null;\n        }\n\n        target.removeEventListener(\"mouseup\", this);\n        target.removeEventListener(\"touchend\", this);\n      };\n\n      target.addEventListener(\"mouseup\", cancel);\n      target.addEventListener(\"touchend\", cancel);\n    }\n\n    getActiveElement() {\n      if (document.activeElement === document.body) {\n        return this.activeElement || document.activeElement;\n      } else {\n        return document.activeElement || document.body;\n      }\n    }\n\n    dropActiveElement(view) {\n      if (this.prevActive && view.ownsElement(this.prevActive)) {\n        this.prevActive = null;\n      }\n    }\n\n    restorePreviouslyActiveFocus() {\n      if (this.prevActive && this.prevActive !== document.body) {\n        this.prevActive.focus();\n      }\n    }\n\n    blurActiveElement() {\n      this.prevActive = this.getActiveElement();\n\n      if (this.prevActive !== document.body) {\n        this.prevActive.blur();\n      }\n    }\n\n    bindTopLevelEvents() {\n      if (this.boundTopLevelEvents) {\n        return;\n      }\n\n      this.boundTopLevelEvents = true;\n      document.body.addEventListener(\"click\", function () {});\n      window.addEventListener(\"pageshow\", e => {\n        if (e.persisted) {\n          this.getSocket().disconnect();\n          this.withPageLoading({\n            to: window.location.href,\n            kind: \"redirect\"\n          });\n          window.location.reload();\n        }\n      }, true);\n      this.bindNav();\n      this.bindClicks();\n      this.bindForms();\n      this.bind({\n        keyup: \"keyup\",\n        keydown: \"keydown\"\n      }, (e, type, view, targetEl, phxEvent, eventTarget) => {\n        let matchKey = targetEl.getAttribute(this.binding(PHX_KEY));\n        let pressedKey = e.key && e.key.toLowerCase();\n\n        if (matchKey && matchKey.toLowerCase() !== pressedKey) {\n          return;\n        }\n\n        let data = __spreadValues({\n          key: e.key\n        }, this.eventMeta(type, e, targetEl));\n\n        js_default.exec(type, phxEvent, view, targetEl, [\"push\", {\n          data\n        }]);\n      });\n      this.bind({\n        blur: \"focusout\",\n        focus: \"focusin\"\n      }, (e, type, view, targetEl, phxEvent, eventTarget) => {\n        if (!eventTarget) {\n          let data = __spreadValues({\n            key: e.key\n          }, this.eventMeta(type, e, targetEl));\n\n          js_default.exec(type, phxEvent, view, targetEl, [\"push\", {\n            data\n          }]);\n        }\n      });\n      this.bind({\n        blur: \"blur\",\n        focus: \"focus\"\n      }, (e, type, view, targetEl, targetCtx, phxEvent, phxTarget) => {\n        if (phxTarget === \"window\") {\n          let data = this.eventMeta(type, e, targetEl);\n          js_default.exec(type, phxEvent, view, targetEl, [\"push\", {\n            data\n          }]);\n        }\n      });\n      window.addEventListener(\"dragover\", e => e.preventDefault());\n      window.addEventListener(\"drop\", e => {\n        e.preventDefault();\n        let dropTargetId = maybe(closestPhxBinding(e.target, this.binding(PHX_DROP_TARGET)), trueTarget => {\n          return trueTarget.getAttribute(this.binding(PHX_DROP_TARGET));\n        });\n        let dropTarget = dropTargetId && document.getElementById(dropTargetId);\n        let files = Array.from(e.dataTransfer.files || []);\n\n        if (!dropTarget || dropTarget.disabled || files.length === 0 || !(dropTarget.files instanceof FileList)) {\n          return;\n        }\n\n        LiveUploader.trackFiles(dropTarget, files);\n        dropTarget.dispatchEvent(new Event(\"input\", {\n          bubbles: true\n        }));\n      });\n      this.on(PHX_TRACK_UPLOADS, e => {\n        let uploadTarget = e.target;\n\n        if (!dom_default.isUploadInput(uploadTarget)) {\n          return;\n        }\n\n        let files = Array.from(e.detail.files || []).filter(f => f instanceof File || f instanceof Blob);\n        LiveUploader.trackFiles(uploadTarget, files);\n        uploadTarget.dispatchEvent(new Event(\"input\", {\n          bubbles: true\n        }));\n      });\n    }\n\n    eventMeta(eventName, e, targetEl) {\n      let callback = this.metadataCallbacks[eventName];\n      return callback ? callback(e, targetEl) : {};\n    }\n\n    setPendingLink(href) {\n      this.linkRef++;\n      this.pendingLink = href;\n      return this.linkRef;\n    }\n\n    commitPendingLink(linkRef) {\n      if (this.linkRef !== linkRef) {\n        return false;\n      } else {\n        this.href = this.pendingLink;\n        this.pendingLink = null;\n        return true;\n      }\n    }\n\n    getHref() {\n      return this.href;\n    }\n\n    hasPendingLink() {\n      return !!this.pendingLink;\n    }\n\n    bind(events, callback) {\n      for (let event in events) {\n        let browserEventName = events[event];\n        this.on(browserEventName, e => {\n          let binding = this.binding(event);\n          let windowBinding = this.binding(`window-${event}`);\n          let targetPhxEvent = e.target.getAttribute && e.target.getAttribute(binding);\n\n          if (targetPhxEvent) {\n            this.debounce(e.target, e, () => {\n              this.withinOwners(e.target, view => {\n                callback(e, event, view, e.target, targetPhxEvent, null);\n              });\n            });\n          } else {\n            dom_default.all(document, `[${windowBinding}]`, el => {\n              let phxEvent = el.getAttribute(windowBinding);\n              this.debounce(el, e, () => {\n                this.withinOwners(el, view => {\n                  callback(e, event, view, el, phxEvent, \"window\");\n                });\n              });\n            });\n          }\n        });\n      }\n    }\n\n    bindClicks() {\n      this.bindClick(\"click\", \"click\", false);\n      this.bindClick(\"mousedown\", \"capture-click\", true);\n    }\n\n    bindClick(eventName, bindingName, capture) {\n      let click = this.binding(bindingName);\n      window.addEventListener(eventName, e => {\n        if (!this.isConnected()) {\n          return;\n        }\n\n        let target = null;\n\n        if (capture) {\n          target = e.target.matches(`[${click}]`) ? e.target : e.target.querySelector(`[${click}]`);\n        } else {\n          target = closestPhxBinding(e.target, click);\n          this.dispatchClickAway(e);\n        }\n\n        let phxEvent = target && target.getAttribute(click);\n\n        if (!phxEvent) {\n          return;\n        }\n\n        if (target.getAttribute(\"href\") === \"#\") {\n          e.preventDefault();\n        }\n\n        this.debounce(target, e, () => {\n          this.withinOwners(target, view => {\n            js_default.exec(\"click\", phxEvent, view, target, [\"push\", {\n              data: this.eventMeta(\"click\", e, target)\n            }]);\n          });\n        });\n      }, capture);\n    }\n\n    dispatchClickAway(e) {\n      let binding = this.binding(\"click-away\");\n      dom_default.all(document, `[${binding}]`, el => {\n        if (!(el.isSameNode(e.target) || el.contains(e.target))) {\n          this.withinOwners(e.target, view => {\n            let phxEvent = el.getAttribute(binding);\n\n            if (js_default.isVisible(el)) {\n              js_default.exec(\"click\", phxEvent, view, e.target, [\"push\", {\n                data: this.eventMeta(\"click\", e, e.target)\n              }]);\n            }\n          });\n        }\n      });\n    }\n\n    bindNav() {\n      if (!browser_default.canPushState()) {\n        return;\n      }\n\n      if (history.scrollRestoration) {\n        history.scrollRestoration = \"manual\";\n      }\n\n      let scrollTimer = null;\n      window.addEventListener(\"scroll\", _e => {\n        clearTimeout(scrollTimer);\n        scrollTimer = setTimeout(() => {\n          browser_default.updateCurrentState(state => Object.assign(state, {\n            scroll: window.scrollY\n          }));\n        }, 100);\n      });\n      window.addEventListener(\"popstate\", event => {\n        if (!this.registerNewLocation(window.location)) {\n          return;\n        }\n\n        let {\n          type,\n          id,\n          root,\n          scroll\n        } = event.state || {};\n        let href = window.location.href;\n        this.requestDOMUpdate(() => {\n          if (this.main.isConnected() && type === \"patch\" && id === this.main.id) {\n            this.main.pushLinkPatch(href, null);\n          } else {\n            this.replaceMain(href, null, () => {\n              if (root) {\n                this.replaceRootHistory();\n              }\n\n              if (typeof scroll === \"number\") {\n                setTimeout(() => {\n                  window.scrollTo(0, scroll);\n                }, 0);\n              }\n            });\n          }\n        });\n      }, false);\n      window.addEventListener(\"click\", e => {\n        let target = closestPhxBinding(e.target, PHX_LIVE_LINK);\n        let type = target && target.getAttribute(PHX_LIVE_LINK);\n        let wantsNewTab = e.metaKey || e.ctrlKey || e.button === 1;\n\n        if (!type || !this.isConnected() || !this.main || wantsNewTab) {\n          return;\n        }\n\n        let href = target.href;\n        let linkState = target.getAttribute(PHX_LINK_STATE);\n        e.preventDefault();\n\n        if (this.pendingLink === href) {\n          return;\n        }\n\n        this.requestDOMUpdate(() => {\n          if (type === \"patch\") {\n            this.pushHistoryPatch(href, linkState, target);\n          } else if (type === \"redirect\") {\n            this.historyRedirect(href, linkState);\n          } else {\n            throw new Error(`expected ${PHX_LIVE_LINK} to be \"patch\" or \"redirect\", got: ${type}`);\n          }\n        });\n      }, false);\n    }\n\n    dispatchEvent(event, payload = {}) {\n      dom_default.dispatchEvent(window, `phx:${event}`, payload);\n    }\n\n    dispatchEvents(events) {\n      events.forEach(([event, payload]) => this.dispatchEvent(event, payload));\n    }\n\n    withPageLoading(info, callback) {\n      dom_default.dispatchEvent(window, \"phx:page-loading-start\", info);\n\n      let done = () => dom_default.dispatchEvent(window, \"phx:page-loading-stop\", info);\n\n      return callback ? callback(done) : done;\n    }\n\n    pushHistoryPatch(href, linkState, targetEl) {\n      this.withPageLoading({\n        to: href,\n        kind: \"patch\"\n      }, done => {\n        this.main.pushLinkPatch(href, targetEl, linkRef => {\n          this.historyPatch(href, linkState, linkRef);\n          done();\n        });\n      });\n    }\n\n    historyPatch(href, linkState, linkRef = this.setPendingLink(href)) {\n      if (!this.commitPendingLink(linkRef)) {\n        return;\n      }\n\n      browser_default.pushState(linkState, {\n        type: \"patch\",\n        id: this.main.id\n      }, href);\n      this.registerNewLocation(window.location);\n    }\n\n    historyRedirect(href, linkState, flash) {\n      let scroll = window.scrollY;\n      this.withPageLoading({\n        to: href,\n        kind: \"redirect\"\n      }, done => {\n        this.replaceMain(href, flash, () => {\n          browser_default.pushState(linkState, {\n            type: \"redirect\",\n            id: this.main.id,\n            scroll\n          }, href);\n          this.registerNewLocation(window.location);\n          done();\n        });\n      });\n    }\n\n    replaceRootHistory() {\n      browser_default.pushState(\"replace\", {\n        root: true,\n        type: \"patch\",\n        id: this.main.id\n      });\n    }\n\n    registerNewLocation(newLocation) {\n      let {\n        pathname,\n        search\n      } = this.currentLocation;\n\n      if (pathname + search === newLocation.pathname + newLocation.search) {\n        return false;\n      } else {\n        this.currentLocation = clone(newLocation);\n        return true;\n      }\n    }\n\n    bindForms() {\n      let iterations = 0;\n      this.on(\"submit\", e => {\n        let phxEvent = e.target.getAttribute(this.binding(\"submit\"));\n\n        if (!phxEvent) {\n          return;\n        }\n\n        e.preventDefault();\n        e.target.disabled = true;\n        this.withinOwners(e.target, view => {\n          js_default.exec(\"submit\", phxEvent, view, e.target, [\"push\", {}]);\n        });\n      }, false);\n\n      for (let type of [\"change\", \"input\"]) {\n        this.on(type, e => {\n          let input = e.target;\n          let phxEvent = input.form && input.form.getAttribute(this.binding(\"change\"));\n\n          if (!phxEvent) {\n            return;\n          }\n\n          if (input.type === \"number\" && input.validity && input.validity.badInput) {\n            return;\n          }\n\n          let currentIterations = iterations;\n          iterations++;\n          let {\n            at,\n            type: lastType\n          } = dom_default.private(input, \"prev-iteration\") || {};\n\n          if (at === currentIterations - 1 && type !== lastType) {\n            return;\n          }\n\n          dom_default.putPrivate(input, \"prev-iteration\", {\n            at: currentIterations,\n            type\n          });\n          this.debounce(input, e, () => {\n            this.withinOwners(input.form, view => {\n              dom_default.putPrivate(input, PHX_HAS_FOCUSED, true);\n\n              if (!dom_default.isTextualInput(input)) {\n                this.setActiveElement(input);\n              }\n\n              js_default.exec(\"change\", phxEvent, view, input, [\"push\", {\n                _target: e.target.name\n              }]);\n            });\n          });\n        }, false);\n      }\n    }\n\n    debounce(el, event, callback) {\n      let phxDebounce = this.binding(PHX_DEBOUNCE);\n      let phxThrottle = this.binding(PHX_THROTTLE);\n      let defaultDebounce = this.defaults.debounce.toString();\n      let defaultThrottle = this.defaults.throttle.toString();\n      dom_default.debounce(el, event, phxDebounce, defaultDebounce, phxThrottle, defaultThrottle, callback);\n    }\n\n    silenceEvents(callback) {\n      this.silenced = true;\n      callback();\n      this.silenced = false;\n    }\n\n    on(event, callback) {\n      window.addEventListener(event, e => {\n        if (!this.silenced) {\n          callback(e);\n        }\n      });\n    }\n\n  };\n  var TransitionSet = class {\n    constructor() {\n      this.transitions = new Set();\n      this.pendingOps = [];\n      this.reset();\n    }\n\n    reset() {\n      this.transitions.forEach(timer => {\n        cancelTimeout(timer);\n        this.transitions.delete(timer);\n      });\n      this.flushPendingOps();\n    }\n\n    after(callback) {\n      if (this.size() === 0) {\n        callback();\n      } else {\n        this.pushPendingOp(callback);\n      }\n    }\n\n    addTransition(time, onStart, onDone) {\n      onStart();\n      let timer = setTimeout(() => {\n        this.transitions.delete(timer);\n        onDone();\n\n        if (this.size() === 0) {\n          this.flushPendingOps();\n        }\n      }, time);\n      this.transitions.add(timer);\n    }\n\n    pushPendingOp(op) {\n      this.pendingOps.push(op);\n    }\n\n    size() {\n      return this.transitions.size;\n    }\n\n    flushPendingOps() {\n      this.pendingOps.forEach(op => op());\n      this.pendingOps = [];\n    }\n\n  };\n  return phoenix_live_view_exports;\n})();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vZGVwcy9waG9lbml4X2xpdmVfdmlldy9wcml2L3N0YXRpYy9waG9lbml4X2xpdmVfdmlldy5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uLi9kZXBzL3Bob2VuaXhfbGl2ZV92aWV3L3ByaXYvc3RhdGljL3Bob2VuaXhfbGl2ZV92aWV3LmpzPzJjOTAiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIExpdmVWaWV3ID0gKCgpID0+IHtcbiAgdmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbiAgdmFyIF9fZ2V0T3duUHJvcFN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xuICB2YXIgX19oYXNPd25Qcm9wID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbiAgdmFyIF9fcHJvcElzRW51bSA9IE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGU7XG4gIHZhciBfX2RlZk5vcm1hbFByb3AgPSAob2JqLCBrZXksIHZhbHVlKSA9PiBrZXkgaW4gb2JqID8gX19kZWZQcm9wKG9iaiwga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUsIHZhbHVlIH0pIDogb2JqW2tleV0gPSB2YWx1ZTtcbiAgdmFyIF9fc3ByZWFkVmFsdWVzID0gKGEsIGIpID0+IHtcbiAgICBmb3IgKHZhciBwcm9wIGluIGIgfHwgKGIgPSB7fSkpXG4gICAgICBpZiAoX19oYXNPd25Qcm9wLmNhbGwoYiwgcHJvcCkpXG4gICAgICAgIF9fZGVmTm9ybWFsUHJvcChhLCBwcm9wLCBiW3Byb3BdKTtcbiAgICBpZiAoX19nZXRPd25Qcm9wU3ltYm9scylcbiAgICAgIGZvciAodmFyIHByb3Agb2YgX19nZXRPd25Qcm9wU3ltYm9scyhiKSkge1xuICAgICAgICBpZiAoX19wcm9wSXNFbnVtLmNhbGwoYiwgcHJvcCkpXG4gICAgICAgICAgX19kZWZOb3JtYWxQcm9wKGEsIHByb3AsIGJbcHJvcF0pO1xuICAgICAgfVxuICAgIHJldHVybiBhO1xuICB9O1xuICB2YXIgX19tYXJrQXNNb2R1bGUgPSAodGFyZ2V0KSA9PiBfX2RlZlByb3AodGFyZ2V0LCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbiAgdmFyIF9fZXhwb3J0ID0gKHRhcmdldCwgYWxsKSA9PiB7XG4gICAgX19tYXJrQXNNb2R1bGUodGFyZ2V0KTtcbiAgICBmb3IgKHZhciBuYW1lIGluIGFsbClcbiAgICAgIF9fZGVmUHJvcCh0YXJnZXQsIG5hbWUsIHsgZ2V0OiBhbGxbbmFtZV0sIGVudW1lcmFibGU6IHRydWUgfSk7XG4gIH07XG5cbiAgLy8ganMvcGhvZW5peF9saXZlX3ZpZXcvaW5kZXguanNcbiAgdmFyIHBob2VuaXhfbGl2ZV92aWV3X2V4cG9ydHMgPSB7fTtcbiAgX19leHBvcnQocGhvZW5peF9saXZlX3ZpZXdfZXhwb3J0cywge1xuICAgIExpdmVTb2NrZXQ6ICgpID0+IExpdmVTb2NrZXRcbiAgfSk7XG5cbiAgLy8ganMvcGhvZW5peF9saXZlX3ZpZXcvY29uc3RhbnRzLmpzXG4gIHZhciBDT05TRUNVVElWRV9SRUxPQURTID0gXCJjb25zZWN1dGl2ZS1yZWxvYWRzXCI7XG4gIHZhciBNQVhfUkVMT0FEUyA9IDEwO1xuICB2YXIgUkVMT0FEX0pJVFRFUiA9IFsxZTMsIDNlM107XG4gIHZhciBGQUlMU0FGRV9KSVRURVIgPSAzZTQ7XG4gIHZhciBQSFhfRVZFTlRfQ0xBU1NFUyA9IFtcbiAgICBcInBoeC1jbGljay1sb2FkaW5nXCIsXG4gICAgXCJwaHgtY2hhbmdlLWxvYWRpbmdcIixcbiAgICBcInBoeC1zdWJtaXQtbG9hZGluZ1wiLFxuICAgIFwicGh4LWtleWRvd24tbG9hZGluZ1wiLFxuICAgIFwicGh4LWtleXVwLWxvYWRpbmdcIixcbiAgICBcInBoeC1ibHVyLWxvYWRpbmdcIixcbiAgICBcInBoeC1mb2N1cy1sb2FkaW5nXCJcbiAgXTtcbiAgdmFyIFBIWF9DT01QT05FTlQgPSBcImRhdGEtcGh4LWNvbXBvbmVudFwiO1xuICB2YXIgUEhYX0xJVkVfTElOSyA9IFwiZGF0YS1waHgtbGlua1wiO1xuICB2YXIgUEhYX1RSQUNLX1NUQVRJQyA9IFwidHJhY2stc3RhdGljXCI7XG4gIHZhciBQSFhfTElOS19TVEFURSA9IFwiZGF0YS1waHgtbGluay1zdGF0ZVwiO1xuICB2YXIgUEhYX1JFRiA9IFwiZGF0YS1waHgtcmVmXCI7XG4gIHZhciBQSFhfVFJBQ0tfVVBMT0FEUyA9IFwidHJhY2stdXBsb2Fkc1wiO1xuICB2YXIgUEhYX1VQTE9BRF9SRUYgPSBcImRhdGEtcGh4LXVwbG9hZC1yZWZcIjtcbiAgdmFyIFBIWF9QUkVGTElHSFRFRF9SRUZTID0gXCJkYXRhLXBoeC1wcmVmbGlnaHRlZC1yZWZzXCI7XG4gIHZhciBQSFhfRE9ORV9SRUZTID0gXCJkYXRhLXBoeC1kb25lLXJlZnNcIjtcbiAgdmFyIFBIWF9EUk9QX1RBUkdFVCA9IFwiZHJvcC10YXJnZXRcIjtcbiAgdmFyIFBIWF9BQ1RJVkVfRU5UUllfUkVGUyA9IFwiZGF0YS1waHgtYWN0aXZlLXJlZnNcIjtcbiAgdmFyIFBIWF9MSVZFX0ZJTEVfVVBEQVRFRCA9IFwicGh4OmxpdmUtZmlsZTp1cGRhdGVkXCI7XG4gIHZhciBQSFhfU0tJUCA9IFwiZGF0YS1waHgtc2tpcFwiO1xuICB2YXIgUEhYX1BSVU5FID0gXCJkYXRhLXBoeC1wcnVuZVwiO1xuICB2YXIgUEhYX1BBR0VfTE9BRElORyA9IFwicGFnZS1sb2FkaW5nXCI7XG4gIHZhciBQSFhfQ09OTkVDVEVEX0NMQVNTID0gXCJwaHgtY29ubmVjdGVkXCI7XG4gIHZhciBQSFhfRElTQ09OTkVDVEVEX0NMQVNTID0gXCJwaHgtbG9hZGluZ1wiO1xuICB2YXIgUEhYX05PX0ZFRURCQUNLX0NMQVNTID0gXCJwaHgtbm8tZmVlZGJhY2tcIjtcbiAgdmFyIFBIWF9FUlJPUl9DTEFTUyA9IFwicGh4LWVycm9yXCI7XG4gIHZhciBQSFhfUEFSRU5UX0lEID0gXCJkYXRhLXBoeC1wYXJlbnQtaWRcIjtcbiAgdmFyIFBIWF9NQUlOID0gXCJkYXRhLXBoeC1tYWluXCI7XG4gIHZhciBQSFhfUk9PVF9JRCA9IFwiZGF0YS1waHgtcm9vdC1pZFwiO1xuICB2YXIgUEhYX1RSSUdHRVJfQUNUSU9OID0gXCJ0cmlnZ2VyLWFjdGlvblwiO1xuICB2YXIgUEhYX0ZFRURCQUNLX0ZPUiA9IFwiZmVlZGJhY2stZm9yXCI7XG4gIHZhciBQSFhfSEFTX0ZPQ1VTRUQgPSBcInBoeC1oYXMtZm9jdXNlZFwiO1xuICB2YXIgRk9DVVNBQkxFX0lOUFVUUyA9IFtcInRleHRcIiwgXCJ0ZXh0YXJlYVwiLCBcIm51bWJlclwiLCBcImVtYWlsXCIsIFwicGFzc3dvcmRcIiwgXCJzZWFyY2hcIiwgXCJ0ZWxcIiwgXCJ1cmxcIiwgXCJkYXRlXCIsIFwidGltZVwiXTtcbiAgdmFyIENIRUNLQUJMRV9JTlBVVFMgPSBbXCJjaGVja2JveFwiLCBcInJhZGlvXCJdO1xuICB2YXIgUEhYX0hBU19TVUJNSVRURUQgPSBcInBoeC1oYXMtc3VibWl0dGVkXCI7XG4gIHZhciBQSFhfU0VTU0lPTiA9IFwiZGF0YS1waHgtc2Vzc2lvblwiO1xuICB2YXIgUEhYX1ZJRVdfU0VMRUNUT1IgPSBgWyR7UEhYX1NFU1NJT059XWA7XG4gIHZhciBQSFhfU1RBVElDID0gXCJkYXRhLXBoeC1zdGF0aWNcIjtcbiAgdmFyIFBIWF9SRUFET05MWSA9IFwiZGF0YS1waHgtcmVhZG9ubHlcIjtcbiAgdmFyIFBIWF9ESVNBQkxFRCA9IFwiZGF0YS1waHgtZGlzYWJsZWRcIjtcbiAgdmFyIFBIWF9ESVNBQkxFX1dJVEggPSBcImRpc2FibGUtd2l0aFwiO1xuICB2YXIgUEhYX0RJU0FCTEVfV0lUSF9SRVNUT1JFID0gXCJkYXRhLXBoeC1kaXNhYmxlLXdpdGgtcmVzdG9yZVwiO1xuICB2YXIgUEhYX0hPT0sgPSBcImhvb2tcIjtcbiAgdmFyIFBIWF9ERUJPVU5DRSA9IFwiZGVib3VuY2VcIjtcbiAgdmFyIFBIWF9USFJPVFRMRSA9IFwidGhyb3R0bGVcIjtcbiAgdmFyIFBIWF9VUERBVEUgPSBcInVwZGF0ZVwiO1xuICB2YXIgUEhYX0tFWSA9IFwia2V5XCI7XG4gIHZhciBQSFhfUFJJVkFURSA9IFwicGh4UHJpdmF0ZVwiO1xuICB2YXIgUEhYX0FVVE9fUkVDT1ZFUiA9IFwiYXV0by1yZWNvdmVyXCI7XG4gIHZhciBQSFhfTFZfREVCVUcgPSBcInBoeDpsaXZlLXNvY2tldDpkZWJ1Z1wiO1xuICB2YXIgUEhYX0xWX1BST0ZJTEUgPSBcInBoeDpsaXZlLXNvY2tldDpwcm9maWxpbmdcIjtcbiAgdmFyIFBIWF9MVl9MQVRFTkNZX1NJTSA9IFwicGh4OmxpdmUtc29ja2V0OmxhdGVuY3ktc2ltXCI7XG4gIHZhciBQSFhfUFJPR1JFU1MgPSBcInByb2dyZXNzXCI7XG4gIHZhciBMT0FERVJfVElNRU9VVCA9IDE7XG4gIHZhciBCRUZPUkVfVU5MT0FEX0xPQURFUl9USU1FT1VUID0gMjAwO1xuICB2YXIgQklORElOR19QUkVGSVggPSBcInBoeC1cIjtcbiAgdmFyIFBVU0hfVElNRU9VVCA9IDNlNDtcbiAgdmFyIERFQk9VTkNFX1RSSUdHRVIgPSBcImRlYm91bmNlLXRyaWdnZXJcIjtcbiAgdmFyIFRIUk9UVExFRCA9IFwidGhyb3R0bGVkXCI7XG4gIHZhciBERUJPVU5DRV9QUkVWX0tFWSA9IFwiZGVib3VuY2UtcHJldi1rZXlcIjtcbiAgdmFyIERFRkFVTFRTID0ge1xuICAgIGRlYm91bmNlOiAzMDAsXG4gICAgdGhyb3R0bGU6IDMwMFxuICB9O1xuICB2YXIgRFlOQU1JQ1MgPSBcImRcIjtcbiAgdmFyIFNUQVRJQyA9IFwic1wiO1xuICB2YXIgQ09NUE9ORU5UUyA9IFwiY1wiO1xuICB2YXIgRVZFTlRTID0gXCJlXCI7XG4gIHZhciBSRVBMWSA9IFwiclwiO1xuICB2YXIgVElUTEUgPSBcInRcIjtcbiAgdmFyIFRFTVBMQVRFUyA9IFwicFwiO1xuXG4gIC8vIGpzL3Bob2VuaXhfbGl2ZV92aWV3L2VudHJ5X3VwbG9hZGVyLmpzXG4gIHZhciBFbnRyeVVwbG9hZGVyID0gY2xhc3Mge1xuICAgIGNvbnN0cnVjdG9yKGVudHJ5LCBjaHVua1NpemUsIGxpdmVTb2NrZXQpIHtcbiAgICAgIHRoaXMubGl2ZVNvY2tldCA9IGxpdmVTb2NrZXQ7XG4gICAgICB0aGlzLmVudHJ5ID0gZW50cnk7XG4gICAgICB0aGlzLm9mZnNldCA9IDA7XG4gICAgICB0aGlzLmNodW5rU2l6ZSA9IGNodW5rU2l6ZTtcbiAgICAgIHRoaXMuY2h1bmtUaW1lciA9IG51bGw7XG4gICAgICB0aGlzLnVwbG9hZENoYW5uZWwgPSBsaXZlU29ja2V0LmNoYW5uZWwoYGx2dToke2VudHJ5LnJlZn1gLCB7IHRva2VuOiBlbnRyeS5tZXRhZGF0YSgpIH0pO1xuICAgIH1cbiAgICBlcnJvcihyZWFzb24pIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLmNodW5rVGltZXIpO1xuICAgICAgdGhpcy51cGxvYWRDaGFubmVsLmxlYXZlKCk7XG4gICAgICB0aGlzLmVudHJ5LmVycm9yKHJlYXNvbik7XG4gICAgfVxuICAgIHVwbG9hZCgpIHtcbiAgICAgIHRoaXMudXBsb2FkQ2hhbm5lbC5vbkVycm9yKChyZWFzb24pID0+IHRoaXMuZXJyb3IocmVhc29uKSk7XG4gICAgICB0aGlzLnVwbG9hZENoYW5uZWwuam9pbigpLnJlY2VpdmUoXCJva1wiLCAoX2RhdGEpID0+IHRoaXMucmVhZE5leHRDaHVuaygpKS5yZWNlaXZlKFwiZXJyb3JcIiwgKHJlYXNvbikgPT4gdGhpcy5lcnJvcihyZWFzb24pKTtcbiAgICB9XG4gICAgaXNEb25lKCkge1xuICAgICAgcmV0dXJuIHRoaXMub2Zmc2V0ID49IHRoaXMuZW50cnkuZmlsZS5zaXplO1xuICAgIH1cbiAgICByZWFkTmV4dENodW5rKCkge1xuICAgICAgbGV0IHJlYWRlciA9IG5ldyB3aW5kb3cuRmlsZVJlYWRlcigpO1xuICAgICAgbGV0IGJsb2IgPSB0aGlzLmVudHJ5LmZpbGUuc2xpY2UodGhpcy5vZmZzZXQsIHRoaXMuY2h1bmtTaXplICsgdGhpcy5vZmZzZXQpO1xuICAgICAgcmVhZGVyLm9ubG9hZCA9IChlKSA9PiB7XG4gICAgICAgIGlmIChlLnRhcmdldC5lcnJvciA9PT0gbnVsbCkge1xuICAgICAgICAgIHRoaXMub2Zmc2V0ICs9IGUudGFyZ2V0LnJlc3VsdC5ieXRlTGVuZ3RoO1xuICAgICAgICAgIHRoaXMucHVzaENodW5rKGUudGFyZ2V0LnJlc3VsdCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGxvZ0Vycm9yKFwiUmVhZCBlcnJvcjogXCIgKyBlLnRhcmdldC5lcnJvcik7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICByZWFkZXIucmVhZEFzQXJyYXlCdWZmZXIoYmxvYik7XG4gICAgfVxuICAgIHB1c2hDaHVuayhjaHVuaykge1xuICAgICAgaWYgKCF0aGlzLnVwbG9hZENoYW5uZWwuaXNKb2luZWQoKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLnVwbG9hZENoYW5uZWwucHVzaChcImNodW5rXCIsIGNodW5rKS5yZWNlaXZlKFwib2tcIiwgKCkgPT4ge1xuICAgICAgICB0aGlzLmVudHJ5LnByb2dyZXNzKHRoaXMub2Zmc2V0IC8gdGhpcy5lbnRyeS5maWxlLnNpemUgKiAxMDApO1xuICAgICAgICBpZiAoIXRoaXMuaXNEb25lKCkpIHtcbiAgICAgICAgICB0aGlzLmNodW5rVGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHRoaXMucmVhZE5leHRDaHVuaygpLCB0aGlzLmxpdmVTb2NrZXQuZ2V0TGF0ZW5jeVNpbSgpIHx8IDApO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH07XG5cbiAgLy8ganMvcGhvZW5peF9saXZlX3ZpZXcvdXRpbHMuanNcbiAgdmFyIGxvZ0Vycm9yID0gKG1zZywgb2JqKSA9PiBjb25zb2xlLmVycm9yICYmIGNvbnNvbGUuZXJyb3IobXNnLCBvYmopO1xuICB2YXIgaXNDaWQgPSAoY2lkKSA9PiB7XG4gICAgbGV0IHR5cGUgPSB0eXBlb2YgY2lkO1xuICAgIHJldHVybiB0eXBlID09PSBcIm51bWJlclwiIHx8IHR5cGUgPT09IFwic3RyaW5nXCIgJiYgL14oMHxbMS05XVxcZCopJC8udGVzdChjaWQpO1xuICB9O1xuICBmdW5jdGlvbiBkZXRlY3REdXBsaWNhdGVJZHMoKSB7XG4gICAgbGV0IGlkcyA9IG5ldyBTZXQoKTtcbiAgICBsZXQgZWxlbXMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKFwiKltpZF1cIik7XG4gICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IGVsZW1zLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBpZiAoaWRzLmhhcyhlbGVtc1tpXS5pZCkpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihgTXVsdGlwbGUgSURzIGRldGVjdGVkOiAke2VsZW1zW2ldLmlkfS4gRW5zdXJlIHVuaXF1ZSBlbGVtZW50IGlkcy5gKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlkcy5hZGQoZWxlbXNbaV0uaWQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICB2YXIgZGVidWcgPSAodmlldywga2luZCwgbXNnLCBvYmopID0+IHtcbiAgICBpZiAodmlldy5saXZlU29ja2V0LmlzRGVidWdFbmFibGVkKCkpIHtcbiAgICAgIGNvbnNvbGUubG9nKGAke3ZpZXcuaWR9ICR7a2luZH06ICR7bXNnfSAtIGAsIG9iaik7XG4gICAgfVxuICB9O1xuICB2YXIgY2xvc3VyZSA9ICh2YWwpID0+IHR5cGVvZiB2YWwgPT09IFwiZnVuY3Rpb25cIiA/IHZhbCA6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB2YWw7XG4gIH07XG4gIHZhciBjbG9uZSA9IChvYmopID0+IHtcbiAgICByZXR1cm4gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShvYmopKTtcbiAgfTtcbiAgdmFyIGNsb3Nlc3RQaHhCaW5kaW5nID0gKGVsLCBiaW5kaW5nLCBib3JkZXJFbCkgPT4ge1xuICAgIGRvIHtcbiAgICAgIGlmIChlbC5tYXRjaGVzKGBbJHtiaW5kaW5nfV1gKSkge1xuICAgICAgICByZXR1cm4gZWw7XG4gICAgICB9XG4gICAgICBlbCA9IGVsLnBhcmVudEVsZW1lbnQgfHwgZWwucGFyZW50Tm9kZTtcbiAgICB9IHdoaWxlIChlbCAhPT0gbnVsbCAmJiBlbC5ub2RlVHlwZSA9PT0gMSAmJiAhKGJvcmRlckVsICYmIGJvcmRlckVsLmlzU2FtZU5vZGUoZWwpIHx8IGVsLm1hdGNoZXMoUEhYX1ZJRVdfU0VMRUNUT1IpKSk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH07XG4gIHZhciBpc09iamVjdCA9IChvYmopID0+IHtcbiAgICByZXR1cm4gb2JqICE9PSBudWxsICYmIHR5cGVvZiBvYmogPT09IFwib2JqZWN0XCIgJiYgIShvYmogaW5zdGFuY2VvZiBBcnJheSk7XG4gIH07XG4gIHZhciBpc0VxdWFsT2JqID0gKG9iajEsIG9iajIpID0+IEpTT04uc3RyaW5naWZ5KG9iajEpID09PSBKU09OLnN0cmluZ2lmeShvYmoyKTtcbiAgdmFyIGlzRW1wdHkgPSAob2JqKSA9PiB7XG4gICAgZm9yIChsZXQgeCBpbiBvYmopIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG4gIHZhciBtYXliZSA9IChlbCwgY2FsbGJhY2spID0+IGVsICYmIGNhbGxiYWNrKGVsKTtcbiAgdmFyIGNoYW5uZWxVcGxvYWRlciA9IGZ1bmN0aW9uKGVudHJpZXMsIG9uRXJyb3IsIHJlc3AsIGxpdmVTb2NrZXQpIHtcbiAgICBlbnRyaWVzLmZvckVhY2goKGVudHJ5KSA9PiB7XG4gICAgICBsZXQgZW50cnlVcGxvYWRlciA9IG5ldyBFbnRyeVVwbG9hZGVyKGVudHJ5LCByZXNwLmNvbmZpZy5jaHVua19zaXplLCBsaXZlU29ja2V0KTtcbiAgICAgIGVudHJ5VXBsb2FkZXIudXBsb2FkKCk7XG4gICAgfSk7XG4gIH07XG5cbiAgLy8ganMvcGhvZW5peF9saXZlX3ZpZXcvYnJvd3Nlci5qc1xuICB2YXIgQnJvd3NlciA9IHtcbiAgICBjYW5QdXNoU3RhdGUoKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIGhpc3RvcnkucHVzaFN0YXRlICE9PSBcInVuZGVmaW5lZFwiO1xuICAgIH0sXG4gICAgZHJvcExvY2FsKGxvY2FsU3RvcmFnZSwgbmFtZXNwYWNlLCBzdWJrZXkpIHtcbiAgICAgIHJldHVybiBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbSh0aGlzLmxvY2FsS2V5KG5hbWVzcGFjZSwgc3Via2V5KSk7XG4gICAgfSxcbiAgICB1cGRhdGVMb2NhbChsb2NhbFN0b3JhZ2UsIG5hbWVzcGFjZSwgc3Via2V5LCBpbml0aWFsLCBmdW5jKSB7XG4gICAgICBsZXQgY3VycmVudCA9IHRoaXMuZ2V0TG9jYWwobG9jYWxTdG9yYWdlLCBuYW1lc3BhY2UsIHN1YmtleSk7XG4gICAgICBsZXQga2V5ID0gdGhpcy5sb2NhbEtleShuYW1lc3BhY2UsIHN1YmtleSk7XG4gICAgICBsZXQgbmV3VmFsID0gY3VycmVudCA9PT0gbnVsbCA/IGluaXRpYWwgOiBmdW5jKGN1cnJlbnQpO1xuICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oa2V5LCBKU09OLnN0cmluZ2lmeShuZXdWYWwpKTtcbiAgICAgIHJldHVybiBuZXdWYWw7XG4gICAgfSxcbiAgICBnZXRMb2NhbChsb2NhbFN0b3JhZ2UsIG5hbWVzcGFjZSwgc3Via2V5KSB7XG4gICAgICByZXR1cm4gSlNPTi5wYXJzZShsb2NhbFN0b3JhZ2UuZ2V0SXRlbSh0aGlzLmxvY2FsS2V5KG5hbWVzcGFjZSwgc3Via2V5KSkpO1xuICAgIH0sXG4gICAgdXBkYXRlQ3VycmVudFN0YXRlKGNhbGxiYWNrKSB7XG4gICAgICBpZiAoIXRoaXMuY2FuUHVzaFN0YXRlKCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaGlzdG9yeS5yZXBsYWNlU3RhdGUoY2FsbGJhY2soaGlzdG9yeS5zdGF0ZSB8fCB7fSksIFwiXCIsIHdpbmRvdy5sb2NhdGlvbi5ocmVmKTtcbiAgICB9LFxuICAgIHB1c2hTdGF0ZShraW5kLCBtZXRhLCB0bykge1xuICAgICAgaWYgKHRoaXMuY2FuUHVzaFN0YXRlKCkpIHtcbiAgICAgICAgaWYgKHRvICE9PSB3aW5kb3cubG9jYXRpb24uaHJlZikge1xuICAgICAgICAgIGlmIChtZXRhLnR5cGUgPT0gXCJyZWRpcmVjdFwiICYmIG1ldGEuc2Nyb2xsKSB7XG4gICAgICAgICAgICBsZXQgY3VycmVudFN0YXRlID0gaGlzdG9yeS5zdGF0ZSB8fCB7fTtcbiAgICAgICAgICAgIGN1cnJlbnRTdGF0ZS5zY3JvbGwgPSBtZXRhLnNjcm9sbDtcbiAgICAgICAgICAgIGhpc3RvcnkucmVwbGFjZVN0YXRlKGN1cnJlbnRTdGF0ZSwgXCJcIiwgd2luZG93LmxvY2F0aW9uLmhyZWYpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBkZWxldGUgbWV0YS5zY3JvbGw7XG4gICAgICAgICAgaGlzdG9yeVtraW5kICsgXCJTdGF0ZVwiXShtZXRhLCBcIlwiLCB0byB8fCBudWxsKTtcbiAgICAgICAgICBsZXQgaGFzaEVsID0gdGhpcy5nZXRIYXNoVGFyZ2V0RWwod2luZG93LmxvY2F0aW9uLmhhc2gpO1xuICAgICAgICAgIGlmIChoYXNoRWwpIHtcbiAgICAgICAgICAgIGhhc2hFbC5zY3JvbGxJbnRvVmlldygpO1xuICAgICAgICAgIH0gZWxzZSBpZiAobWV0YS50eXBlID09PSBcInJlZGlyZWN0XCIpIHtcbiAgICAgICAgICAgIHdpbmRvdy5zY3JvbGwoMCwgMCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnJlZGlyZWN0KHRvKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHNldENvb2tpZShuYW1lLCB2YWx1ZSkge1xuICAgICAgZG9jdW1lbnQuY29va2llID0gYCR7bmFtZX09JHt2YWx1ZX1gO1xuICAgIH0sXG4gICAgZ2V0Q29va2llKG5hbWUpIHtcbiAgICAgIHJldHVybiBkb2N1bWVudC5jb29raWUucmVwbGFjZShuZXcgUmVnRXhwKGAoPzooPzpefC4qO3MqKSR7bmFtZX1zKj1zKihbXjtdKikuKiQpfF4uKiRgKSwgXCIkMVwiKTtcbiAgICB9LFxuICAgIHJlZGlyZWN0KHRvVVJMLCBmbGFzaCkge1xuICAgICAgaWYgKGZsYXNoKSB7XG4gICAgICAgIEJyb3dzZXIuc2V0Q29va2llKFwiX19waG9lbml4X2ZsYXNoX19cIiwgZmxhc2ggKyBcIjsgbWF4LWFnZT02MDAwMDsgcGF0aD0vXCIpO1xuICAgICAgfVxuICAgICAgd2luZG93LmxvY2F0aW9uID0gdG9VUkw7XG4gICAgfSxcbiAgICBsb2NhbEtleShuYW1lc3BhY2UsIHN1YmtleSkge1xuICAgICAgcmV0dXJuIGAke25hbWVzcGFjZX0tJHtzdWJrZXl9YDtcbiAgICB9LFxuICAgIGdldEhhc2hUYXJnZXRFbChtYXliZUhhc2gpIHtcbiAgICAgIGxldCBoYXNoID0gbWF5YmVIYXNoLnRvU3RyaW5nKCkuc3Vic3RyaW5nKDEpO1xuICAgICAgaWYgKGhhc2ggPT09IFwiXCIpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGhhc2gpIHx8IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoYGFbbmFtZT1cIiR7aGFzaH1cIl1gKTtcbiAgICB9XG4gIH07XG4gIHZhciBicm93c2VyX2RlZmF1bHQgPSBCcm93c2VyO1xuXG4gIC8vIGpzL3Bob2VuaXhfbGl2ZV92aWV3L2RvbS5qc1xuICB2YXIgRE9NID0ge1xuICAgIGJ5SWQoaWQpIHtcbiAgICAgIHJldHVybiBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChpZCkgfHwgbG9nRXJyb3IoYG5vIGlkIGZvdW5kIGZvciAke2lkfWApO1xuICAgIH0sXG4gICAgcmVtb3ZlQ2xhc3MoZWwsIGNsYXNzTmFtZSkge1xuICAgICAgZWwuY2xhc3NMaXN0LnJlbW92ZShjbGFzc05hbWUpO1xuICAgICAgaWYgKGVsLmNsYXNzTGlzdC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKFwiY2xhc3NcIik7XG4gICAgICB9XG4gICAgfSxcbiAgICBhbGwobm9kZSwgcXVlcnksIGNhbGxiYWNrKSB7XG4gICAgICBpZiAoIW5vZGUpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgICAgbGV0IGFycmF5ID0gQXJyYXkuZnJvbShub2RlLnF1ZXJ5U2VsZWN0b3JBbGwocXVlcnkpKTtcbiAgICAgIHJldHVybiBjYWxsYmFjayA/IGFycmF5LmZvckVhY2goY2FsbGJhY2spIDogYXJyYXk7XG4gICAgfSxcbiAgICBjaGlsZE5vZGVMZW5ndGgoaHRtbCkge1xuICAgICAgbGV0IHRlbXBsYXRlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInRlbXBsYXRlXCIpO1xuICAgICAgdGVtcGxhdGUuaW5uZXJIVE1MID0gaHRtbDtcbiAgICAgIHJldHVybiB0ZW1wbGF0ZS5jb250ZW50LmNoaWxkRWxlbWVudENvdW50O1xuICAgIH0sXG4gICAgaXNVcGxvYWRJbnB1dChlbCkge1xuICAgICAgcmV0dXJuIGVsLnR5cGUgPT09IFwiZmlsZVwiICYmIGVsLmdldEF0dHJpYnV0ZShQSFhfVVBMT0FEX1JFRikgIT09IG51bGw7XG4gICAgfSxcbiAgICBmaW5kVXBsb2FkSW5wdXRzKG5vZGUpIHtcbiAgICAgIHJldHVybiB0aGlzLmFsbChub2RlLCBgaW5wdXRbdHlwZT1cImZpbGVcIl1bJHtQSFhfVVBMT0FEX1JFRn1dYCk7XG4gICAgfSxcbiAgICBmaW5kQ29tcG9uZW50Tm9kZUxpc3Qobm9kZSwgY2lkKSB7XG4gICAgICByZXR1cm4gdGhpcy5maWx0ZXJXaXRoaW5TYW1lTGl2ZVZpZXcodGhpcy5hbGwobm9kZSwgYFske1BIWF9DT01QT05FTlR9PVwiJHtjaWR9XCJdYCksIG5vZGUpO1xuICAgIH0sXG4gICAgaXNQaHhEZXN0cm95ZWQobm9kZSkge1xuICAgICAgcmV0dXJuIG5vZGUuaWQgJiYgRE9NLnByaXZhdGUobm9kZSwgXCJkZXN0cm95ZWRcIikgPyB0cnVlIDogZmFsc2U7XG4gICAgfSxcbiAgICBtYXJrUGh4Q2hpbGREZXN0cm95ZWQoZWwpIHtcbiAgICAgIGlmICh0aGlzLmlzUGh4Q2hpbGQoZWwpKSB7XG4gICAgICAgIGVsLnNldEF0dHJpYnV0ZShQSFhfU0VTU0lPTiwgXCJcIik7XG4gICAgICB9XG4gICAgICB0aGlzLnB1dFByaXZhdGUoZWwsIFwiZGVzdHJveWVkXCIsIHRydWUpO1xuICAgIH0sXG4gICAgZmluZFBoeENoaWxkcmVuSW5GcmFnbWVudChodG1sLCBwYXJlbnRJZCkge1xuICAgICAgbGV0IHRlbXBsYXRlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInRlbXBsYXRlXCIpO1xuICAgICAgdGVtcGxhdGUuaW5uZXJIVE1MID0gaHRtbDtcbiAgICAgIHJldHVybiB0aGlzLmZpbmRQaHhDaGlsZHJlbih0ZW1wbGF0ZS5jb250ZW50LCBwYXJlbnRJZCk7XG4gICAgfSxcbiAgICBpc0lnbm9yZWQoZWwsIHBoeFVwZGF0ZSkge1xuICAgICAgcmV0dXJuIChlbC5nZXRBdHRyaWJ1dGUocGh4VXBkYXRlKSB8fCBlbC5nZXRBdHRyaWJ1dGUoXCJkYXRhLXBoeC11cGRhdGVcIikpID09PSBcImlnbm9yZVwiO1xuICAgIH0sXG4gICAgaXNQaHhVcGRhdGUoZWwsIHBoeFVwZGF0ZSwgdXBkYXRlVHlwZXMpIHtcbiAgICAgIHJldHVybiBlbC5nZXRBdHRyaWJ1dGUgJiYgdXBkYXRlVHlwZXMuaW5kZXhPZihlbC5nZXRBdHRyaWJ1dGUocGh4VXBkYXRlKSkgPj0gMDtcbiAgICB9LFxuICAgIGZpbmRQaHhDaGlsZHJlbihlbCwgcGFyZW50SWQpIHtcbiAgICAgIHJldHVybiB0aGlzLmFsbChlbCwgYCR7UEhYX1ZJRVdfU0VMRUNUT1J9WyR7UEhYX1BBUkVOVF9JRH09XCIke3BhcmVudElkfVwiXWApO1xuICAgIH0sXG4gICAgZmluZFBhcmVudENJRHMobm9kZSwgY2lkcykge1xuICAgICAgbGV0IGluaXRpYWwgPSBuZXcgU2V0KGNpZHMpO1xuICAgICAgcmV0dXJuIGNpZHMucmVkdWNlKChhY2MsIGNpZCkgPT4ge1xuICAgICAgICBsZXQgc2VsZWN0b3IgPSBgWyR7UEhYX0NPTVBPTkVOVH09XCIke2NpZH1cIl0gWyR7UEhYX0NPTVBPTkVOVH1dYDtcbiAgICAgICAgdGhpcy5maWx0ZXJXaXRoaW5TYW1lTGl2ZVZpZXcodGhpcy5hbGwobm9kZSwgc2VsZWN0b3IpLCBub2RlKS5tYXAoKGVsKSA9PiBwYXJzZUludChlbC5nZXRBdHRyaWJ1dGUoUEhYX0NPTVBPTkVOVCkpKS5mb3JFYWNoKChjaGlsZENJRCkgPT4gYWNjLmRlbGV0ZShjaGlsZENJRCkpO1xuICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgfSwgaW5pdGlhbCk7XG4gICAgfSxcbiAgICBmaWx0ZXJXaXRoaW5TYW1lTGl2ZVZpZXcobm9kZXMsIHBhcmVudCkge1xuICAgICAgaWYgKHBhcmVudC5xdWVyeVNlbGVjdG9yKFBIWF9WSUVXX1NFTEVDVE9SKSkge1xuICAgICAgICByZXR1cm4gbm9kZXMuZmlsdGVyKChlbCkgPT4gdGhpcy53aXRoaW5TYW1lTGl2ZVZpZXcoZWwsIHBhcmVudCkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG5vZGVzO1xuICAgICAgfVxuICAgIH0sXG4gICAgd2l0aGluU2FtZUxpdmVWaWV3KG5vZGUsIHBhcmVudCkge1xuICAgICAgd2hpbGUgKG5vZGUgPSBub2RlLnBhcmVudE5vZGUpIHtcbiAgICAgICAgaWYgKG5vZGUuaXNTYW1lTm9kZShwYXJlbnQpKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vZGUuZ2V0QXR0cmlidXRlKFBIWF9TRVNTSU9OKSAhPT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgcHJpdmF0ZShlbCwga2V5KSB7XG4gICAgICByZXR1cm4gZWxbUEhYX1BSSVZBVEVdICYmIGVsW1BIWF9QUklWQVRFXVtrZXldO1xuICAgIH0sXG4gICAgZGVsZXRlUHJpdmF0ZShlbCwga2V5KSB7XG4gICAgICBlbFtQSFhfUFJJVkFURV0gJiYgZGVsZXRlIGVsW1BIWF9QUklWQVRFXVtrZXldO1xuICAgIH0sXG4gICAgcHV0UHJpdmF0ZShlbCwga2V5LCB2YWx1ZSkge1xuICAgICAgaWYgKCFlbFtQSFhfUFJJVkFURV0pIHtcbiAgICAgICAgZWxbUEhYX1BSSVZBVEVdID0ge307XG4gICAgICB9XG4gICAgICBlbFtQSFhfUFJJVkFURV1ba2V5XSA9IHZhbHVlO1xuICAgIH0sXG4gICAgdXBkYXRlUHJpdmF0ZShlbCwga2V5LCBkZWZhdWx0VmFsLCB1cGRhdGVGdW5jKSB7XG4gICAgICBsZXQgZXhpc3RpbmcgPSB0aGlzLnByaXZhdGUoZWwsIGtleSk7XG4gICAgICBpZiAoZXhpc3RpbmcgPT09IHZvaWQgMCkge1xuICAgICAgICB0aGlzLnB1dFByaXZhdGUoZWwsIGtleSwgdXBkYXRlRnVuYyhkZWZhdWx0VmFsKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnB1dFByaXZhdGUoZWwsIGtleSwgdXBkYXRlRnVuYyhleGlzdGluZykpO1xuICAgICAgfVxuICAgIH0sXG4gICAgY29weVByaXZhdGVzKHRhcmdldCwgc291cmNlKSB7XG4gICAgICBpZiAoc291cmNlW1BIWF9QUklWQVRFXSkge1xuICAgICAgICB0YXJnZXRbUEhYX1BSSVZBVEVdID0gc291cmNlW1BIWF9QUklWQVRFXTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHB1dFRpdGxlKHN0cikge1xuICAgICAgbGV0IHRpdGxlRWwgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwidGl0bGVcIik7XG4gICAgICBsZXQgeyBwcmVmaXgsIHN1ZmZpeCB9ID0gdGl0bGVFbC5kYXRhc2V0O1xuICAgICAgZG9jdW1lbnQudGl0bGUgPSBgJHtwcmVmaXggfHwgXCJcIn0ke3N0cn0ke3N1ZmZpeCB8fCBcIlwifWA7XG4gICAgfSxcbiAgICBkZWJvdW5jZShlbCwgZXZlbnQsIHBoeERlYm91bmNlLCBkZWZhdWx0RGVib3VuY2UsIHBoeFRocm90dGxlLCBkZWZhdWx0VGhyb3R0bGUsIGNhbGxiYWNrKSB7XG4gICAgICBsZXQgZGVib3VuY2UgPSBlbC5nZXRBdHRyaWJ1dGUocGh4RGVib3VuY2UpO1xuICAgICAgbGV0IHRocm90dGxlID0gZWwuZ2V0QXR0cmlidXRlKHBoeFRocm90dGxlKTtcbiAgICAgIGlmIChkZWJvdW5jZSA9PT0gXCJcIikge1xuICAgICAgICBkZWJvdW5jZSA9IGRlZmF1bHREZWJvdW5jZTtcbiAgICAgIH1cbiAgICAgIGlmICh0aHJvdHRsZSA9PT0gXCJcIikge1xuICAgICAgICB0aHJvdHRsZSA9IGRlZmF1bHRUaHJvdHRsZTtcbiAgICAgIH1cbiAgICAgIGxldCB2YWx1ZSA9IGRlYm91bmNlIHx8IHRocm90dGxlO1xuICAgICAgc3dpdGNoICh2YWx1ZSkge1xuICAgICAgICBjYXNlIG51bGw6XG4gICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKCk7XG4gICAgICAgIGNhc2UgXCJibHVyXCI6XG4gICAgICAgICAgaWYgKHRoaXMub25jZShlbCwgXCJkZWJvdW5jZS1ibHVyXCIpKSB7XG4gICAgICAgICAgICBlbC5hZGRFdmVudExpc3RlbmVyKFwiYmx1clwiLCAoKSA9PiBjYWxsYmFjaygpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGxldCB0aW1lb3V0ID0gcGFyc2VJbnQodmFsdWUpO1xuICAgICAgICAgIGxldCB0cmlnZ2VyID0gKCkgPT4gdGhyb3R0bGUgPyB0aGlzLmRlbGV0ZVByaXZhdGUoZWwsIFRIUk9UVExFRCkgOiBjYWxsYmFjaygpO1xuICAgICAgICAgIGxldCBjdXJyZW50Q3ljbGUgPSB0aGlzLmluY0N5Y2xlKGVsLCBERUJPVU5DRV9UUklHR0VSLCB0cmlnZ2VyKTtcbiAgICAgICAgICBpZiAoaXNOYU4odGltZW91dCkpIHtcbiAgICAgICAgICAgIHJldHVybiBsb2dFcnJvcihgaW52YWxpZCB0aHJvdHRsZS9kZWJvdW5jZSB2YWx1ZTogJHt2YWx1ZX1gKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHRocm90dGxlKSB7XG4gICAgICAgICAgICBsZXQgbmV3S2V5RG93biA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKGV2ZW50LnR5cGUgPT09IFwia2V5ZG93blwiKSB7XG4gICAgICAgICAgICAgIGxldCBwcmV2S2V5ID0gdGhpcy5wcml2YXRlKGVsLCBERUJPVU5DRV9QUkVWX0tFWSk7XG4gICAgICAgICAgICAgIHRoaXMucHV0UHJpdmF0ZShlbCwgREVCT1VOQ0VfUFJFVl9LRVksIGV2ZW50LmtleSk7XG4gICAgICAgICAgICAgIG5ld0tleURvd24gPSBwcmV2S2V5ICE9PSBldmVudC5rZXk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIW5ld0tleURvd24gJiYgdGhpcy5wcml2YXRlKGVsLCBUSFJPVFRMRUQpKSB7XG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICAgIHRoaXMucHV0UHJpdmF0ZShlbCwgVEhST1RUTEVELCB0cnVlKTtcbiAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB0aGlzLnRyaWdnZXJDeWNsZShlbCwgREVCT1VOQ0VfVFJJR0dFUiksIHRpbWVvdXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHRoaXMudHJpZ2dlckN5Y2xlKGVsLCBERUJPVU5DRV9UUklHR0VSLCBjdXJyZW50Q3ljbGUpLCB0aW1lb3V0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbGV0IGZvcm0gPSBlbC5mb3JtO1xuICAgICAgICAgIGlmIChmb3JtICYmIHRoaXMub25jZShmb3JtLCBcImJpbmQtZGVib3VuY2VcIikpIHtcbiAgICAgICAgICAgIGZvcm0uYWRkRXZlbnRMaXN0ZW5lcihcInN1Ym1pdFwiLCAoKSA9PiB7XG4gICAgICAgICAgICAgIEFycmF5LmZyb20obmV3IEZvcm1EYXRhKGZvcm0pLmVudHJpZXMoKSwgKFtuYW1lXSkgPT4ge1xuICAgICAgICAgICAgICAgIGxldCBpbnB1dCA9IGZvcm0ucXVlcnlTZWxlY3RvcihgW25hbWU9XCIke25hbWV9XCJdYCk7XG4gICAgICAgICAgICAgICAgdGhpcy5pbmNDeWNsZShpbnB1dCwgREVCT1VOQ0VfVFJJR0dFUik7XG4gICAgICAgICAgICAgICAgdGhpcy5kZWxldGVQcml2YXRlKGlucHV0LCBUSFJPVFRMRUQpO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodGhpcy5vbmNlKGVsLCBcImJpbmQtZGVib3VuY2VcIikpIHtcbiAgICAgICAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoXCJibHVyXCIsICgpID0+IHRoaXMudHJpZ2dlckN5Y2xlKGVsLCBERUJPVU5DRV9UUklHR0VSKSk7XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgdHJpZ2dlckN5Y2xlKGVsLCBrZXksIGN1cnJlbnRDeWNsZSkge1xuICAgICAgbGV0IFtjeWNsZSwgdHJpZ2dlcl0gPSB0aGlzLnByaXZhdGUoZWwsIGtleSk7XG4gICAgICBpZiAoIWN1cnJlbnRDeWNsZSkge1xuICAgICAgICBjdXJyZW50Q3ljbGUgPSBjeWNsZTtcbiAgICAgIH1cbiAgICAgIGlmIChjdXJyZW50Q3ljbGUgPT09IGN5Y2xlKSB7XG4gICAgICAgIHRoaXMuaW5jQ3ljbGUoZWwsIGtleSk7XG4gICAgICAgIHRyaWdnZXIoKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIG9uY2UoZWwsIGtleSkge1xuICAgICAgaWYgKHRoaXMucHJpdmF0ZShlbCwga2V5KSA9PT0gdHJ1ZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICB0aGlzLnB1dFByaXZhdGUoZWwsIGtleSwgdHJ1ZSk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxuICAgIGluY0N5Y2xlKGVsLCBrZXksIHRyaWdnZXIgPSBmdW5jdGlvbigpIHtcbiAgICB9KSB7XG4gICAgICBsZXQgW2N1cnJlbnRDeWNsZV0gPSB0aGlzLnByaXZhdGUoZWwsIGtleSkgfHwgWzAsIHRyaWdnZXJdO1xuICAgICAgY3VycmVudEN5Y2xlKys7XG4gICAgICB0aGlzLnB1dFByaXZhdGUoZWwsIGtleSwgW2N1cnJlbnRDeWNsZSwgdHJpZ2dlcl0pO1xuICAgICAgcmV0dXJuIGN1cnJlbnRDeWNsZTtcbiAgICB9LFxuICAgIGRpc2NhcmRFcnJvcihjb250YWluZXIsIGVsLCBwaHhGZWVkYmFja0Zvcikge1xuICAgICAgbGV0IGZpZWxkID0gZWwuZ2V0QXR0cmlidXRlICYmIGVsLmdldEF0dHJpYnV0ZShwaHhGZWVkYmFja0Zvcik7XG4gICAgICBsZXQgaW5wdXQgPSBmaWVsZCAmJiBjb250YWluZXIucXVlcnlTZWxlY3RvcihgW2lkPVwiJHtmaWVsZH1cIl0sIFtuYW1lPVwiJHtmaWVsZH1cIl1gKTtcbiAgICAgIGlmICghaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKCEodGhpcy5wcml2YXRlKGlucHV0LCBQSFhfSEFTX0ZPQ1VTRUQpIHx8IHRoaXMucHJpdmF0ZShpbnB1dC5mb3JtLCBQSFhfSEFTX1NVQk1JVFRFRCkpKSB7XG4gICAgICAgIGVsLmNsYXNzTGlzdC5hZGQoUEhYX05PX0ZFRURCQUNLX0NMQVNTKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHNob3dFcnJvcihpbnB1dEVsLCBwaHhGZWVkYmFja0Zvcikge1xuICAgICAgaWYgKGlucHV0RWwuaWQgfHwgaW5wdXRFbC5uYW1lKSB7XG4gICAgICAgIHRoaXMuYWxsKGlucHV0RWwuZm9ybSwgYFske3BoeEZlZWRiYWNrRm9yfT1cIiR7aW5wdXRFbC5pZH1cIl0sIFske3BoeEZlZWRiYWNrRm9yfT1cIiR7aW5wdXRFbC5uYW1lfVwiXWAsIChlbCkgPT4ge1xuICAgICAgICAgIHRoaXMucmVtb3ZlQ2xhc3MoZWwsIFBIWF9OT19GRUVEQkFDS19DTEFTUyk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0sXG4gICAgaXNQaHhDaGlsZChub2RlKSB7XG4gICAgICByZXR1cm4gbm9kZS5nZXRBdHRyaWJ1dGUgJiYgbm9kZS5nZXRBdHRyaWJ1dGUoUEhYX1BBUkVOVF9JRCk7XG4gICAgfSxcbiAgICBmaXJzdFBoeENoaWxkKGVsKSB7XG4gICAgICByZXR1cm4gdGhpcy5pc1BoeENoaWxkKGVsKSA/IGVsIDogdGhpcy5hbGwoZWwsIGBbJHtQSFhfUEFSRU5UX0lEfV1gKVswXTtcbiAgICB9LFxuICAgIGRpc3BhdGNoRXZlbnQodGFyZ2V0LCBldmVudFN0cmluZywgZGV0YWlsID0ge30pIHtcbiAgICAgIGxldCBldmVudCA9IG5ldyBDdXN0b21FdmVudChldmVudFN0cmluZywgeyBidWJibGVzOiB0cnVlLCBjYW5jZWxhYmxlOiB0cnVlLCBkZXRhaWwgfSk7XG4gICAgICB0YXJnZXQuZGlzcGF0Y2hFdmVudChldmVudCk7XG4gICAgfSxcbiAgICBjbG9uZU5vZGUobm9kZSwgaHRtbCkge1xuICAgICAgaWYgKHR5cGVvZiBodG1sID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIHJldHVybiBub2RlLmNsb25lTm9kZSh0cnVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxldCBjbG9uZWQgPSBub2RlLmNsb25lTm9kZShmYWxzZSk7XG4gICAgICAgIGNsb25lZC5pbm5lckhUTUwgPSBodG1sO1xuICAgICAgICByZXR1cm4gY2xvbmVkO1xuICAgICAgfVxuICAgIH0sXG4gICAgbWVyZ2VBdHRycyh0YXJnZXQsIHNvdXJjZSwgb3B0cyA9IHt9KSB7XG4gICAgICBsZXQgZXhjbHVkZSA9IG9wdHMuZXhjbHVkZSB8fCBbXTtcbiAgICAgIGxldCBpc0lnbm9yZWQgPSBvcHRzLmlzSWdub3JlZDtcbiAgICAgIGxldCBzb3VyY2VBdHRycyA9IHNvdXJjZS5hdHRyaWJ1dGVzO1xuICAgICAgZm9yIChsZXQgaSA9IHNvdXJjZUF0dHJzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIGxldCBuYW1lID0gc291cmNlQXR0cnNbaV0ubmFtZTtcbiAgICAgICAgaWYgKGV4Y2x1ZGUuaW5kZXhPZihuYW1lKSA8IDApIHtcbiAgICAgICAgICB0YXJnZXQuc2V0QXR0cmlidXRlKG5hbWUsIHNvdXJjZS5nZXRBdHRyaWJ1dGUobmFtZSkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBsZXQgdGFyZ2V0QXR0cnMgPSB0YXJnZXQuYXR0cmlidXRlcztcbiAgICAgIGZvciAobGV0IGkgPSB0YXJnZXRBdHRycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBsZXQgbmFtZSA9IHRhcmdldEF0dHJzW2ldLm5hbWU7XG4gICAgICAgIGlmIChpc0lnbm9yZWQpIHtcbiAgICAgICAgICBpZiAobmFtZS5zdGFydHNXaXRoKFwiZGF0YS1cIikgJiYgIXNvdXJjZS5oYXNBdHRyaWJ1dGUobmFtZSkpIHtcbiAgICAgICAgICAgIHRhcmdldC5yZW1vdmVBdHRyaWJ1dGUobmFtZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICghc291cmNlLmhhc0F0dHJpYnV0ZShuYW1lKSkge1xuICAgICAgICAgICAgdGFyZ2V0LnJlbW92ZUF0dHJpYnV0ZShuYW1lKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIG1lcmdlRm9jdXNlZElucHV0KHRhcmdldCwgc291cmNlKSB7XG4gICAgICBpZiAoISh0YXJnZXQgaW5zdGFuY2VvZiBIVE1MU2VsZWN0RWxlbWVudCkpIHtcbiAgICAgICAgRE9NLm1lcmdlQXR0cnModGFyZ2V0LCBzb3VyY2UsIHsgZXhjZXB0OiBbXCJ2YWx1ZVwiXSB9KTtcbiAgICAgIH1cbiAgICAgIGlmIChzb3VyY2UucmVhZE9ubHkpIHtcbiAgICAgICAgdGFyZ2V0LnNldEF0dHJpYnV0ZShcInJlYWRvbmx5XCIsIHRydWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGFyZ2V0LnJlbW92ZUF0dHJpYnV0ZShcInJlYWRvbmx5XCIpO1xuICAgICAgfVxuICAgIH0sXG4gICAgaGFzU2VsZWN0aW9uUmFuZ2UoZWwpIHtcbiAgICAgIHJldHVybiBlbC5zZXRTZWxlY3Rpb25SYW5nZSAmJiAoZWwudHlwZSA9PT0gXCJ0ZXh0XCIgfHwgZWwudHlwZSA9PT0gXCJ0ZXh0YXJlYVwiKTtcbiAgICB9LFxuICAgIHJlc3RvcmVGb2N1cyhmb2N1c2VkLCBzZWxlY3Rpb25TdGFydCwgc2VsZWN0aW9uRW5kKSB7XG4gICAgICBpZiAoIURPTS5pc1RleHR1YWxJbnB1dChmb2N1c2VkKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBsZXQgd2FzRm9jdXNlZCA9IGZvY3VzZWQubWF0Y2hlcyhcIjpmb2N1c1wiKTtcbiAgICAgIGlmIChmb2N1c2VkLnJlYWRPbmx5KSB7XG4gICAgICAgIGZvY3VzZWQuYmx1cigpO1xuICAgICAgfVxuICAgICAgaWYgKCF3YXNGb2N1c2VkKSB7XG4gICAgICAgIGZvY3VzZWQuZm9jdXMoKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmhhc1NlbGVjdGlvblJhbmdlKGZvY3VzZWQpKSB7XG4gICAgICAgIGZvY3VzZWQuc2V0U2VsZWN0aW9uUmFuZ2Uoc2VsZWN0aW9uU3RhcnQsIHNlbGVjdGlvbkVuZCk7XG4gICAgICB9XG4gICAgfSxcbiAgICBpc0Zvcm1JbnB1dChlbCkge1xuICAgICAgcmV0dXJuIC9eKD86aW5wdXR8c2VsZWN0fHRleHRhcmVhKSQvaS50ZXN0KGVsLnRhZ05hbWUpICYmIGVsLnR5cGUgIT09IFwiYnV0dG9uXCI7XG4gICAgfSxcbiAgICBzeW5jQXR0cnNUb1Byb3BzKGVsKSB7XG4gICAgICBpZiAoZWwgaW5zdGFuY2VvZiBIVE1MSW5wdXRFbGVtZW50ICYmIENIRUNLQUJMRV9JTlBVVFMuaW5kZXhPZihlbC50eXBlLnRvTG9jYWxlTG93ZXJDYXNlKCkpID49IDApIHtcbiAgICAgICAgZWwuY2hlY2tlZCA9IGVsLmdldEF0dHJpYnV0ZShcImNoZWNrZWRcIikgIT09IG51bGw7XG4gICAgICB9XG4gICAgfSxcbiAgICBpc1RleHR1YWxJbnB1dChlbCkge1xuICAgICAgcmV0dXJuIEZPQ1VTQUJMRV9JTlBVVFMuaW5kZXhPZihlbC50eXBlKSA+PSAwO1xuICAgIH0sXG4gICAgaXNOb3dUcmlnZ2VyRm9ybUV4dGVybmFsKGVsLCBwaHhUcmlnZ2VyRXh0ZXJuYWwpIHtcbiAgICAgIHJldHVybiBlbC5nZXRBdHRyaWJ1dGUgJiYgZWwuZ2V0QXR0cmlidXRlKHBoeFRyaWdnZXJFeHRlcm5hbCkgIT09IG51bGw7XG4gICAgfSxcbiAgICBzeW5jUGVuZGluZ1JlZihmcm9tRWwsIHRvRWwsIGRpc2FibGVXaXRoKSB7XG4gICAgICBsZXQgcmVmID0gZnJvbUVsLmdldEF0dHJpYnV0ZShQSFhfUkVGKTtcbiAgICAgIGlmIChyZWYgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBpZiAoRE9NLmlzRm9ybUlucHV0KGZyb21FbCkgfHwgZnJvbUVsLmdldEF0dHJpYnV0ZShkaXNhYmxlV2l0aCkgIT09IG51bGwpIHtcbiAgICAgICAgaWYgKERPTS5pc1VwbG9hZElucHV0KGZyb21FbCkpIHtcbiAgICAgICAgICBET00ubWVyZ2VBdHRycyhmcm9tRWwsIHRvRWwsIHsgaXNJZ25vcmVkOiB0cnVlIH0pO1xuICAgICAgICB9XG4gICAgICAgIERPTS5wdXRQcml2YXRlKGZyb21FbCwgUEhYX1JFRiwgdG9FbCk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIFBIWF9FVkVOVF9DTEFTU0VTLmZvckVhY2goKGNsYXNzTmFtZSkgPT4ge1xuICAgICAgICAgIGZyb21FbC5jbGFzc0xpc3QuY29udGFpbnMoY2xhc3NOYW1lKSAmJiB0b0VsLmNsYXNzTGlzdC5hZGQoY2xhc3NOYW1lKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRvRWwuc2V0QXR0cmlidXRlKFBIWF9SRUYsIHJlZik7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH0sXG4gICAgY2xlYW5DaGlsZE5vZGVzKGNvbnRhaW5lciwgcGh4VXBkYXRlKSB7XG4gICAgICBpZiAoRE9NLmlzUGh4VXBkYXRlKGNvbnRhaW5lciwgcGh4VXBkYXRlLCBbXCJhcHBlbmRcIiwgXCJwcmVwZW5kXCJdKSkge1xuICAgICAgICBsZXQgdG9SZW1vdmUgPSBbXTtcbiAgICAgICAgY29udGFpbmVyLmNoaWxkTm9kZXMuZm9yRWFjaCgoY2hpbGROb2RlKSA9PiB7XG4gICAgICAgICAgaWYgKCFjaGlsZE5vZGUuaWQpIHtcbiAgICAgICAgICAgIGxldCBpc0VtcHR5VGV4dE5vZGUgPSBjaGlsZE5vZGUubm9kZVR5cGUgPT09IE5vZGUuVEVYVF9OT0RFICYmIGNoaWxkTm9kZS5ub2RlVmFsdWUudHJpbSgpID09PSBcIlwiO1xuICAgICAgICAgICAgaWYgKCFpc0VtcHR5VGV4dE5vZGUpIHtcbiAgICAgICAgICAgICAgbG9nRXJyb3IoYG9ubHkgSFRNTCBlbGVtZW50IHRhZ3Mgd2l0aCBhbiBpZCBhcmUgYWxsb3dlZCBpbnNpZGUgY29udGFpbmVycyB3aXRoIHBoeC11cGRhdGUuXG5cbnJlbW92aW5nIGlsbGVnYWwgbm9kZTogXCIkeyhjaGlsZE5vZGUub3V0ZXJIVE1MIHx8IGNoaWxkTm9kZS5ub2RlVmFsdWUpLnRyaW0oKX1cIlxuXG5gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRvUmVtb3ZlLnB1c2goY2hpbGROb2RlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0b1JlbW92ZS5mb3JFYWNoKChjaGlsZE5vZGUpID0+IGNoaWxkTm9kZS5yZW1vdmUoKSk7XG4gICAgICB9XG4gICAgfSxcbiAgICByZXBsYWNlUm9vdENvbnRhaW5lcihjb250YWluZXIsIHRhZ05hbWUsIGF0dHJzKSB7XG4gICAgICBsZXQgcmV0YWluZWRBdHRycyA9IG5ldyBTZXQoW1wiaWRcIiwgUEhYX1NFU1NJT04sIFBIWF9TVEFUSUMsIFBIWF9NQUlOLCBQSFhfUk9PVF9JRF0pO1xuICAgICAgaWYgKGNvbnRhaW5lci50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09IHRhZ05hbWUudG9Mb3dlckNhc2UoKSkge1xuICAgICAgICBBcnJheS5mcm9tKGNvbnRhaW5lci5hdHRyaWJ1dGVzKS5maWx0ZXIoKGF0dHIpID0+ICFyZXRhaW5lZEF0dHJzLmhhcyhhdHRyLm5hbWUudG9Mb3dlckNhc2UoKSkpLmZvckVhY2goKGF0dHIpID0+IGNvbnRhaW5lci5yZW1vdmVBdHRyaWJ1dGUoYXR0ci5uYW1lKSk7XG4gICAgICAgIE9iamVjdC5rZXlzKGF0dHJzKS5maWx0ZXIoKG5hbWUpID0+ICFyZXRhaW5lZEF0dHJzLmhhcyhuYW1lLnRvTG93ZXJDYXNlKCkpKS5mb3JFYWNoKChhdHRyKSA9PiBjb250YWluZXIuc2V0QXR0cmlidXRlKGF0dHIsIGF0dHJzW2F0dHJdKSk7XG4gICAgICAgIHJldHVybiBjb250YWluZXI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsZXQgbmV3Q29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWdOYW1lKTtcbiAgICAgICAgT2JqZWN0LmtleXMoYXR0cnMpLmZvckVhY2goKGF0dHIpID0+IG5ld0NvbnRhaW5lci5zZXRBdHRyaWJ1dGUoYXR0ciwgYXR0cnNbYXR0cl0pKTtcbiAgICAgICAgcmV0YWluZWRBdHRycy5mb3JFYWNoKChhdHRyKSA9PiBuZXdDb250YWluZXIuc2V0QXR0cmlidXRlKGF0dHIsIGNvbnRhaW5lci5nZXRBdHRyaWJ1dGUoYXR0cikpKTtcbiAgICAgICAgbmV3Q29udGFpbmVyLmlubmVySFRNTCA9IGNvbnRhaW5lci5pbm5lckhUTUw7XG4gICAgICAgIGNvbnRhaW5lci5yZXBsYWNlV2l0aChuZXdDb250YWluZXIpO1xuICAgICAgICByZXR1cm4gbmV3Q29udGFpbmVyO1xuICAgICAgfVxuICAgIH0sXG4gICAgZ2V0U3RpY2t5KGVsLCBuYW1lLCBkZWZhdWx0VmFsKSB7XG4gICAgICBsZXQgb3AgPSAoRE9NLnByaXZhdGUoZWwsIFwic3RpY2t5XCIpIHx8IFtdKS5maW5kKChbZXhpc3RpbmdOYW1lXSkgPT4gbmFtZSA9PT0gZXhpc3RpbmdOYW1lKTtcbiAgICAgIGlmIChvcCkge1xuICAgICAgICBsZXQgW19uYW1lLCBfb3AsIHN0YXNoZWRSZXN1bHRdID0gb3A7XG4gICAgICAgIHJldHVybiBzdGFzaGVkUmVzdWx0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBkZWZhdWx0VmFsID09PSBcImZ1bmN0aW9uXCIgPyBkZWZhdWx0VmFsKCkgOiBkZWZhdWx0VmFsO1xuICAgICAgfVxuICAgIH0sXG4gICAgZGVsZXRlU3RpY2t5KGVsLCBuYW1lKSB7XG4gICAgICB0aGlzLnVwZGF0ZVByaXZhdGUoZWwsIFwic3RpY2t5XCIsIFtdLCAob3BzKSA9PiB7XG4gICAgICAgIHJldHVybiBvcHMuZmlsdGVyKChbZXhpc3RpbmdOYW1lLCBfXSkgPT4gZXhpc3RpbmdOYW1lICE9PSBuYW1lKTtcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgcHV0U3RpY2t5KGVsLCBuYW1lLCBvcCkge1xuICAgICAgbGV0IHN0YXNoZWRSZXN1bHQgPSBvcChlbCk7XG4gICAgICB0aGlzLnVwZGF0ZVByaXZhdGUoZWwsIFwic3RpY2t5XCIsIFtdLCAob3BzKSA9PiB7XG4gICAgICAgIGxldCBleGlzdGluZ0luZGV4ID0gb3BzLmZpbmRJbmRleCgoW2V4aXN0aW5nTmFtZV0pID0+IG5hbWUgPT09IGV4aXN0aW5nTmFtZSk7XG4gICAgICAgIGlmIChleGlzdGluZ0luZGV4ID49IDApIHtcbiAgICAgICAgICBvcHNbZXhpc3RpbmdJbmRleF0gPSBbbmFtZSwgb3AsIHN0YXNoZWRSZXN1bHRdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG9wcy5wdXNoKFtuYW1lLCBvcCwgc3Rhc2hlZFJlc3VsdF0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvcHM7XG4gICAgICB9KTtcbiAgICB9LFxuICAgIGFwcGx5U3RpY2t5T3BlcmF0aW9ucyhlbCkge1xuICAgICAgbGV0IG9wcyA9IERPTS5wcml2YXRlKGVsLCBcInN0aWNreVwiKTtcbiAgICAgIGlmICghb3BzKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIG9wcy5mb3JFYWNoKChbbmFtZSwgb3AsIF9zdGFzaGVkXSkgPT4gdGhpcy5wdXRTdGlja3koZWwsIG5hbWUsIG9wKSk7XG4gICAgfVxuICB9O1xuICB2YXIgZG9tX2RlZmF1bHQgPSBET007XG5cbiAgLy8ganMvcGhvZW5peF9saXZlX3ZpZXcvdXBsb2FkX2VudHJ5LmpzXG4gIHZhciBVcGxvYWRFbnRyeSA9IGNsYXNzIHtcbiAgICBzdGF0aWMgaXNBY3RpdmUoZmlsZUVsLCBmaWxlKSB7XG4gICAgICBsZXQgaXNOZXcgPSBmaWxlLl9waHhSZWYgPT09IHZvaWQgMDtcbiAgICAgIGxldCBhY3RpdmVSZWZzID0gZmlsZUVsLmdldEF0dHJpYnV0ZShQSFhfQUNUSVZFX0VOVFJZX1JFRlMpLnNwbGl0KFwiLFwiKTtcbiAgICAgIGxldCBpc0FjdGl2ZSA9IGFjdGl2ZVJlZnMuaW5kZXhPZihMaXZlVXBsb2FkZXIuZ2VuRmlsZVJlZihmaWxlKSkgPj0gMDtcbiAgICAgIHJldHVybiBmaWxlLnNpemUgPiAwICYmIChpc05ldyB8fCBpc0FjdGl2ZSk7XG4gICAgfVxuICAgIHN0YXRpYyBpc1ByZWZsaWdodGVkKGZpbGVFbCwgZmlsZSkge1xuICAgICAgbGV0IHByZWZsaWdodGVkUmVmcyA9IGZpbGVFbC5nZXRBdHRyaWJ1dGUoUEhYX1BSRUZMSUdIVEVEX1JFRlMpLnNwbGl0KFwiLFwiKTtcbiAgICAgIGxldCBpc1ByZWZsaWdodGVkID0gcHJlZmxpZ2h0ZWRSZWZzLmluZGV4T2YoTGl2ZVVwbG9hZGVyLmdlbkZpbGVSZWYoZmlsZSkpID49IDA7XG4gICAgICByZXR1cm4gaXNQcmVmbGlnaHRlZCAmJiB0aGlzLmlzQWN0aXZlKGZpbGVFbCwgZmlsZSk7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKGZpbGVFbCwgZmlsZSwgdmlldykge1xuICAgICAgdGhpcy5yZWYgPSBMaXZlVXBsb2FkZXIuZ2VuRmlsZVJlZihmaWxlKTtcbiAgICAgIHRoaXMuZmlsZUVsID0gZmlsZUVsO1xuICAgICAgdGhpcy5maWxlID0gZmlsZTtcbiAgICAgIHRoaXMudmlldyA9IHZpZXc7XG4gICAgICB0aGlzLm1ldGEgPSBudWxsO1xuICAgICAgdGhpcy5faXNDYW5jZWxsZWQgPSBmYWxzZTtcbiAgICAgIHRoaXMuX2lzRG9uZSA9IGZhbHNlO1xuICAgICAgdGhpcy5fcHJvZ3Jlc3MgPSAwO1xuICAgICAgdGhpcy5fbGFzdFByb2dyZXNzU2VudCA9IC0xO1xuICAgICAgdGhpcy5fb25Eb25lID0gZnVuY3Rpb24oKSB7XG4gICAgICB9O1xuICAgICAgdGhpcy5fb25FbFVwZGF0ZWQgPSB0aGlzLm9uRWxVcGRhdGVkLmJpbmQodGhpcyk7XG4gICAgICB0aGlzLmZpbGVFbC5hZGRFdmVudExpc3RlbmVyKFBIWF9MSVZFX0ZJTEVfVVBEQVRFRCwgdGhpcy5fb25FbFVwZGF0ZWQpO1xuICAgIH1cbiAgICBtZXRhZGF0YSgpIHtcbiAgICAgIHJldHVybiB0aGlzLm1ldGE7XG4gICAgfVxuICAgIHByb2dyZXNzKHByb2dyZXNzKSB7XG4gICAgICB0aGlzLl9wcm9ncmVzcyA9IE1hdGguZmxvb3IocHJvZ3Jlc3MpO1xuICAgICAgaWYgKHRoaXMuX3Byb2dyZXNzID4gdGhpcy5fbGFzdFByb2dyZXNzU2VudCkge1xuICAgICAgICBpZiAodGhpcy5fcHJvZ3Jlc3MgPj0gMTAwKSB7XG4gICAgICAgICAgdGhpcy5fcHJvZ3Jlc3MgPSAxMDA7XG4gICAgICAgICAgdGhpcy5fbGFzdFByb2dyZXNzU2VudCA9IDEwMDtcbiAgICAgICAgICB0aGlzLl9pc0RvbmUgPSB0cnVlO1xuICAgICAgICAgIHRoaXMudmlldy5wdXNoRmlsZVByb2dyZXNzKHRoaXMuZmlsZUVsLCB0aGlzLnJlZiwgMTAwLCAoKSA9PiB7XG4gICAgICAgICAgICBMaXZlVXBsb2FkZXIudW50cmFja0ZpbGUodGhpcy5maWxlRWwsIHRoaXMuZmlsZSk7XG4gICAgICAgICAgICB0aGlzLl9vbkRvbmUoKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLl9sYXN0UHJvZ3Jlc3NTZW50ID0gdGhpcy5fcHJvZ3Jlc3M7XG4gICAgICAgICAgdGhpcy52aWV3LnB1c2hGaWxlUHJvZ3Jlc3ModGhpcy5maWxlRWwsIHRoaXMucmVmLCB0aGlzLl9wcm9ncmVzcyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgY2FuY2VsKCkge1xuICAgICAgdGhpcy5faXNDYW5jZWxsZWQgPSB0cnVlO1xuICAgICAgdGhpcy5faXNEb25lID0gdHJ1ZTtcbiAgICAgIHRoaXMuX29uRG9uZSgpO1xuICAgIH1cbiAgICBpc0RvbmUoKSB7XG4gICAgICByZXR1cm4gdGhpcy5faXNEb25lO1xuICAgIH1cbiAgICBlcnJvcihyZWFzb24gPSBcImZhaWxlZFwiKSB7XG4gICAgICB0aGlzLnZpZXcucHVzaEZpbGVQcm9ncmVzcyh0aGlzLmZpbGVFbCwgdGhpcy5yZWYsIHsgZXJyb3I6IHJlYXNvbiB9KTtcbiAgICAgIExpdmVVcGxvYWRlci5jbGVhckZpbGVzKHRoaXMuZmlsZUVsKTtcbiAgICB9XG4gICAgb25Eb25lKGNhbGxiYWNrKSB7XG4gICAgICB0aGlzLl9vbkRvbmUgPSAoKSA9PiB7XG4gICAgICAgIHRoaXMuZmlsZUVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoUEhYX0xJVkVfRklMRV9VUERBVEVELCB0aGlzLl9vbkVsVXBkYXRlZCk7XG4gICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICB9O1xuICAgIH1cbiAgICBvbkVsVXBkYXRlZCgpIHtcbiAgICAgIGxldCBhY3RpdmVSZWZzID0gdGhpcy5maWxlRWwuZ2V0QXR0cmlidXRlKFBIWF9BQ1RJVkVfRU5UUllfUkVGUykuc3BsaXQoXCIsXCIpO1xuICAgICAgaWYgKGFjdGl2ZVJlZnMuaW5kZXhPZih0aGlzLnJlZikgPT09IC0xKSB7XG4gICAgICAgIHRoaXMuY2FuY2VsKCk7XG4gICAgICB9XG4gICAgfVxuICAgIHRvUHJlZmxpZ2h0UGF5bG9hZCgpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGxhc3RfbW9kaWZpZWQ6IHRoaXMuZmlsZS5sYXN0TW9kaWZpZWQsXG4gICAgICAgIG5hbWU6IHRoaXMuZmlsZS5uYW1lLFxuICAgICAgICBzaXplOiB0aGlzLmZpbGUuc2l6ZSxcbiAgICAgICAgdHlwZTogdGhpcy5maWxlLnR5cGUsXG4gICAgICAgIHJlZjogdGhpcy5yZWZcbiAgICAgIH07XG4gICAgfVxuICAgIHVwbG9hZGVyKHVwbG9hZGVycykge1xuICAgICAgaWYgKHRoaXMubWV0YS51cGxvYWRlcikge1xuICAgICAgICBsZXQgY2FsbGJhY2sgPSB1cGxvYWRlcnNbdGhpcy5tZXRhLnVwbG9hZGVyXSB8fCBsb2dFcnJvcihgbm8gdXBsb2FkZXIgY29uZmlndXJlZCBmb3IgJHt0aGlzLm1ldGEudXBsb2FkZXJ9YCk7XG4gICAgICAgIHJldHVybiB7IG5hbWU6IHRoaXMubWV0YS51cGxvYWRlciwgY2FsbGJhY2sgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB7IG5hbWU6IFwiY2hhbm5lbFwiLCBjYWxsYmFjazogY2hhbm5lbFVwbG9hZGVyIH07XG4gICAgICB9XG4gICAgfVxuICAgIHppcFBvc3RGbGlnaHQocmVzcCkge1xuICAgICAgdGhpcy5tZXRhID0gcmVzcC5lbnRyaWVzW3RoaXMucmVmXTtcbiAgICAgIGlmICghdGhpcy5tZXRhKSB7XG4gICAgICAgIGxvZ0Vycm9yKGBubyBwcmVmbGlnaHQgdXBsb2FkIHJlc3BvbnNlIHJldHVybmVkIHdpdGggcmVmICR7dGhpcy5yZWZ9YCwgeyBpbnB1dDogdGhpcy5maWxlRWwsIHJlc3BvbnNlOiByZXNwIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvLyBqcy9waG9lbml4X2xpdmVfdmlldy9saXZlX3VwbG9hZGVyLmpzXG4gIHZhciBsaXZlVXBsb2FkZXJGaWxlUmVmID0gMDtcbiAgdmFyIExpdmVVcGxvYWRlciA9IGNsYXNzIHtcbiAgICBzdGF0aWMgZ2VuRmlsZVJlZihmaWxlKSB7XG4gICAgICBsZXQgcmVmID0gZmlsZS5fcGh4UmVmO1xuICAgICAgaWYgKHJlZiAhPT0gdm9pZCAwKSB7XG4gICAgICAgIHJldHVybiByZWY7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmaWxlLl9waHhSZWYgPSAobGl2ZVVwbG9hZGVyRmlsZVJlZisrKS50b1N0cmluZygpO1xuICAgICAgICByZXR1cm4gZmlsZS5fcGh4UmVmO1xuICAgICAgfVxuICAgIH1cbiAgICBzdGF0aWMgZ2V0RW50cnlEYXRhVVJMKGlucHV0RWwsIHJlZiwgY2FsbGJhY2spIHtcbiAgICAgIGxldCBmaWxlID0gdGhpcy5hY3RpdmVGaWxlcyhpbnB1dEVsKS5maW5kKChmaWxlMikgPT4gdGhpcy5nZW5GaWxlUmVmKGZpbGUyKSA9PT0gcmVmKTtcbiAgICAgIGNhbGxiYWNrKFVSTC5jcmVhdGVPYmplY3RVUkwoZmlsZSkpO1xuICAgIH1cbiAgICBzdGF0aWMgaGFzVXBsb2Fkc0luUHJvZ3Jlc3MoZm9ybUVsKSB7XG4gICAgICBsZXQgYWN0aXZlID0gMDtcbiAgICAgIGRvbV9kZWZhdWx0LmZpbmRVcGxvYWRJbnB1dHMoZm9ybUVsKS5mb3JFYWNoKChpbnB1dCkgPT4ge1xuICAgICAgICBpZiAoaW5wdXQuZ2V0QXR0cmlidXRlKFBIWF9QUkVGTElHSFRFRF9SRUZTKSAhPT0gaW5wdXQuZ2V0QXR0cmlidXRlKFBIWF9ET05FX1JFRlMpKSB7XG4gICAgICAgICAgYWN0aXZlKys7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGFjdGl2ZSA+IDA7XG4gICAgfVxuICAgIHN0YXRpYyBzZXJpYWxpemVVcGxvYWRzKGlucHV0RWwpIHtcbiAgICAgIGxldCBmaWxlcyA9IHRoaXMuYWN0aXZlRmlsZXMoaW5wdXRFbCk7XG4gICAgICBsZXQgZmlsZURhdGEgPSB7fTtcbiAgICAgIGZpbGVzLmZvckVhY2goKGZpbGUpID0+IHtcbiAgICAgICAgbGV0IGVudHJ5ID0geyBwYXRoOiBpbnB1dEVsLm5hbWUgfTtcbiAgICAgICAgbGV0IHVwbG9hZFJlZiA9IGlucHV0RWwuZ2V0QXR0cmlidXRlKFBIWF9VUExPQURfUkVGKTtcbiAgICAgICAgZmlsZURhdGFbdXBsb2FkUmVmXSA9IGZpbGVEYXRhW3VwbG9hZFJlZl0gfHwgW107XG4gICAgICAgIGVudHJ5LnJlZiA9IHRoaXMuZ2VuRmlsZVJlZihmaWxlKTtcbiAgICAgICAgZW50cnkubmFtZSA9IGZpbGUubmFtZSB8fCBlbnRyeS5yZWY7XG4gICAgICAgIGVudHJ5LnR5cGUgPSBmaWxlLnR5cGU7XG4gICAgICAgIGVudHJ5LnNpemUgPSBmaWxlLnNpemU7XG4gICAgICAgIGZpbGVEYXRhW3VwbG9hZFJlZl0ucHVzaChlbnRyeSk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBmaWxlRGF0YTtcbiAgICB9XG4gICAgc3RhdGljIGNsZWFyRmlsZXMoaW5wdXRFbCkge1xuICAgICAgaW5wdXRFbC52YWx1ZSA9IG51bGw7XG4gICAgICBpbnB1dEVsLnJlbW92ZUF0dHJpYnV0ZShQSFhfVVBMT0FEX1JFRik7XG4gICAgICBkb21fZGVmYXVsdC5wdXRQcml2YXRlKGlucHV0RWwsIFwiZmlsZXNcIiwgW10pO1xuICAgIH1cbiAgICBzdGF0aWMgdW50cmFja0ZpbGUoaW5wdXRFbCwgZmlsZSkge1xuICAgICAgZG9tX2RlZmF1bHQucHV0UHJpdmF0ZShpbnB1dEVsLCBcImZpbGVzXCIsIGRvbV9kZWZhdWx0LnByaXZhdGUoaW5wdXRFbCwgXCJmaWxlc1wiKS5maWx0ZXIoKGYpID0+ICFPYmplY3QuaXMoZiwgZmlsZSkpKTtcbiAgICB9XG4gICAgc3RhdGljIHRyYWNrRmlsZXMoaW5wdXRFbCwgZmlsZXMpIHtcbiAgICAgIGlmIChpbnB1dEVsLmdldEF0dHJpYnV0ZShcIm11bHRpcGxlXCIpICE9PSBudWxsKSB7XG4gICAgICAgIGxldCBuZXdGaWxlcyA9IGZpbGVzLmZpbHRlcigoZmlsZSkgPT4gIXRoaXMuYWN0aXZlRmlsZXMoaW5wdXRFbCkuZmluZCgoZikgPT4gT2JqZWN0LmlzKGYsIGZpbGUpKSk7XG4gICAgICAgIGRvbV9kZWZhdWx0LnB1dFByaXZhdGUoaW5wdXRFbCwgXCJmaWxlc1wiLCB0aGlzLmFjdGl2ZUZpbGVzKGlucHV0RWwpLmNvbmNhdChuZXdGaWxlcykpO1xuICAgICAgICBpbnB1dEVsLnZhbHVlID0gbnVsbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRvbV9kZWZhdWx0LnB1dFByaXZhdGUoaW5wdXRFbCwgXCJmaWxlc1wiLCBmaWxlcyk7XG4gICAgICB9XG4gICAgfVxuICAgIHN0YXRpYyBhY3RpdmVGaWxlSW5wdXRzKGZvcm1FbCkge1xuICAgICAgbGV0IGZpbGVJbnB1dHMgPSBkb21fZGVmYXVsdC5maW5kVXBsb2FkSW5wdXRzKGZvcm1FbCk7XG4gICAgICByZXR1cm4gQXJyYXkuZnJvbShmaWxlSW5wdXRzKS5maWx0ZXIoKGVsKSA9PiBlbC5maWxlcyAmJiB0aGlzLmFjdGl2ZUZpbGVzKGVsKS5sZW5ndGggPiAwKTtcbiAgICB9XG4gICAgc3RhdGljIGFjdGl2ZUZpbGVzKGlucHV0KSB7XG4gICAgICByZXR1cm4gKGRvbV9kZWZhdWx0LnByaXZhdGUoaW5wdXQsIFwiZmlsZXNcIikgfHwgW10pLmZpbHRlcigoZikgPT4gVXBsb2FkRW50cnkuaXNBY3RpdmUoaW5wdXQsIGYpKTtcbiAgICB9XG4gICAgc3RhdGljIGlucHV0c0F3YWl0aW5nUHJlZmxpZ2h0KGZvcm1FbCkge1xuICAgICAgbGV0IGZpbGVJbnB1dHMgPSBkb21fZGVmYXVsdC5maW5kVXBsb2FkSW5wdXRzKGZvcm1FbCk7XG4gICAgICByZXR1cm4gQXJyYXkuZnJvbShmaWxlSW5wdXRzKS5maWx0ZXIoKGlucHV0KSA9PiB0aGlzLmZpbGVzQXdhaXRpbmdQcmVmbGlnaHQoaW5wdXQpLmxlbmd0aCA+IDApO1xuICAgIH1cbiAgICBzdGF0aWMgZmlsZXNBd2FpdGluZ1ByZWZsaWdodChpbnB1dCkge1xuICAgICAgcmV0dXJuIHRoaXMuYWN0aXZlRmlsZXMoaW5wdXQpLmZpbHRlcigoZikgPT4gIVVwbG9hZEVudHJ5LmlzUHJlZmxpZ2h0ZWQoaW5wdXQsIGYpKTtcbiAgICB9XG4gICAgY29uc3RydWN0b3IoaW5wdXRFbCwgdmlldywgb25Db21wbGV0ZSkge1xuICAgICAgdGhpcy52aWV3ID0gdmlldztcbiAgICAgIHRoaXMub25Db21wbGV0ZSA9IG9uQ29tcGxldGU7XG4gICAgICB0aGlzLl9lbnRyaWVzID0gQXJyYXkuZnJvbShMaXZlVXBsb2FkZXIuZmlsZXNBd2FpdGluZ1ByZWZsaWdodChpbnB1dEVsKSB8fCBbXSkubWFwKChmaWxlKSA9PiBuZXcgVXBsb2FkRW50cnkoaW5wdXRFbCwgZmlsZSwgdmlldykpO1xuICAgICAgdGhpcy5udW1FbnRyaWVzSW5Qcm9ncmVzcyA9IHRoaXMuX2VudHJpZXMubGVuZ3RoO1xuICAgIH1cbiAgICBlbnRyaWVzKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2VudHJpZXM7XG4gICAgfVxuICAgIGluaXRBZGFwdGVyVXBsb2FkKHJlc3AsIG9uRXJyb3IsIGxpdmVTb2NrZXQpIHtcbiAgICAgIHRoaXMuX2VudHJpZXMgPSB0aGlzLl9lbnRyaWVzLm1hcCgoZW50cnkpID0+IHtcbiAgICAgICAgZW50cnkuemlwUG9zdEZsaWdodChyZXNwKTtcbiAgICAgICAgZW50cnkub25Eb25lKCgpID0+IHtcbiAgICAgICAgICB0aGlzLm51bUVudHJpZXNJblByb2dyZXNzLS07XG4gICAgICAgICAgaWYgKHRoaXMubnVtRW50cmllc0luUHJvZ3Jlc3MgPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMub25Db21wbGV0ZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBlbnRyeTtcbiAgICAgIH0pO1xuICAgICAgbGV0IGdyb3VwZWRFbnRyaWVzID0gdGhpcy5fZW50cmllcy5yZWR1Y2UoKGFjYywgZW50cnkpID0+IHtcbiAgICAgICAgbGV0IHsgbmFtZSwgY2FsbGJhY2sgfSA9IGVudHJ5LnVwbG9hZGVyKGxpdmVTb2NrZXQudXBsb2FkZXJzKTtcbiAgICAgICAgYWNjW25hbWVdID0gYWNjW25hbWVdIHx8IHsgY2FsbGJhY2ssIGVudHJpZXM6IFtdIH07XG4gICAgICAgIGFjY1tuYW1lXS5lbnRyaWVzLnB1c2goZW50cnkpO1xuICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgfSwge30pO1xuICAgICAgZm9yIChsZXQgbmFtZSBpbiBncm91cGVkRW50cmllcykge1xuICAgICAgICBsZXQgeyBjYWxsYmFjaywgZW50cmllcyB9ID0gZ3JvdXBlZEVudHJpZXNbbmFtZV07XG4gICAgICAgIGNhbGxiYWNrKGVudHJpZXMsIG9uRXJyb3IsIHJlc3AsIGxpdmVTb2NrZXQpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvLyBqcy9waG9lbml4X2xpdmVfdmlldy9ob29rcy5qc1xuICB2YXIgSG9va3MgPSB7XG4gICAgTGl2ZUZpbGVVcGxvYWQ6IHtcbiAgICAgIGFjdGl2ZVJlZnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVsLmdldEF0dHJpYnV0ZShQSFhfQUNUSVZFX0VOVFJZX1JFRlMpO1xuICAgICAgfSxcbiAgICAgIHByZWZsaWdodGVkUmVmcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZWwuZ2V0QXR0cmlidXRlKFBIWF9QUkVGTElHSFRFRF9SRUZTKTtcbiAgICAgIH0sXG4gICAgICBtb3VudGVkKCkge1xuICAgICAgICB0aGlzLnByZWZsaWdodGVkV2FzID0gdGhpcy5wcmVmbGlnaHRlZFJlZnMoKTtcbiAgICAgIH0sXG4gICAgICB1cGRhdGVkKCkge1xuICAgICAgICBsZXQgbmV3UHJlZmxpZ2h0cyA9IHRoaXMucHJlZmxpZ2h0ZWRSZWZzKCk7XG4gICAgICAgIGlmICh0aGlzLnByZWZsaWdodGVkV2FzICE9PSBuZXdQcmVmbGlnaHRzKSB7XG4gICAgICAgICAgdGhpcy5wcmVmbGlnaHRlZFdhcyA9IG5ld1ByZWZsaWdodHM7XG4gICAgICAgICAgaWYgKG5ld1ByZWZsaWdodHMgPT09IFwiXCIpIHtcbiAgICAgICAgICAgIHRoaXMuX192aWV3LmNhbmNlbFN1Ym1pdCh0aGlzLmVsLmZvcm0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5hY3RpdmVSZWZzKCkgPT09IFwiXCIpIHtcbiAgICAgICAgICB0aGlzLmVsLnZhbHVlID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmVsLmRpc3BhdGNoRXZlbnQobmV3IEN1c3RvbUV2ZW50KFBIWF9MSVZFX0ZJTEVfVVBEQVRFRCkpO1xuICAgICAgfVxuICAgIH0sXG4gICAgTGl2ZUltZ1ByZXZpZXc6IHtcbiAgICAgIG1vdW50ZWQoKSB7XG4gICAgICAgIHRoaXMucmVmID0gdGhpcy5lbC5nZXRBdHRyaWJ1dGUoXCJkYXRhLXBoeC1lbnRyeS1yZWZcIik7XG4gICAgICAgIHRoaXMuaW5wdXRFbCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHRoaXMuZWwuZ2V0QXR0cmlidXRlKFBIWF9VUExPQURfUkVGKSk7XG4gICAgICAgIExpdmVVcGxvYWRlci5nZXRFbnRyeURhdGFVUkwodGhpcy5pbnB1dEVsLCB0aGlzLnJlZiwgKHVybCkgPT4ge1xuICAgICAgICAgIHRoaXMudXJsID0gdXJsO1xuICAgICAgICAgIHRoaXMuZWwuc3JjID0gdXJsO1xuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICBkZXN0cm95ZWQoKSB7XG4gICAgICAgIFVSTC5yZXZva2VPYmplY3RVUkwodGhpcy51cmwpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgdmFyIGhvb2tzX2RlZmF1bHQgPSBIb29rcztcblxuICAvLyBqcy9waG9lbml4X2xpdmVfdmlldy9kb21fcG9zdF9tb3JwaF9yZXN0b3Jlci5qc1xuICB2YXIgRE9NUG9zdE1vcnBoUmVzdG9yZXIgPSBjbGFzcyB7XG4gICAgY29uc3RydWN0b3IoY29udGFpbmVyQmVmb3JlLCBjb250YWluZXJBZnRlciwgdXBkYXRlVHlwZSkge1xuICAgICAgbGV0IGlkc0JlZm9yZSA9IG5ldyBTZXQoKTtcbiAgICAgIGxldCBpZHNBZnRlciA9IG5ldyBTZXQoWy4uLmNvbnRhaW5lckFmdGVyLmNoaWxkcmVuXS5tYXAoKGNoaWxkKSA9PiBjaGlsZC5pZCkpO1xuICAgICAgbGV0IGVsZW1lbnRzVG9Nb2RpZnkgPSBbXTtcbiAgICAgIEFycmF5LmZyb20oY29udGFpbmVyQmVmb3JlLmNoaWxkcmVuKS5mb3JFYWNoKChjaGlsZCkgPT4ge1xuICAgICAgICBpZiAoY2hpbGQuaWQpIHtcbiAgICAgICAgICBpZHNCZWZvcmUuYWRkKGNoaWxkLmlkKTtcbiAgICAgICAgICBpZiAoaWRzQWZ0ZXIuaGFzKGNoaWxkLmlkKSkge1xuICAgICAgICAgICAgbGV0IHByZXZpb3VzRWxlbWVudElkID0gY2hpbGQucHJldmlvdXNFbGVtZW50U2libGluZyAmJiBjaGlsZC5wcmV2aW91c0VsZW1lbnRTaWJsaW5nLmlkO1xuICAgICAgICAgICAgZWxlbWVudHNUb01vZGlmeS5wdXNoKHsgZWxlbWVudElkOiBjaGlsZC5pZCwgcHJldmlvdXNFbGVtZW50SWQgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHRoaXMuY29udGFpbmVySWQgPSBjb250YWluZXJBZnRlci5pZDtcbiAgICAgIHRoaXMudXBkYXRlVHlwZSA9IHVwZGF0ZVR5cGU7XG4gICAgICB0aGlzLmVsZW1lbnRzVG9Nb2RpZnkgPSBlbGVtZW50c1RvTW9kaWZ5O1xuICAgICAgdGhpcy5lbGVtZW50SWRzVG9BZGQgPSBbLi4uaWRzQWZ0ZXJdLmZpbHRlcigoaWQpID0+ICFpZHNCZWZvcmUuaGFzKGlkKSk7XG4gICAgfVxuICAgIHBlcmZvcm0oKSB7XG4gICAgICBsZXQgY29udGFpbmVyID0gZG9tX2RlZmF1bHQuYnlJZCh0aGlzLmNvbnRhaW5lcklkKTtcbiAgICAgIHRoaXMuZWxlbWVudHNUb01vZGlmeS5mb3JFYWNoKChlbGVtZW50VG9Nb2RpZnkpID0+IHtcbiAgICAgICAgaWYgKGVsZW1lbnRUb01vZGlmeS5wcmV2aW91c0VsZW1lbnRJZCkge1xuICAgICAgICAgIG1heWJlKGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGVsZW1lbnRUb01vZGlmeS5wcmV2aW91c0VsZW1lbnRJZCksIChwcmV2aW91c0VsZW0pID0+IHtcbiAgICAgICAgICAgIG1heWJlKGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGVsZW1lbnRUb01vZGlmeS5lbGVtZW50SWQpLCAoZWxlbSkgPT4ge1xuICAgICAgICAgICAgICBsZXQgaXNJblJpZ2h0UGxhY2UgPSBlbGVtLnByZXZpb3VzRWxlbWVudFNpYmxpbmcgJiYgZWxlbS5wcmV2aW91c0VsZW1lbnRTaWJsaW5nLmlkID09IHByZXZpb3VzRWxlbS5pZDtcbiAgICAgICAgICAgICAgaWYgKCFpc0luUmlnaHRQbGFjZSkge1xuICAgICAgICAgICAgICAgIHByZXZpb3VzRWxlbS5pbnNlcnRBZGphY2VudEVsZW1lbnQoXCJhZnRlcmVuZFwiLCBlbGVtKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbWF5YmUoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoZWxlbWVudFRvTW9kaWZ5LmVsZW1lbnRJZCksIChlbGVtKSA9PiB7XG4gICAgICAgICAgICBsZXQgaXNJblJpZ2h0UGxhY2UgPSBlbGVtLnByZXZpb3VzRWxlbWVudFNpYmxpbmcgPT0gbnVsbDtcbiAgICAgICAgICAgIGlmICghaXNJblJpZ2h0UGxhY2UpIHtcbiAgICAgICAgICAgICAgY29udGFpbmVyLmluc2VydEFkamFjZW50RWxlbWVudChcImFmdGVyYmVnaW5cIiwgZWxlbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgaWYgKHRoaXMudXBkYXRlVHlwZSA9PSBcInByZXBlbmRcIikge1xuICAgICAgICB0aGlzLmVsZW1lbnRJZHNUb0FkZC5yZXZlcnNlKCkuZm9yRWFjaCgoZWxlbUlkKSA9PiB7XG4gICAgICAgICAgbWF5YmUoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoZWxlbUlkKSwgKGVsZW0pID0+IGNvbnRhaW5lci5pbnNlcnRBZGphY2VudEVsZW1lbnQoXCJhZnRlcmJlZ2luXCIsIGVsZW0pKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8vIG5vZGVfbW9kdWxlcy9tb3JwaGRvbS9kaXN0L21vcnBoZG9tLWVzbS5qc1xuICB2YXIgRE9DVU1FTlRfRlJBR01FTlRfTk9ERSA9IDExO1xuICBmdW5jdGlvbiBtb3JwaEF0dHJzKGZyb21Ob2RlLCB0b05vZGUpIHtcbiAgICB2YXIgdG9Ob2RlQXR0cnMgPSB0b05vZGUuYXR0cmlidXRlcztcbiAgICB2YXIgYXR0cjtcbiAgICB2YXIgYXR0ck5hbWU7XG4gICAgdmFyIGF0dHJOYW1lc3BhY2VVUkk7XG4gICAgdmFyIGF0dHJWYWx1ZTtcbiAgICB2YXIgZnJvbVZhbHVlO1xuICAgIGlmICh0b05vZGUubm9kZVR5cGUgPT09IERPQ1VNRU5UX0ZSQUdNRU5UX05PREUgfHwgZnJvbU5vZGUubm9kZVR5cGUgPT09IERPQ1VNRU5UX0ZSQUdNRU5UX05PREUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IHRvTm9kZUF0dHJzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICBhdHRyID0gdG9Ob2RlQXR0cnNbaV07XG4gICAgICBhdHRyTmFtZSA9IGF0dHIubmFtZTtcbiAgICAgIGF0dHJOYW1lc3BhY2VVUkkgPSBhdHRyLm5hbWVzcGFjZVVSSTtcbiAgICAgIGF0dHJWYWx1ZSA9IGF0dHIudmFsdWU7XG4gICAgICBpZiAoYXR0ck5hbWVzcGFjZVVSSSkge1xuICAgICAgICBhdHRyTmFtZSA9IGF0dHIubG9jYWxOYW1lIHx8IGF0dHJOYW1lO1xuICAgICAgICBmcm9tVmFsdWUgPSBmcm9tTm9kZS5nZXRBdHRyaWJ1dGVOUyhhdHRyTmFtZXNwYWNlVVJJLCBhdHRyTmFtZSk7XG4gICAgICAgIGlmIChmcm9tVmFsdWUgIT09IGF0dHJWYWx1ZSkge1xuICAgICAgICAgIGlmIChhdHRyLnByZWZpeCA9PT0gXCJ4bWxuc1wiKSB7XG4gICAgICAgICAgICBhdHRyTmFtZSA9IGF0dHIubmFtZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZnJvbU5vZGUuc2V0QXR0cmlidXRlTlMoYXR0ck5hbWVzcGFjZVVSSSwgYXR0ck5hbWUsIGF0dHJWYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZyb21WYWx1ZSA9IGZyb21Ob2RlLmdldEF0dHJpYnV0ZShhdHRyTmFtZSk7XG4gICAgICAgIGlmIChmcm9tVmFsdWUgIT09IGF0dHJWYWx1ZSkge1xuICAgICAgICAgIGZyb21Ob2RlLnNldEF0dHJpYnV0ZShhdHRyTmFtZSwgYXR0clZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICB2YXIgZnJvbU5vZGVBdHRycyA9IGZyb21Ob2RlLmF0dHJpYnV0ZXM7XG4gICAgZm9yICh2YXIgZCA9IGZyb21Ob2RlQXR0cnMubGVuZ3RoIC0gMTsgZCA+PSAwOyBkLS0pIHtcbiAgICAgIGF0dHIgPSBmcm9tTm9kZUF0dHJzW2RdO1xuICAgICAgYXR0ck5hbWUgPSBhdHRyLm5hbWU7XG4gICAgICBhdHRyTmFtZXNwYWNlVVJJID0gYXR0ci5uYW1lc3BhY2VVUkk7XG4gICAgICBpZiAoYXR0ck5hbWVzcGFjZVVSSSkge1xuICAgICAgICBhdHRyTmFtZSA9IGF0dHIubG9jYWxOYW1lIHx8IGF0dHJOYW1lO1xuICAgICAgICBpZiAoIXRvTm9kZS5oYXNBdHRyaWJ1dGVOUyhhdHRyTmFtZXNwYWNlVVJJLCBhdHRyTmFtZSkpIHtcbiAgICAgICAgICBmcm9tTm9kZS5yZW1vdmVBdHRyaWJ1dGVOUyhhdHRyTmFtZXNwYWNlVVJJLCBhdHRyTmFtZSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICghdG9Ob2RlLmhhc0F0dHJpYnV0ZShhdHRyTmFtZSkpIHtcbiAgICAgICAgICBmcm9tTm9kZS5yZW1vdmVBdHRyaWJ1dGUoYXR0ck5hbWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHZhciByYW5nZTtcbiAgdmFyIE5TX1hIVE1MID0gXCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sXCI7XG4gIHZhciBkb2MgPSB0eXBlb2YgZG9jdW1lbnQgPT09IFwidW5kZWZpbmVkXCIgPyB2b2lkIDAgOiBkb2N1bWVudDtcbiAgdmFyIEhBU19URU1QTEFURV9TVVBQT1JUID0gISFkb2MgJiYgXCJjb250ZW50XCIgaW4gZG9jLmNyZWF0ZUVsZW1lbnQoXCJ0ZW1wbGF0ZVwiKTtcbiAgdmFyIEhBU19SQU5HRV9TVVBQT1JUID0gISFkb2MgJiYgZG9jLmNyZWF0ZVJhbmdlICYmIFwiY3JlYXRlQ29udGV4dHVhbEZyYWdtZW50XCIgaW4gZG9jLmNyZWF0ZVJhbmdlKCk7XG4gIGZ1bmN0aW9uIGNyZWF0ZUZyYWdtZW50RnJvbVRlbXBsYXRlKHN0cikge1xuICAgIHZhciB0ZW1wbGF0ZSA9IGRvYy5jcmVhdGVFbGVtZW50KFwidGVtcGxhdGVcIik7XG4gICAgdGVtcGxhdGUuaW5uZXJIVE1MID0gc3RyO1xuICAgIHJldHVybiB0ZW1wbGF0ZS5jb250ZW50LmNoaWxkTm9kZXNbMF07XG4gIH1cbiAgZnVuY3Rpb24gY3JlYXRlRnJhZ21lbnRGcm9tUmFuZ2Uoc3RyKSB7XG4gICAgaWYgKCFyYW5nZSkge1xuICAgICAgcmFuZ2UgPSBkb2MuY3JlYXRlUmFuZ2UoKTtcbiAgICAgIHJhbmdlLnNlbGVjdE5vZGUoZG9jLmJvZHkpO1xuICAgIH1cbiAgICB2YXIgZnJhZ21lbnQgPSByYW5nZS5jcmVhdGVDb250ZXh0dWFsRnJhZ21lbnQoc3RyKTtcbiAgICByZXR1cm4gZnJhZ21lbnQuY2hpbGROb2Rlc1swXTtcbiAgfVxuICBmdW5jdGlvbiBjcmVhdGVGcmFnbWVudEZyb21XcmFwKHN0cikge1xuICAgIHZhciBmcmFnbWVudCA9IGRvYy5jcmVhdGVFbGVtZW50KFwiYm9keVwiKTtcbiAgICBmcmFnbWVudC5pbm5lckhUTUwgPSBzdHI7XG4gICAgcmV0dXJuIGZyYWdtZW50LmNoaWxkTm9kZXNbMF07XG4gIH1cbiAgZnVuY3Rpb24gdG9FbGVtZW50KHN0cikge1xuICAgIHN0ciA9IHN0ci50cmltKCk7XG4gICAgaWYgKEhBU19URU1QTEFURV9TVVBQT1JUKSB7XG4gICAgICByZXR1cm4gY3JlYXRlRnJhZ21lbnRGcm9tVGVtcGxhdGUoc3RyKTtcbiAgICB9IGVsc2UgaWYgKEhBU19SQU5HRV9TVVBQT1JUKSB7XG4gICAgICByZXR1cm4gY3JlYXRlRnJhZ21lbnRGcm9tUmFuZ2Uoc3RyKTtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUZyYWdtZW50RnJvbVdyYXAoc3RyKTtcbiAgfVxuICBmdW5jdGlvbiBjb21wYXJlTm9kZU5hbWVzKGZyb21FbCwgdG9FbCkge1xuICAgIHZhciBmcm9tTm9kZU5hbWUgPSBmcm9tRWwubm9kZU5hbWU7XG4gICAgdmFyIHRvTm9kZU5hbWUgPSB0b0VsLm5vZGVOYW1lO1xuICAgIHZhciBmcm9tQ29kZVN0YXJ0LCB0b0NvZGVTdGFydDtcbiAgICBpZiAoZnJvbU5vZGVOYW1lID09PSB0b05vZGVOYW1lKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgZnJvbUNvZGVTdGFydCA9IGZyb21Ob2RlTmFtZS5jaGFyQ29kZUF0KDApO1xuICAgIHRvQ29kZVN0YXJ0ID0gdG9Ob2RlTmFtZS5jaGFyQ29kZUF0KDApO1xuICAgIGlmIChmcm9tQ29kZVN0YXJ0IDw9IDkwICYmIHRvQ29kZVN0YXJ0ID49IDk3KSB7XG4gICAgICByZXR1cm4gZnJvbU5vZGVOYW1lID09PSB0b05vZGVOYW1lLnRvVXBwZXJDYXNlKCk7XG4gICAgfSBlbHNlIGlmICh0b0NvZGVTdGFydCA8PSA5MCAmJiBmcm9tQ29kZVN0YXJ0ID49IDk3KSB7XG4gICAgICByZXR1cm4gdG9Ob2RlTmFtZSA9PT0gZnJvbU5vZGVOYW1lLnRvVXBwZXJDYXNlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gY3JlYXRlRWxlbWVudE5TKG5hbWUsIG5hbWVzcGFjZVVSSSkge1xuICAgIHJldHVybiAhbmFtZXNwYWNlVVJJIHx8IG5hbWVzcGFjZVVSSSA9PT0gTlNfWEhUTUwgPyBkb2MuY3JlYXRlRWxlbWVudChuYW1lKSA6IGRvYy5jcmVhdGVFbGVtZW50TlMobmFtZXNwYWNlVVJJLCBuYW1lKTtcbiAgfVxuICBmdW5jdGlvbiBtb3ZlQ2hpbGRyZW4oZnJvbUVsLCB0b0VsKSB7XG4gICAgdmFyIGN1ckNoaWxkID0gZnJvbUVsLmZpcnN0Q2hpbGQ7XG4gICAgd2hpbGUgKGN1ckNoaWxkKSB7XG4gICAgICB2YXIgbmV4dENoaWxkID0gY3VyQ2hpbGQubmV4dFNpYmxpbmc7XG4gICAgICB0b0VsLmFwcGVuZENoaWxkKGN1ckNoaWxkKTtcbiAgICAgIGN1ckNoaWxkID0gbmV4dENoaWxkO1xuICAgIH1cbiAgICByZXR1cm4gdG9FbDtcbiAgfVxuICBmdW5jdGlvbiBzeW5jQm9vbGVhbkF0dHJQcm9wKGZyb21FbCwgdG9FbCwgbmFtZSkge1xuICAgIGlmIChmcm9tRWxbbmFtZV0gIT09IHRvRWxbbmFtZV0pIHtcbiAgICAgIGZyb21FbFtuYW1lXSA9IHRvRWxbbmFtZV07XG4gICAgICBpZiAoZnJvbUVsW25hbWVdKSB7XG4gICAgICAgIGZyb21FbC5zZXRBdHRyaWJ1dGUobmFtZSwgXCJcIik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmcm9tRWwucmVtb3ZlQXR0cmlidXRlKG5hbWUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICB2YXIgc3BlY2lhbEVsSGFuZGxlcnMgPSB7XG4gICAgT1BUSU9OOiBmdW5jdGlvbihmcm9tRWwsIHRvRWwpIHtcbiAgICAgIHZhciBwYXJlbnROb2RlID0gZnJvbUVsLnBhcmVudE5vZGU7XG4gICAgICBpZiAocGFyZW50Tm9kZSkge1xuICAgICAgICB2YXIgcGFyZW50TmFtZSA9IHBhcmVudE5vZGUubm9kZU5hbWUudG9VcHBlckNhc2UoKTtcbiAgICAgICAgaWYgKHBhcmVudE5hbWUgPT09IFwiT1BUR1JPVVBcIikge1xuICAgICAgICAgIHBhcmVudE5vZGUgPSBwYXJlbnROb2RlLnBhcmVudE5vZGU7XG4gICAgICAgICAgcGFyZW50TmFtZSA9IHBhcmVudE5vZGUgJiYgcGFyZW50Tm9kZS5ub2RlTmFtZS50b1VwcGVyQ2FzZSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJlbnROYW1lID09PSBcIlNFTEVDVFwiICYmICFwYXJlbnROb2RlLmhhc0F0dHJpYnV0ZShcIm11bHRpcGxlXCIpKSB7XG4gICAgICAgICAgaWYgKGZyb21FbC5oYXNBdHRyaWJ1dGUoXCJzZWxlY3RlZFwiKSAmJiAhdG9FbC5zZWxlY3RlZCkge1xuICAgICAgICAgICAgZnJvbUVsLnNldEF0dHJpYnV0ZShcInNlbGVjdGVkXCIsIFwic2VsZWN0ZWRcIik7XG4gICAgICAgICAgICBmcm9tRWwucmVtb3ZlQXR0cmlidXRlKFwic2VsZWN0ZWRcIik7XG4gICAgICAgICAgfVxuICAgICAgICAgIHBhcmVudE5vZGUuc2VsZWN0ZWRJbmRleCA9IC0xO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBzeW5jQm9vbGVhbkF0dHJQcm9wKGZyb21FbCwgdG9FbCwgXCJzZWxlY3RlZFwiKTtcbiAgICB9LFxuICAgIElOUFVUOiBmdW5jdGlvbihmcm9tRWwsIHRvRWwpIHtcbiAgICAgIHN5bmNCb29sZWFuQXR0clByb3AoZnJvbUVsLCB0b0VsLCBcImNoZWNrZWRcIik7XG4gICAgICBzeW5jQm9vbGVhbkF0dHJQcm9wKGZyb21FbCwgdG9FbCwgXCJkaXNhYmxlZFwiKTtcbiAgICAgIGlmIChmcm9tRWwudmFsdWUgIT09IHRvRWwudmFsdWUpIHtcbiAgICAgICAgZnJvbUVsLnZhbHVlID0gdG9FbC52YWx1ZTtcbiAgICAgIH1cbiAgICAgIGlmICghdG9FbC5oYXNBdHRyaWJ1dGUoXCJ2YWx1ZVwiKSkge1xuICAgICAgICBmcm9tRWwucmVtb3ZlQXR0cmlidXRlKFwidmFsdWVcIik7XG4gICAgICB9XG4gICAgfSxcbiAgICBURVhUQVJFQTogZnVuY3Rpb24oZnJvbUVsLCB0b0VsKSB7XG4gICAgICB2YXIgbmV3VmFsdWUgPSB0b0VsLnZhbHVlO1xuICAgICAgaWYgKGZyb21FbC52YWx1ZSAhPT0gbmV3VmFsdWUpIHtcbiAgICAgICAgZnJvbUVsLnZhbHVlID0gbmV3VmFsdWU7XG4gICAgICB9XG4gICAgICB2YXIgZmlyc3RDaGlsZCA9IGZyb21FbC5maXJzdENoaWxkO1xuICAgICAgaWYgKGZpcnN0Q2hpbGQpIHtcbiAgICAgICAgdmFyIG9sZFZhbHVlID0gZmlyc3RDaGlsZC5ub2RlVmFsdWU7XG4gICAgICAgIGlmIChvbGRWYWx1ZSA9PSBuZXdWYWx1ZSB8fCAhbmV3VmFsdWUgJiYgb2xkVmFsdWUgPT0gZnJvbUVsLnBsYWNlaG9sZGVyKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGZpcnN0Q2hpbGQubm9kZVZhbHVlID0gbmV3VmFsdWU7XG4gICAgICB9XG4gICAgfSxcbiAgICBTRUxFQ1Q6IGZ1bmN0aW9uKGZyb21FbCwgdG9FbCkge1xuICAgICAgaWYgKCF0b0VsLmhhc0F0dHJpYnV0ZShcIm11bHRpcGxlXCIpKSB7XG4gICAgICAgIHZhciBzZWxlY3RlZEluZGV4ID0gLTE7XG4gICAgICAgIHZhciBpID0gMDtcbiAgICAgICAgdmFyIGN1ckNoaWxkID0gZnJvbUVsLmZpcnN0Q2hpbGQ7XG4gICAgICAgIHZhciBvcHRncm91cDtcbiAgICAgICAgdmFyIG5vZGVOYW1lO1xuICAgICAgICB3aGlsZSAoY3VyQ2hpbGQpIHtcbiAgICAgICAgICBub2RlTmFtZSA9IGN1ckNoaWxkLm5vZGVOYW1lICYmIGN1ckNoaWxkLm5vZGVOYW1lLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgICAgaWYgKG5vZGVOYW1lID09PSBcIk9QVEdST1VQXCIpIHtcbiAgICAgICAgICAgIG9wdGdyb3VwID0gY3VyQ2hpbGQ7XG4gICAgICAgICAgICBjdXJDaGlsZCA9IG9wdGdyb3VwLmZpcnN0Q2hpbGQ7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChub2RlTmFtZSA9PT0gXCJPUFRJT05cIikge1xuICAgICAgICAgICAgICBpZiAoY3VyQ2hpbGQuaGFzQXR0cmlidXRlKFwic2VsZWN0ZWRcIikpIHtcbiAgICAgICAgICAgICAgICBzZWxlY3RlZEluZGV4ID0gaTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdXJDaGlsZCA9IGN1ckNoaWxkLm5leHRTaWJsaW5nO1xuICAgICAgICAgICAgaWYgKCFjdXJDaGlsZCAmJiBvcHRncm91cCkge1xuICAgICAgICAgICAgICBjdXJDaGlsZCA9IG9wdGdyb3VwLm5leHRTaWJsaW5nO1xuICAgICAgICAgICAgICBvcHRncm91cCA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZyb21FbC5zZWxlY3RlZEluZGV4ID0gc2VsZWN0ZWRJbmRleDtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIHZhciBFTEVNRU5UX05PREUgPSAxO1xuICB2YXIgRE9DVU1FTlRfRlJBR01FTlRfTk9ERSQxID0gMTE7XG4gIHZhciBURVhUX05PREUgPSAzO1xuICB2YXIgQ09NTUVOVF9OT0RFID0gODtcbiAgZnVuY3Rpb24gbm9vcCgpIHtcbiAgfVxuICBmdW5jdGlvbiBkZWZhdWx0R2V0Tm9kZUtleShub2RlKSB7XG4gICAgaWYgKG5vZGUpIHtcbiAgICAgIHJldHVybiBub2RlLmdldEF0dHJpYnV0ZSAmJiBub2RlLmdldEF0dHJpYnV0ZShcImlkXCIpIHx8IG5vZGUuaWQ7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIG1vcnBoZG9tRmFjdG9yeShtb3JwaEF0dHJzMikge1xuICAgIHJldHVybiBmdW5jdGlvbiBtb3JwaGRvbTIoZnJvbU5vZGUsIHRvTm9kZSwgb3B0aW9ucykge1xuICAgICAgaWYgKCFvcHRpb25zKSB7XG4gICAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgdG9Ob2RlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGlmIChmcm9tTm9kZS5ub2RlTmFtZSA9PT0gXCIjZG9jdW1lbnRcIiB8fCBmcm9tTm9kZS5ub2RlTmFtZSA9PT0gXCJIVE1MXCIgfHwgZnJvbU5vZGUubm9kZU5hbWUgPT09IFwiQk9EWVwiKSB7XG4gICAgICAgICAgdmFyIHRvTm9kZUh0bWwgPSB0b05vZGU7XG4gICAgICAgICAgdG9Ob2RlID0gZG9jLmNyZWF0ZUVsZW1lbnQoXCJodG1sXCIpO1xuICAgICAgICAgIHRvTm9kZS5pbm5lckhUTUwgPSB0b05vZGVIdG1sO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRvTm9kZSA9IHRvRWxlbWVudCh0b05vZGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2YXIgZ2V0Tm9kZUtleSA9IG9wdGlvbnMuZ2V0Tm9kZUtleSB8fCBkZWZhdWx0R2V0Tm9kZUtleTtcbiAgICAgIHZhciBvbkJlZm9yZU5vZGVBZGRlZCA9IG9wdGlvbnMub25CZWZvcmVOb2RlQWRkZWQgfHwgbm9vcDtcbiAgICAgIHZhciBvbk5vZGVBZGRlZCA9IG9wdGlvbnMub25Ob2RlQWRkZWQgfHwgbm9vcDtcbiAgICAgIHZhciBvbkJlZm9yZUVsVXBkYXRlZCA9IG9wdGlvbnMub25CZWZvcmVFbFVwZGF0ZWQgfHwgbm9vcDtcbiAgICAgIHZhciBvbkVsVXBkYXRlZCA9IG9wdGlvbnMub25FbFVwZGF0ZWQgfHwgbm9vcDtcbiAgICAgIHZhciBvbkJlZm9yZU5vZGVEaXNjYXJkZWQgPSBvcHRpb25zLm9uQmVmb3JlTm9kZURpc2NhcmRlZCB8fCBub29wO1xuICAgICAgdmFyIG9uTm9kZURpc2NhcmRlZCA9IG9wdGlvbnMub25Ob2RlRGlzY2FyZGVkIHx8IG5vb3A7XG4gICAgICB2YXIgb25CZWZvcmVFbENoaWxkcmVuVXBkYXRlZCA9IG9wdGlvbnMub25CZWZvcmVFbENoaWxkcmVuVXBkYXRlZCB8fCBub29wO1xuICAgICAgdmFyIGNoaWxkcmVuT25seSA9IG9wdGlvbnMuY2hpbGRyZW5Pbmx5ID09PSB0cnVlO1xuICAgICAgdmFyIGZyb21Ob2Rlc0xvb2t1cCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICB2YXIga2V5ZWRSZW1vdmFsTGlzdCA9IFtdO1xuICAgICAgZnVuY3Rpb24gYWRkS2V5ZWRSZW1vdmFsKGtleSkge1xuICAgICAgICBrZXllZFJlbW92YWxMaXN0LnB1c2goa2V5KTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIHdhbGtEaXNjYXJkZWRDaGlsZE5vZGVzKG5vZGUsIHNraXBLZXllZE5vZGVzKSB7XG4gICAgICAgIGlmIChub2RlLm5vZGVUeXBlID09PSBFTEVNRU5UX05PREUpIHtcbiAgICAgICAgICB2YXIgY3VyQ2hpbGQgPSBub2RlLmZpcnN0Q2hpbGQ7XG4gICAgICAgICAgd2hpbGUgKGN1ckNoaWxkKSB7XG4gICAgICAgICAgICB2YXIga2V5ID0gdm9pZCAwO1xuICAgICAgICAgICAgaWYgKHNraXBLZXllZE5vZGVzICYmIChrZXkgPSBnZXROb2RlS2V5KGN1ckNoaWxkKSkpIHtcbiAgICAgICAgICAgICAgYWRkS2V5ZWRSZW1vdmFsKGtleSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBvbk5vZGVEaXNjYXJkZWQoY3VyQ2hpbGQpO1xuICAgICAgICAgICAgICBpZiAoY3VyQ2hpbGQuZmlyc3RDaGlsZCkge1xuICAgICAgICAgICAgICAgIHdhbGtEaXNjYXJkZWRDaGlsZE5vZGVzKGN1ckNoaWxkLCBza2lwS2V5ZWROb2Rlcyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN1ckNoaWxkID0gY3VyQ2hpbGQubmV4dFNpYmxpbmc7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiByZW1vdmVOb2RlKG5vZGUsIHBhcmVudE5vZGUsIHNraXBLZXllZE5vZGVzKSB7XG4gICAgICAgIGlmIChvbkJlZm9yZU5vZGVEaXNjYXJkZWQobm9kZSkgPT09IGZhbHNlKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJlbnROb2RlKSB7XG4gICAgICAgICAgcGFyZW50Tm9kZS5yZW1vdmVDaGlsZChub2RlKTtcbiAgICAgICAgfVxuICAgICAgICBvbk5vZGVEaXNjYXJkZWQobm9kZSk7XG4gICAgICAgIHdhbGtEaXNjYXJkZWRDaGlsZE5vZGVzKG5vZGUsIHNraXBLZXllZE5vZGVzKTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIGluZGV4VHJlZShub2RlKSB7XG4gICAgICAgIGlmIChub2RlLm5vZGVUeXBlID09PSBFTEVNRU5UX05PREUgfHwgbm9kZS5ub2RlVHlwZSA9PT0gRE9DVU1FTlRfRlJBR01FTlRfTk9ERSQxKSB7XG4gICAgICAgICAgdmFyIGN1ckNoaWxkID0gbm9kZS5maXJzdENoaWxkO1xuICAgICAgICAgIHdoaWxlIChjdXJDaGlsZCkge1xuICAgICAgICAgICAgdmFyIGtleSA9IGdldE5vZGVLZXkoY3VyQ2hpbGQpO1xuICAgICAgICAgICAgaWYgKGtleSkge1xuICAgICAgICAgICAgICBmcm9tTm9kZXNMb29rdXBba2V5XSA9IGN1ckNoaWxkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaW5kZXhUcmVlKGN1ckNoaWxkKTtcbiAgICAgICAgICAgIGN1ckNoaWxkID0gY3VyQ2hpbGQubmV4dFNpYmxpbmc7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpbmRleFRyZWUoZnJvbU5vZGUpO1xuICAgICAgZnVuY3Rpb24gaGFuZGxlTm9kZUFkZGVkKGVsKSB7XG4gICAgICAgIG9uTm9kZUFkZGVkKGVsKTtcbiAgICAgICAgdmFyIGN1ckNoaWxkID0gZWwuZmlyc3RDaGlsZDtcbiAgICAgICAgd2hpbGUgKGN1ckNoaWxkKSB7XG4gICAgICAgICAgdmFyIG5leHRTaWJsaW5nID0gY3VyQ2hpbGQubmV4dFNpYmxpbmc7XG4gICAgICAgICAgdmFyIGtleSA9IGdldE5vZGVLZXkoY3VyQ2hpbGQpO1xuICAgICAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgICAgIHZhciB1bm1hdGNoZWRGcm9tRWwgPSBmcm9tTm9kZXNMb29rdXBba2V5XTtcbiAgICAgICAgICAgIGlmICh1bm1hdGNoZWRGcm9tRWwgJiYgY29tcGFyZU5vZGVOYW1lcyhjdXJDaGlsZCwgdW5tYXRjaGVkRnJvbUVsKSkge1xuICAgICAgICAgICAgICBjdXJDaGlsZC5wYXJlbnROb2RlLnJlcGxhY2VDaGlsZCh1bm1hdGNoZWRGcm9tRWwsIGN1ckNoaWxkKTtcbiAgICAgICAgICAgICAgbW9ycGhFbCh1bm1hdGNoZWRGcm9tRWwsIGN1ckNoaWxkKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGhhbmRsZU5vZGVBZGRlZChjdXJDaGlsZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGhhbmRsZU5vZGVBZGRlZChjdXJDaGlsZCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGN1ckNoaWxkID0gbmV4dFNpYmxpbmc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIGNsZWFudXBGcm9tRWwoZnJvbUVsLCBjdXJGcm9tTm9kZUNoaWxkLCBjdXJGcm9tTm9kZUtleSkge1xuICAgICAgICB3aGlsZSAoY3VyRnJvbU5vZGVDaGlsZCkge1xuICAgICAgICAgIHZhciBmcm9tTmV4dFNpYmxpbmcgPSBjdXJGcm9tTm9kZUNoaWxkLm5leHRTaWJsaW5nO1xuICAgICAgICAgIGlmIChjdXJGcm9tTm9kZUtleSA9IGdldE5vZGVLZXkoY3VyRnJvbU5vZGVDaGlsZCkpIHtcbiAgICAgICAgICAgIGFkZEtleWVkUmVtb3ZhbChjdXJGcm9tTm9kZUtleSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlbW92ZU5vZGUoY3VyRnJvbU5vZGVDaGlsZCwgZnJvbUVsLCB0cnVlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY3VyRnJvbU5vZGVDaGlsZCA9IGZyb21OZXh0U2libGluZztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZnVuY3Rpb24gbW9ycGhFbChmcm9tRWwsIHRvRWwsIGNoaWxkcmVuT25seTIpIHtcbiAgICAgICAgdmFyIHRvRWxLZXkgPSBnZXROb2RlS2V5KHRvRWwpO1xuICAgICAgICBpZiAodG9FbEtleSkge1xuICAgICAgICAgIGRlbGV0ZSBmcm9tTm9kZXNMb29rdXBbdG9FbEtleV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFjaGlsZHJlbk9ubHkyKSB7XG4gICAgICAgICAgaWYgKG9uQmVmb3JlRWxVcGRhdGVkKGZyb21FbCwgdG9FbCkgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIG1vcnBoQXR0cnMyKGZyb21FbCwgdG9FbCk7XG4gICAgICAgICAgb25FbFVwZGF0ZWQoZnJvbUVsKTtcbiAgICAgICAgICBpZiAob25CZWZvcmVFbENoaWxkcmVuVXBkYXRlZChmcm9tRWwsIHRvRWwpID09PSBmYWxzZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZnJvbUVsLm5vZGVOYW1lICE9PSBcIlRFWFRBUkVBXCIpIHtcbiAgICAgICAgICBtb3JwaENoaWxkcmVuKGZyb21FbCwgdG9FbCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3BlY2lhbEVsSGFuZGxlcnMuVEVYVEFSRUEoZnJvbUVsLCB0b0VsKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZnVuY3Rpb24gbW9ycGhDaGlsZHJlbihmcm9tRWwsIHRvRWwpIHtcbiAgICAgICAgdmFyIGN1clRvTm9kZUNoaWxkID0gdG9FbC5maXJzdENoaWxkO1xuICAgICAgICB2YXIgY3VyRnJvbU5vZGVDaGlsZCA9IGZyb21FbC5maXJzdENoaWxkO1xuICAgICAgICB2YXIgY3VyVG9Ob2RlS2V5O1xuICAgICAgICB2YXIgY3VyRnJvbU5vZGVLZXk7XG4gICAgICAgIHZhciBmcm9tTmV4dFNpYmxpbmc7XG4gICAgICAgIHZhciB0b05leHRTaWJsaW5nO1xuICAgICAgICB2YXIgbWF0Y2hpbmdGcm9tRWw7XG4gICAgICAgIG91dGVyOlxuICAgICAgICAgIHdoaWxlIChjdXJUb05vZGVDaGlsZCkge1xuICAgICAgICAgICAgdG9OZXh0U2libGluZyA9IGN1clRvTm9kZUNoaWxkLm5leHRTaWJsaW5nO1xuICAgICAgICAgICAgY3VyVG9Ob2RlS2V5ID0gZ2V0Tm9kZUtleShjdXJUb05vZGVDaGlsZCk7XG4gICAgICAgICAgICB3aGlsZSAoY3VyRnJvbU5vZGVDaGlsZCkge1xuICAgICAgICAgICAgICBmcm9tTmV4dFNpYmxpbmcgPSBjdXJGcm9tTm9kZUNoaWxkLm5leHRTaWJsaW5nO1xuICAgICAgICAgICAgICBpZiAoY3VyVG9Ob2RlQ2hpbGQuaXNTYW1lTm9kZSAmJiBjdXJUb05vZGVDaGlsZC5pc1NhbWVOb2RlKGN1ckZyb21Ob2RlQ2hpbGQpKSB7XG4gICAgICAgICAgICAgICAgY3VyVG9Ob2RlQ2hpbGQgPSB0b05leHRTaWJsaW5nO1xuICAgICAgICAgICAgICAgIGN1ckZyb21Ob2RlQ2hpbGQgPSBmcm9tTmV4dFNpYmxpbmc7XG4gICAgICAgICAgICAgICAgY29udGludWUgb3V0ZXI7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY3VyRnJvbU5vZGVLZXkgPSBnZXROb2RlS2V5KGN1ckZyb21Ob2RlQ2hpbGQpO1xuICAgICAgICAgICAgICB2YXIgY3VyRnJvbU5vZGVUeXBlID0gY3VyRnJvbU5vZGVDaGlsZC5ub2RlVHlwZTtcbiAgICAgICAgICAgICAgdmFyIGlzQ29tcGF0aWJsZSA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgaWYgKGN1ckZyb21Ob2RlVHlwZSA9PT0gY3VyVG9Ob2RlQ2hpbGQubm9kZVR5cGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoY3VyRnJvbU5vZGVUeXBlID09PSBFTEVNRU5UX05PREUpIHtcbiAgICAgICAgICAgICAgICAgIGlmIChjdXJUb05vZGVLZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGN1clRvTm9kZUtleSAhPT0gY3VyRnJvbU5vZGVLZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICBpZiAobWF0Y2hpbmdGcm9tRWwgPSBmcm9tTm9kZXNMb29rdXBbY3VyVG9Ob2RlS2V5XSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZyb21OZXh0U2libGluZyA9PT0gbWF0Y2hpbmdGcm9tRWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgaXNDb21wYXRpYmxlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBmcm9tRWwuaW5zZXJ0QmVmb3JlKG1hdGNoaW5nRnJvbUVsLCBjdXJGcm9tTm9kZUNoaWxkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN1ckZyb21Ob2RlS2V5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkS2V5ZWRSZW1vdmFsKGN1ckZyb21Ob2RlS2V5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZW1vdmVOb2RlKGN1ckZyb21Ob2RlQ2hpbGQsIGZyb21FbCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgY3VyRnJvbU5vZGVDaGlsZCA9IG1hdGNoaW5nRnJvbUVsO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpc0NvbXBhdGlibGUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY3VyRnJvbU5vZGVLZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgaXNDb21wYXRpYmxlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBpc0NvbXBhdGlibGUgPSBpc0NvbXBhdGlibGUgIT09IGZhbHNlICYmIGNvbXBhcmVOb2RlTmFtZXMoY3VyRnJvbU5vZGVDaGlsZCwgY3VyVG9Ob2RlQ2hpbGQpO1xuICAgICAgICAgICAgICAgICAgaWYgKGlzQ29tcGF0aWJsZSkge1xuICAgICAgICAgICAgICAgICAgICBtb3JwaEVsKGN1ckZyb21Ob2RlQ2hpbGQsIGN1clRvTm9kZUNoaWxkKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGN1ckZyb21Ob2RlVHlwZSA9PT0gVEVYVF9OT0RFIHx8IGN1ckZyb21Ob2RlVHlwZSA9PSBDT01NRU5UX05PREUpIHtcbiAgICAgICAgICAgICAgICAgIGlzQ29tcGF0aWJsZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICBpZiAoY3VyRnJvbU5vZGVDaGlsZC5ub2RlVmFsdWUgIT09IGN1clRvTm9kZUNoaWxkLm5vZGVWYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBjdXJGcm9tTm9kZUNoaWxkLm5vZGVWYWx1ZSA9IGN1clRvTm9kZUNoaWxkLm5vZGVWYWx1ZTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKGlzQ29tcGF0aWJsZSkge1xuICAgICAgICAgICAgICAgIGN1clRvTm9kZUNoaWxkID0gdG9OZXh0U2libGluZztcbiAgICAgICAgICAgICAgICBjdXJGcm9tTm9kZUNoaWxkID0gZnJvbU5leHRTaWJsaW5nO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlIG91dGVyO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChjdXJGcm9tTm9kZUtleSkge1xuICAgICAgICAgICAgICAgIGFkZEtleWVkUmVtb3ZhbChjdXJGcm9tTm9kZUtleSk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVtb3ZlTm9kZShjdXJGcm9tTm9kZUNoaWxkLCBmcm9tRWwsIHRydWUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGN1ckZyb21Ob2RlQ2hpbGQgPSBmcm9tTmV4dFNpYmxpbmc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY3VyVG9Ob2RlS2V5ICYmIChtYXRjaGluZ0Zyb21FbCA9IGZyb21Ob2Rlc0xvb2t1cFtjdXJUb05vZGVLZXldKSAmJiBjb21wYXJlTm9kZU5hbWVzKG1hdGNoaW5nRnJvbUVsLCBjdXJUb05vZGVDaGlsZCkpIHtcbiAgICAgICAgICAgICAgZnJvbUVsLmFwcGVuZENoaWxkKG1hdGNoaW5nRnJvbUVsKTtcbiAgICAgICAgICAgICAgbW9ycGhFbChtYXRjaGluZ0Zyb21FbCwgY3VyVG9Ob2RlQ2hpbGQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdmFyIG9uQmVmb3JlTm9kZUFkZGVkUmVzdWx0ID0gb25CZWZvcmVOb2RlQWRkZWQoY3VyVG9Ob2RlQ2hpbGQpO1xuICAgICAgICAgICAgICBpZiAob25CZWZvcmVOb2RlQWRkZWRSZXN1bHQgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgaWYgKG9uQmVmb3JlTm9kZUFkZGVkUmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICBjdXJUb05vZGVDaGlsZCA9IG9uQmVmb3JlTm9kZUFkZGVkUmVzdWx0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoY3VyVG9Ob2RlQ2hpbGQuYWN0dWFsaXplKSB7XG4gICAgICAgICAgICAgICAgICBjdXJUb05vZGVDaGlsZCA9IGN1clRvTm9kZUNoaWxkLmFjdHVhbGl6ZShmcm9tRWwub3duZXJEb2N1bWVudCB8fCBkb2MpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmcm9tRWwuYXBwZW5kQ2hpbGQoY3VyVG9Ob2RlQ2hpbGQpO1xuICAgICAgICAgICAgICAgIGhhbmRsZU5vZGVBZGRlZChjdXJUb05vZGVDaGlsZCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN1clRvTm9kZUNoaWxkID0gdG9OZXh0U2libGluZztcbiAgICAgICAgICAgIGN1ckZyb21Ob2RlQ2hpbGQgPSBmcm9tTmV4dFNpYmxpbmc7XG4gICAgICAgICAgfVxuICAgICAgICBjbGVhbnVwRnJvbUVsKGZyb21FbCwgY3VyRnJvbU5vZGVDaGlsZCwgY3VyRnJvbU5vZGVLZXkpO1xuICAgICAgICB2YXIgc3BlY2lhbEVsSGFuZGxlciA9IHNwZWNpYWxFbEhhbmRsZXJzW2Zyb21FbC5ub2RlTmFtZV07XG4gICAgICAgIGlmIChzcGVjaWFsRWxIYW5kbGVyKSB7XG4gICAgICAgICAgc3BlY2lhbEVsSGFuZGxlcihmcm9tRWwsIHRvRWwpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2YXIgbW9ycGhlZE5vZGUgPSBmcm9tTm9kZTtcbiAgICAgIHZhciBtb3JwaGVkTm9kZVR5cGUgPSBtb3JwaGVkTm9kZS5ub2RlVHlwZTtcbiAgICAgIHZhciB0b05vZGVUeXBlID0gdG9Ob2RlLm5vZGVUeXBlO1xuICAgICAgaWYgKCFjaGlsZHJlbk9ubHkpIHtcbiAgICAgICAgaWYgKG1vcnBoZWROb2RlVHlwZSA9PT0gRUxFTUVOVF9OT0RFKSB7XG4gICAgICAgICAgaWYgKHRvTm9kZVR5cGUgPT09IEVMRU1FTlRfTk9ERSkge1xuICAgICAgICAgICAgaWYgKCFjb21wYXJlTm9kZU5hbWVzKGZyb21Ob2RlLCB0b05vZGUpKSB7XG4gICAgICAgICAgICAgIG9uTm9kZURpc2NhcmRlZChmcm9tTm9kZSk7XG4gICAgICAgICAgICAgIG1vcnBoZWROb2RlID0gbW92ZUNoaWxkcmVuKGZyb21Ob2RlLCBjcmVhdGVFbGVtZW50TlModG9Ob2RlLm5vZGVOYW1lLCB0b05vZGUubmFtZXNwYWNlVVJJKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG1vcnBoZWROb2RlID0gdG9Ob2RlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChtb3JwaGVkTm9kZVR5cGUgPT09IFRFWFRfTk9ERSB8fCBtb3JwaGVkTm9kZVR5cGUgPT09IENPTU1FTlRfTk9ERSkge1xuICAgICAgICAgIGlmICh0b05vZGVUeXBlID09PSBtb3JwaGVkTm9kZVR5cGUpIHtcbiAgICAgICAgICAgIGlmIChtb3JwaGVkTm9kZS5ub2RlVmFsdWUgIT09IHRvTm9kZS5ub2RlVmFsdWUpIHtcbiAgICAgICAgICAgICAgbW9ycGhlZE5vZGUubm9kZVZhbHVlID0gdG9Ob2RlLm5vZGVWYWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBtb3JwaGVkTm9kZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbW9ycGhlZE5vZGUgPSB0b05vZGU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAobW9ycGhlZE5vZGUgPT09IHRvTm9kZSkge1xuICAgICAgICBvbk5vZGVEaXNjYXJkZWQoZnJvbU5vZGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHRvTm9kZS5pc1NhbWVOb2RlICYmIHRvTm9kZS5pc1NhbWVOb2RlKG1vcnBoZWROb2RlKSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBtb3JwaEVsKG1vcnBoZWROb2RlLCB0b05vZGUsIGNoaWxkcmVuT25seSk7XG4gICAgICAgIGlmIChrZXllZFJlbW92YWxMaXN0KSB7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGtleWVkUmVtb3ZhbExpc3QubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBlbFRvUmVtb3ZlID0gZnJvbU5vZGVzTG9va3VwW2tleWVkUmVtb3ZhbExpc3RbaV1dO1xuICAgICAgICAgICAgaWYgKGVsVG9SZW1vdmUpIHtcbiAgICAgICAgICAgICAgcmVtb3ZlTm9kZShlbFRvUmVtb3ZlLCBlbFRvUmVtb3ZlLnBhcmVudE5vZGUsIGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICghY2hpbGRyZW5Pbmx5ICYmIG1vcnBoZWROb2RlICE9PSBmcm9tTm9kZSAmJiBmcm9tTm9kZS5wYXJlbnROb2RlKSB7XG4gICAgICAgIGlmIChtb3JwaGVkTm9kZS5hY3R1YWxpemUpIHtcbiAgICAgICAgICBtb3JwaGVkTm9kZSA9IG1vcnBoZWROb2RlLmFjdHVhbGl6ZShmcm9tTm9kZS5vd25lckRvY3VtZW50IHx8IGRvYyk7XG4gICAgICAgIH1cbiAgICAgICAgZnJvbU5vZGUucGFyZW50Tm9kZS5yZXBsYWNlQ2hpbGQobW9ycGhlZE5vZGUsIGZyb21Ob2RlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBtb3JwaGVkTm9kZTtcbiAgICB9O1xuICB9XG4gIHZhciBtb3JwaGRvbSA9IG1vcnBoZG9tRmFjdG9yeShtb3JwaEF0dHJzKTtcbiAgdmFyIG1vcnBoZG9tX2VzbV9kZWZhdWx0ID0gbW9ycGhkb207XG5cbiAgLy8ganMvcGhvZW5peF9saXZlX3ZpZXcvZG9tX3BhdGNoLmpzXG4gIHZhciBET01QYXRjaCA9IGNsYXNzIHtcbiAgICBzdGF0aWMgcGF0Y2hFbChmcm9tRWwsIHRvRWwsIGFjdGl2ZUVsZW1lbnQpIHtcbiAgICAgIG1vcnBoZG9tX2VzbV9kZWZhdWx0KGZyb21FbCwgdG9FbCwge1xuICAgICAgICBjaGlsZHJlbk9ubHk6IGZhbHNlLFxuICAgICAgICBvbkJlZm9yZUVsVXBkYXRlZDogKGZyb21FbDIsIHRvRWwyKSA9PiB7XG4gICAgICAgICAgaWYgKGFjdGl2ZUVsZW1lbnQgJiYgYWN0aXZlRWxlbWVudC5pc1NhbWVOb2RlKGZyb21FbDIpICYmIGRvbV9kZWZhdWx0LmlzRm9ybUlucHV0KGZyb21FbDIpKSB7XG4gICAgICAgICAgICBkb21fZGVmYXVsdC5tZXJnZUZvY3VzZWRJbnB1dChmcm9tRWwyLCB0b0VsMik7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgY29uc3RydWN0b3IodmlldywgY29udGFpbmVyLCBpZCwgaHRtbCwgdGFyZ2V0Q0lEKSB7XG4gICAgICB0aGlzLnZpZXcgPSB2aWV3O1xuICAgICAgdGhpcy5saXZlU29ja2V0ID0gdmlldy5saXZlU29ja2V0O1xuICAgICAgdGhpcy5jb250YWluZXIgPSBjb250YWluZXI7XG4gICAgICB0aGlzLmlkID0gaWQ7XG4gICAgICB0aGlzLnJvb3RJRCA9IHZpZXcucm9vdC5pZDtcbiAgICAgIHRoaXMuaHRtbCA9IGh0bWw7XG4gICAgICB0aGlzLnRhcmdldENJRCA9IHRhcmdldENJRDtcbiAgICAgIHRoaXMuY2lkUGF0Y2ggPSBpc0NpZCh0aGlzLnRhcmdldENJRCk7XG4gICAgICB0aGlzLmNhbGxiYWNrcyA9IHtcbiAgICAgICAgYmVmb3JlYWRkZWQ6IFtdLFxuICAgICAgICBiZWZvcmV1cGRhdGVkOiBbXSxcbiAgICAgICAgYmVmb3JlcGh4Q2hpbGRBZGRlZDogW10sXG4gICAgICAgIGFmdGVyYWRkZWQ6IFtdLFxuICAgICAgICBhZnRlcnVwZGF0ZWQ6IFtdLFxuICAgICAgICBhZnRlcmRpc2NhcmRlZDogW10sXG4gICAgICAgIGFmdGVycGh4Q2hpbGRBZGRlZDogW10sXG4gICAgICAgIGFmdGVydHJhbnNpdGlvbnNEaXNjYXJkZWQ6IFtdXG4gICAgICB9O1xuICAgIH1cbiAgICBiZWZvcmUoa2luZCwgY2FsbGJhY2spIHtcbiAgICAgIHRoaXMuY2FsbGJhY2tzW2BiZWZvcmUke2tpbmR9YF0ucHVzaChjYWxsYmFjayk7XG4gICAgfVxuICAgIGFmdGVyKGtpbmQsIGNhbGxiYWNrKSB7XG4gICAgICB0aGlzLmNhbGxiYWNrc1tgYWZ0ZXIke2tpbmR9YF0ucHVzaChjYWxsYmFjayk7XG4gICAgfVxuICAgIHRyYWNrQmVmb3JlKGtpbmQsIC4uLmFyZ3MpIHtcbiAgICAgIHRoaXMuY2FsbGJhY2tzW2BiZWZvcmUke2tpbmR9YF0uZm9yRWFjaCgoY2FsbGJhY2spID0+IGNhbGxiYWNrKC4uLmFyZ3MpKTtcbiAgICB9XG4gICAgdHJhY2tBZnRlcihraW5kLCAuLi5hcmdzKSB7XG4gICAgICB0aGlzLmNhbGxiYWNrc1tgYWZ0ZXIke2tpbmR9YF0uZm9yRWFjaCgoY2FsbGJhY2spID0+IGNhbGxiYWNrKC4uLmFyZ3MpKTtcbiAgICB9XG4gICAgbWFya1BydW5hYmxlQ29udGVudEZvclJlbW92YWwoKSB7XG4gICAgICBkb21fZGVmYXVsdC5hbGwodGhpcy5jb250YWluZXIsIFwiW3BoeC11cGRhdGU9YXBwZW5kXSA+ICosIFtwaHgtdXBkYXRlPXByZXBlbmRdID4gKlwiLCAoZWwpID0+IHtcbiAgICAgICAgZWwuc2V0QXR0cmlidXRlKFBIWF9QUlVORSwgXCJcIik7XG4gICAgICB9KTtcbiAgICB9XG4gICAgcGVyZm9ybSgpIHtcbiAgICAgIGxldCB7IHZpZXcsIGxpdmVTb2NrZXQsIGNvbnRhaW5lciwgaHRtbCB9ID0gdGhpcztcbiAgICAgIGxldCB0YXJnZXRDb250YWluZXIgPSB0aGlzLmlzQ0lEUGF0Y2goKSA/IHRoaXMudGFyZ2V0Q0lEQ29udGFpbmVyKGh0bWwpIDogY29udGFpbmVyO1xuICAgICAgaWYgKHRoaXMuaXNDSURQYXRjaCgpICYmICF0YXJnZXRDb250YWluZXIpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgbGV0IGZvY3VzZWQgPSBsaXZlU29ja2V0LmdldEFjdGl2ZUVsZW1lbnQoKTtcbiAgICAgIGxldCB7IHNlbGVjdGlvblN0YXJ0LCBzZWxlY3Rpb25FbmQgfSA9IGZvY3VzZWQgJiYgZG9tX2RlZmF1bHQuaGFzU2VsZWN0aW9uUmFuZ2UoZm9jdXNlZCkgPyBmb2N1c2VkIDoge307XG4gICAgICBsZXQgcGh4VXBkYXRlID0gbGl2ZVNvY2tldC5iaW5kaW5nKFBIWF9VUERBVEUpO1xuICAgICAgbGV0IHBoeEZlZWRiYWNrRm9yID0gbGl2ZVNvY2tldC5iaW5kaW5nKFBIWF9GRUVEQkFDS19GT1IpO1xuICAgICAgbGV0IGRpc2FibGVXaXRoID0gbGl2ZVNvY2tldC5iaW5kaW5nKFBIWF9ESVNBQkxFX1dJVEgpO1xuICAgICAgbGV0IHBoeFRyaWdnZXJFeHRlcm5hbCA9IGxpdmVTb2NrZXQuYmluZGluZyhQSFhfVFJJR0dFUl9BQ1RJT04pO1xuICAgICAgbGV0IHBoeFJlbW92ZSA9IGxpdmVTb2NrZXQuYmluZGluZyhcInJlbW92ZVwiKTtcbiAgICAgIGxldCBhZGRlZCA9IFtdO1xuICAgICAgbGV0IHVwZGF0ZXMgPSBbXTtcbiAgICAgIGxldCBhcHBlbmRQcmVwZW5kVXBkYXRlcyA9IFtdO1xuICAgICAgbGV0IHBlbmRpbmdSZW1vdmVzID0gW107XG4gICAgICBsZXQgZXh0ZXJuYWxGb3JtVHJpZ2dlcmVkID0gbnVsbDtcbiAgICAgIGxldCBkaWZmSFRNTCA9IGxpdmVTb2NrZXQudGltZShcInByZW1vcnBoIGNvbnRhaW5lciBwcmVwXCIsICgpID0+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYnVpbGREaWZmSFRNTChjb250YWluZXIsIGh0bWwsIHBoeFVwZGF0ZSwgdGFyZ2V0Q29udGFpbmVyKTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy50cmFja0JlZm9yZShcImFkZGVkXCIsIGNvbnRhaW5lcik7XG4gICAgICB0aGlzLnRyYWNrQmVmb3JlKFwidXBkYXRlZFwiLCBjb250YWluZXIsIGNvbnRhaW5lcik7XG4gICAgICBsaXZlU29ja2V0LnRpbWUoXCJtb3JwaGRvbVwiLCAoKSA9PiB7XG4gICAgICAgIG1vcnBoZG9tX2VzbV9kZWZhdWx0KHRhcmdldENvbnRhaW5lciwgZGlmZkhUTUwsIHtcbiAgICAgICAgICBjaGlsZHJlbk9ubHk6IHRhcmdldENvbnRhaW5lci5nZXRBdHRyaWJ1dGUoUEhYX0NPTVBPTkVOVCkgPT09IG51bGwsXG4gICAgICAgICAgZ2V0Tm9kZUtleTogKG5vZGUpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBkb21fZGVmYXVsdC5pc1BoeERlc3Ryb3llZChub2RlKSA/IG51bGwgOiBub2RlLmlkO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgb25CZWZvcmVOb2RlQWRkZWQ6IChlbCkgPT4ge1xuICAgICAgICAgICAgdGhpcy50cmFja0JlZm9yZShcImFkZGVkXCIsIGVsKTtcbiAgICAgICAgICAgIHJldHVybiBlbDtcbiAgICAgICAgICB9LFxuICAgICAgICAgIG9uTm9kZUFkZGVkOiAoZWwpID0+IHtcbiAgICAgICAgICAgIGlmIChlbCBpbnN0YW5jZW9mIEhUTUxJbWFnZUVsZW1lbnQgJiYgZWwuc3Jjc2V0KSB7XG4gICAgICAgICAgICAgIGVsLnNyY3NldCA9IGVsLnNyY3NldDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZWwgaW5zdGFuY2VvZiBIVE1MVmlkZW9FbGVtZW50ICYmIGVsLmF1dG9wbGF5KSB7XG4gICAgICAgICAgICAgIGVsLnBsYXkoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkb21fZGVmYXVsdC5pc05vd1RyaWdnZXJGb3JtRXh0ZXJuYWwoZWwsIHBoeFRyaWdnZXJFeHRlcm5hbCkpIHtcbiAgICAgICAgICAgICAgZXh0ZXJuYWxGb3JtVHJpZ2dlcmVkID0gZWw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkb21fZGVmYXVsdC5kaXNjYXJkRXJyb3IodGFyZ2V0Q29udGFpbmVyLCBlbCwgcGh4RmVlZGJhY2tGb3IpO1xuICAgICAgICAgICAgaWYgKGRvbV9kZWZhdWx0LmlzUGh4Q2hpbGQoZWwpICYmIHZpZXcub3duc0VsZW1lbnQoZWwpKSB7XG4gICAgICAgICAgICAgIHRoaXMudHJhY2tBZnRlcihcInBoeENoaWxkQWRkZWRcIiwgZWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYWRkZWQucHVzaChlbCk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBvbk5vZGVEaXNjYXJkZWQ6IChlbCkgPT4ge1xuICAgICAgICAgICAgaWYgKGRvbV9kZWZhdWx0LmlzUGh4Q2hpbGQoZWwpKSB7XG4gICAgICAgICAgICAgIGxpdmVTb2NrZXQuZGVzdHJveVZpZXdCeUVsKGVsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMudHJhY2tBZnRlcihcImRpc2NhcmRlZFwiLCBlbCk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBvbkJlZm9yZU5vZGVEaXNjYXJkZWQ6IChlbCkgPT4ge1xuICAgICAgICAgICAgaWYgKGVsLmdldEF0dHJpYnV0ZSAmJiBlbC5nZXRBdHRyaWJ1dGUoUEhYX1BSVU5FKSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChlbC5wYXJlbnROb2RlICE9PSBudWxsICYmIGRvbV9kZWZhdWx0LmlzUGh4VXBkYXRlKGVsLnBhcmVudE5vZGUsIHBoeFVwZGF0ZSwgW1wiYXBwZW5kXCIsIFwicHJlcGVuZFwiXSkgJiYgZWwuaWQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGVsLmdldEF0dHJpYnV0ZSAmJiBlbC5nZXRBdHRyaWJ1dGUocGh4UmVtb3ZlKSkge1xuICAgICAgICAgICAgICBwZW5kaW5nUmVtb3Zlcy5wdXNoKGVsKTtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuc2tpcENJRFNpYmxpbmcoZWwpKSB7XG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgb25FbFVwZGF0ZWQ6IChlbCkgPT4ge1xuICAgICAgICAgICAgaWYgKGRvbV9kZWZhdWx0LmlzTm93VHJpZ2dlckZvcm1FeHRlcm5hbChlbCwgcGh4VHJpZ2dlckV4dGVybmFsKSkge1xuICAgICAgICAgICAgICBleHRlcm5hbEZvcm1UcmlnZ2VyZWQgPSBlbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHVwZGF0ZXMucHVzaChlbCk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBvbkJlZm9yZUVsVXBkYXRlZDogKGZyb21FbCwgdG9FbCkgPT4ge1xuICAgICAgICAgICAgZG9tX2RlZmF1bHQuY2xlYW5DaGlsZE5vZGVzKHRvRWwsIHBoeFVwZGF0ZSk7XG4gICAgICAgICAgICBpZiAodGhpcy5za2lwQ0lEU2libGluZyh0b0VsKSkge1xuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZG9tX2RlZmF1bHQuaXNJZ25vcmVkKGZyb21FbCwgcGh4VXBkYXRlKSkge1xuICAgICAgICAgICAgICB0aGlzLnRyYWNrQmVmb3JlKFwidXBkYXRlZFwiLCBmcm9tRWwsIHRvRWwpO1xuICAgICAgICAgICAgICBkb21fZGVmYXVsdC5tZXJnZUF0dHJzKGZyb21FbCwgdG9FbCwgeyBpc0lnbm9yZWQ6IHRydWUgfSk7XG4gICAgICAgICAgICAgIHVwZGF0ZXMucHVzaChmcm9tRWwpO1xuICAgICAgICAgICAgICBkb21fZGVmYXVsdC5hcHBseVN0aWNreU9wZXJhdGlvbnMoZnJvbUVsKTtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGZyb21FbC50eXBlID09PSBcIm51bWJlclwiICYmIChmcm9tRWwudmFsaWRpdHkgJiYgZnJvbUVsLnZhbGlkaXR5LmJhZElucHV0KSkge1xuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWRvbV9kZWZhdWx0LnN5bmNQZW5kaW5nUmVmKGZyb21FbCwgdG9FbCwgZGlzYWJsZVdpdGgpKSB7XG4gICAgICAgICAgICAgIGlmIChkb21fZGVmYXVsdC5pc1VwbG9hZElucHV0KGZyb21FbCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRyYWNrQmVmb3JlKFwidXBkYXRlZFwiLCBmcm9tRWwsIHRvRWwpO1xuICAgICAgICAgICAgICAgIHVwZGF0ZXMucHVzaChmcm9tRWwpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGRvbV9kZWZhdWx0LmFwcGx5U3RpY2t5T3BlcmF0aW9ucyhmcm9tRWwpO1xuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZG9tX2RlZmF1bHQuaXNQaHhDaGlsZCh0b0VsKSkge1xuICAgICAgICAgICAgICBsZXQgcHJldlNlc3Npb24gPSBmcm9tRWwuZ2V0QXR0cmlidXRlKFBIWF9TRVNTSU9OKTtcbiAgICAgICAgICAgICAgZG9tX2RlZmF1bHQubWVyZ2VBdHRycyhmcm9tRWwsIHRvRWwsIHsgZXhjbHVkZTogW1BIWF9TVEFUSUNdIH0pO1xuICAgICAgICAgICAgICBpZiAocHJldlNlc3Npb24gIT09IFwiXCIpIHtcbiAgICAgICAgICAgICAgICBmcm9tRWwuc2V0QXR0cmlidXRlKFBIWF9TRVNTSU9OLCBwcmV2U2Vzc2lvbik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZnJvbUVsLnNldEF0dHJpYnV0ZShQSFhfUk9PVF9JRCwgdGhpcy5yb290SUQpO1xuICAgICAgICAgICAgICBkb21fZGVmYXVsdC5hcHBseVN0aWNreU9wZXJhdGlvbnMoZnJvbUVsKTtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZG9tX2RlZmF1bHQuY29weVByaXZhdGVzKHRvRWwsIGZyb21FbCk7XG4gICAgICAgICAgICBkb21fZGVmYXVsdC5kaXNjYXJkRXJyb3IodGFyZ2V0Q29udGFpbmVyLCB0b0VsLCBwaHhGZWVkYmFja0Zvcik7XG4gICAgICAgICAgICBsZXQgaXNGb2N1c2VkRm9ybUVsID0gZm9jdXNlZCAmJiBmcm9tRWwuaXNTYW1lTm9kZShmb2N1c2VkKSAmJiBkb21fZGVmYXVsdC5pc0Zvcm1JbnB1dChmcm9tRWwpO1xuICAgICAgICAgICAgaWYgKGlzRm9jdXNlZEZvcm1FbCkge1xuICAgICAgICAgICAgICB0aGlzLnRyYWNrQmVmb3JlKFwidXBkYXRlZFwiLCBmcm9tRWwsIHRvRWwpO1xuICAgICAgICAgICAgICBkb21fZGVmYXVsdC5tZXJnZUZvY3VzZWRJbnB1dChmcm9tRWwsIHRvRWwpO1xuICAgICAgICAgICAgICBkb21fZGVmYXVsdC5zeW5jQXR0cnNUb1Byb3BzKGZyb21FbCk7XG4gICAgICAgICAgICAgIHVwZGF0ZXMucHVzaChmcm9tRWwpO1xuICAgICAgICAgICAgICBkb21fZGVmYXVsdC5hcHBseVN0aWNreU9wZXJhdGlvbnMoZnJvbUVsKTtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgaWYgKGRvbV9kZWZhdWx0LmlzUGh4VXBkYXRlKHRvRWwsIHBoeFVwZGF0ZSwgW1wiYXBwZW5kXCIsIFwicHJlcGVuZFwiXSkpIHtcbiAgICAgICAgICAgICAgICBhcHBlbmRQcmVwZW5kVXBkYXRlcy5wdXNoKG5ldyBET01Qb3N0TW9ycGhSZXN0b3Jlcihmcm9tRWwsIHRvRWwsIHRvRWwuZ2V0QXR0cmlidXRlKHBoeFVwZGF0ZSkpKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBkb21fZGVmYXVsdC5zeW5jQXR0cnNUb1Byb3BzKHRvRWwpO1xuICAgICAgICAgICAgICBkb21fZGVmYXVsdC5hcHBseVN0aWNreU9wZXJhdGlvbnModG9FbCk7XG4gICAgICAgICAgICAgIHRoaXMudHJhY2tCZWZvcmUoXCJ1cGRhdGVkXCIsIGZyb21FbCwgdG9FbCk7XG4gICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICAgIGlmIChsaXZlU29ja2V0LmlzRGVidWdFbmFibGVkKCkpIHtcbiAgICAgICAgZGV0ZWN0RHVwbGljYXRlSWRzKCk7XG4gICAgICB9XG4gICAgICBpZiAoYXBwZW5kUHJlcGVuZFVwZGF0ZXMubGVuZ3RoID4gMCkge1xuICAgICAgICBsaXZlU29ja2V0LnRpbWUoXCJwb3N0LW1vcnBoIGFwcGVuZC9wcmVwZW5kIHJlc3RvcmF0aW9uXCIsICgpID0+IHtcbiAgICAgICAgICBhcHBlbmRQcmVwZW5kVXBkYXRlcy5mb3JFYWNoKCh1cGRhdGUpID0+IHVwZGF0ZS5wZXJmb3JtKCkpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGxpdmVTb2NrZXQuc2lsZW5jZUV2ZW50cygoKSA9PiBkb21fZGVmYXVsdC5yZXN0b3JlRm9jdXMoZm9jdXNlZCwgc2VsZWN0aW9uU3RhcnQsIHNlbGVjdGlvbkVuZCkpO1xuICAgICAgZG9tX2RlZmF1bHQuZGlzcGF0Y2hFdmVudChkb2N1bWVudCwgXCJwaHg6dXBkYXRlXCIpO1xuICAgICAgYWRkZWQuZm9yRWFjaCgoZWwpID0+IHRoaXMudHJhY2tBZnRlcihcImFkZGVkXCIsIGVsKSk7XG4gICAgICB1cGRhdGVzLmZvckVhY2goKGVsKSA9PiB0aGlzLnRyYWNrQWZ0ZXIoXCJ1cGRhdGVkXCIsIGVsKSk7XG4gICAgICBpZiAocGVuZGluZ1JlbW92ZXMubGVuZ3RoID4gMCkge1xuICAgICAgICBsaXZlU29ja2V0LnRyYW5zaXRpb25SZW1vdmVzKHBlbmRpbmdSZW1vdmVzKTtcbiAgICAgICAgbGl2ZVNvY2tldC5yZXF1ZXN0RE9NVXBkYXRlKCgpID0+IHtcbiAgICAgICAgICBwZW5kaW5nUmVtb3Zlcy5mb3JFYWNoKChlbCkgPT4ge1xuICAgICAgICAgICAgbGV0IGNoaWxkID0gZG9tX2RlZmF1bHQuZmlyc3RQaHhDaGlsZChlbCk7XG4gICAgICAgICAgICBpZiAoY2hpbGQpIHtcbiAgICAgICAgICAgICAgbGl2ZVNvY2tldC5kZXN0cm95Vmlld0J5RWwoY2hpbGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWwucmVtb3ZlKCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdGhpcy50cmFja0FmdGVyKFwidHJhbnNpdGlvbnNEaXNjYXJkZWRcIiwgcGVuZGluZ1JlbW92ZXMpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmIChleHRlcm5hbEZvcm1UcmlnZ2VyZWQpIHtcbiAgICAgICAgbGl2ZVNvY2tldC5kaXNjb25uZWN0KCk7XG4gICAgICAgIGV4dGVybmFsRm9ybVRyaWdnZXJlZC5zdWJtaXQoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpc0NJRFBhdGNoKCkge1xuICAgICAgcmV0dXJuIHRoaXMuY2lkUGF0Y2g7XG4gICAgfVxuICAgIHNraXBDSURTaWJsaW5nKGVsKSB7XG4gICAgICByZXR1cm4gZWwubm9kZVR5cGUgPT09IE5vZGUuRUxFTUVOVF9OT0RFICYmIGVsLmdldEF0dHJpYnV0ZShQSFhfU0tJUCkgIT09IG51bGw7XG4gICAgfVxuICAgIHRhcmdldENJRENvbnRhaW5lcihodG1sKSB7XG4gICAgICBpZiAoIXRoaXMuaXNDSURQYXRjaCgpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGxldCBbZmlyc3QsIC4uLnJlc3RdID0gZG9tX2RlZmF1bHQuZmluZENvbXBvbmVudE5vZGVMaXN0KHRoaXMuY29udGFpbmVyLCB0aGlzLnRhcmdldENJRCk7XG4gICAgICBpZiAocmVzdC5sZW5ndGggPT09IDAgJiYgZG9tX2RlZmF1bHQuY2hpbGROb2RlTGVuZ3RoKGh0bWwpID09PSAxKSB7XG4gICAgICAgIHJldHVybiBmaXJzdDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBmaXJzdCAmJiBmaXJzdC5wYXJlbnROb2RlO1xuICAgICAgfVxuICAgIH1cbiAgICBidWlsZERpZmZIVE1MKGNvbnRhaW5lciwgaHRtbCwgcGh4VXBkYXRlLCB0YXJnZXRDb250YWluZXIpIHtcbiAgICAgIGxldCBpc0NJRFBhdGNoID0gdGhpcy5pc0NJRFBhdGNoKCk7XG4gICAgICBsZXQgaXNDSURXaXRoU2luZ2xlUm9vdCA9IGlzQ0lEUGF0Y2ggJiYgdGFyZ2V0Q29udGFpbmVyLmdldEF0dHJpYnV0ZShQSFhfQ09NUE9ORU5UKSA9PT0gdGhpcy50YXJnZXRDSUQudG9TdHJpbmcoKTtcbiAgICAgIGlmICghaXNDSURQYXRjaCB8fCBpc0NJRFdpdGhTaW5nbGVSb290KSB7XG4gICAgICAgIHJldHVybiBodG1sO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGV0IGRpZmZDb250YWluZXIgPSBudWxsO1xuICAgICAgICBsZXQgdGVtcGxhdGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwidGVtcGxhdGVcIik7XG4gICAgICAgIGRpZmZDb250YWluZXIgPSBkb21fZGVmYXVsdC5jbG9uZU5vZGUodGFyZ2V0Q29udGFpbmVyKTtcbiAgICAgICAgbGV0IFtmaXJzdENvbXBvbmVudCwgLi4ucmVzdF0gPSBkb21fZGVmYXVsdC5maW5kQ29tcG9uZW50Tm9kZUxpc3QoZGlmZkNvbnRhaW5lciwgdGhpcy50YXJnZXRDSUQpO1xuICAgICAgICB0ZW1wbGF0ZS5pbm5lckhUTUwgPSBodG1sO1xuICAgICAgICByZXN0LmZvckVhY2goKGVsKSA9PiBlbC5yZW1vdmUoKSk7XG4gICAgICAgIEFycmF5LmZyb20oZGlmZkNvbnRhaW5lci5jaGlsZE5vZGVzKS5mb3JFYWNoKChjaGlsZCkgPT4ge1xuICAgICAgICAgIGlmIChjaGlsZC5pZCAmJiBjaGlsZC5ub2RlVHlwZSA9PT0gTm9kZS5FTEVNRU5UX05PREUgJiYgY2hpbGQuZ2V0QXR0cmlidXRlKFBIWF9DT01QT05FTlQpICE9PSB0aGlzLnRhcmdldENJRC50b1N0cmluZygpKSB7XG4gICAgICAgICAgICBjaGlsZC5zZXRBdHRyaWJ1dGUoUEhYX1NLSVAsIFwiXCIpO1xuICAgICAgICAgICAgY2hpbGQuaW5uZXJIVE1MID0gXCJcIjtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBBcnJheS5mcm9tKHRlbXBsYXRlLmNvbnRlbnQuY2hpbGROb2RlcykuZm9yRWFjaCgoZWwpID0+IGRpZmZDb250YWluZXIuaW5zZXJ0QmVmb3JlKGVsLCBmaXJzdENvbXBvbmVudCkpO1xuICAgICAgICBmaXJzdENvbXBvbmVudC5yZW1vdmUoKTtcbiAgICAgICAgcmV0dXJuIGRpZmZDb250YWluZXIub3V0ZXJIVE1MO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvLyBqcy9waG9lbml4X2xpdmVfdmlldy9yZW5kZXJlZC5qc1xuICB2YXIgUmVuZGVyZWQgPSBjbGFzcyB7XG4gICAgc3RhdGljIGV4dHJhY3QoZGlmZikge1xuICAgICAgbGV0IHsgW1JFUExZXTogcmVwbHksIFtFVkVOVFNdOiBldmVudHMsIFtUSVRMRV06IHRpdGxlIH0gPSBkaWZmO1xuICAgICAgZGVsZXRlIGRpZmZbUkVQTFldO1xuICAgICAgZGVsZXRlIGRpZmZbRVZFTlRTXTtcbiAgICAgIGRlbGV0ZSBkaWZmW1RJVExFXTtcbiAgICAgIHJldHVybiB7IGRpZmYsIHRpdGxlLCByZXBseTogcmVwbHkgfHwgbnVsbCwgZXZlbnRzOiBldmVudHMgfHwgW10gfTtcbiAgICB9XG4gICAgY29uc3RydWN0b3Iodmlld0lkLCByZW5kZXJlZCkge1xuICAgICAgdGhpcy52aWV3SWQgPSB2aWV3SWQ7XG4gICAgICB0aGlzLnJlbmRlcmVkID0ge307XG4gICAgICB0aGlzLm1lcmdlRGlmZihyZW5kZXJlZCk7XG4gICAgfVxuICAgIHBhcmVudFZpZXdJZCgpIHtcbiAgICAgIHJldHVybiB0aGlzLnZpZXdJZDtcbiAgICB9XG4gICAgdG9TdHJpbmcob25seUNpZHMpIHtcbiAgICAgIHJldHVybiB0aGlzLnJlY3Vyc2l2ZVRvU3RyaW5nKHRoaXMucmVuZGVyZWQsIHRoaXMucmVuZGVyZWRbQ09NUE9ORU5UU10sIG9ubHlDaWRzKTtcbiAgICB9XG4gICAgcmVjdXJzaXZlVG9TdHJpbmcocmVuZGVyZWQsIGNvbXBvbmVudHMgPSByZW5kZXJlZFtDT01QT05FTlRTXSwgb25seUNpZHMpIHtcbiAgICAgIG9ubHlDaWRzID0gb25seUNpZHMgPyBuZXcgU2V0KG9ubHlDaWRzKSA6IG51bGw7XG4gICAgICBsZXQgb3V0cHV0ID0geyBidWZmZXI6IFwiXCIsIGNvbXBvbmVudHMsIG9ubHlDaWRzIH07XG4gICAgICB0aGlzLnRvT3V0cHV0QnVmZmVyKHJlbmRlcmVkLCBudWxsLCBvdXRwdXQpO1xuICAgICAgcmV0dXJuIG91dHB1dC5idWZmZXI7XG4gICAgfVxuICAgIGNvbXBvbmVudENJRHMoZGlmZikge1xuICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKGRpZmZbQ09NUE9ORU5UU10gfHwge30pLm1hcCgoaSkgPT4gcGFyc2VJbnQoaSkpO1xuICAgIH1cbiAgICBpc0NvbXBvbmVudE9ubHlEaWZmKGRpZmYpIHtcbiAgICAgIGlmICghZGlmZltDT01QT05FTlRTXSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICByZXR1cm4gT2JqZWN0LmtleXMoZGlmZikubGVuZ3RoID09PSAxO1xuICAgIH1cbiAgICBnZXRDb21wb25lbnQoZGlmZiwgY2lkKSB7XG4gICAgICByZXR1cm4gZGlmZltDT01QT05FTlRTXVtjaWRdO1xuICAgIH1cbiAgICBtZXJnZURpZmYoZGlmZikge1xuICAgICAgbGV0IG5ld2MgPSBkaWZmW0NPTVBPTkVOVFNdO1xuICAgICAgbGV0IGNhY2hlID0ge307XG4gICAgICBkZWxldGUgZGlmZltDT01QT05FTlRTXTtcbiAgICAgIHRoaXMucmVuZGVyZWQgPSB0aGlzLm11dGFibGVNZXJnZSh0aGlzLnJlbmRlcmVkLCBkaWZmKTtcbiAgICAgIHRoaXMucmVuZGVyZWRbQ09NUE9ORU5UU10gPSB0aGlzLnJlbmRlcmVkW0NPTVBPTkVOVFNdIHx8IHt9O1xuICAgICAgaWYgKG5ld2MpIHtcbiAgICAgICAgbGV0IG9sZGMgPSB0aGlzLnJlbmRlcmVkW0NPTVBPTkVOVFNdO1xuICAgICAgICBmb3IgKGxldCBjaWQgaW4gbmV3Yykge1xuICAgICAgICAgIG5ld2NbY2lkXSA9IHRoaXMuY2FjaGVkRmluZENvbXBvbmVudChjaWQsIG5ld2NbY2lkXSwgb2xkYywgbmV3YywgY2FjaGUpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGNpZCBpbiBuZXdjKSB7XG4gICAgICAgICAgb2xkY1tjaWRdID0gbmV3Y1tjaWRdO1xuICAgICAgICB9XG4gICAgICAgIGRpZmZbQ09NUE9ORU5UU10gPSBuZXdjO1xuICAgICAgfVxuICAgIH1cbiAgICBjYWNoZWRGaW5kQ29tcG9uZW50KGNpZCwgY2RpZmYsIG9sZGMsIG5ld2MsIGNhY2hlKSB7XG4gICAgICBpZiAoY2FjaGVbY2lkXSkge1xuICAgICAgICByZXR1cm4gY2FjaGVbY2lkXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxldCBuZGlmZiwgc3RhdCwgc2NpZCA9IGNkaWZmW1NUQVRJQ107XG4gICAgICAgIGlmIChpc0NpZChzY2lkKSkge1xuICAgICAgICAgIGxldCB0ZGlmZjtcbiAgICAgICAgICBpZiAoc2NpZCA+IDApIHtcbiAgICAgICAgICAgIHRkaWZmID0gdGhpcy5jYWNoZWRGaW5kQ29tcG9uZW50KHNjaWQsIG5ld2Nbc2NpZF0sIG9sZGMsIG5ld2MsIGNhY2hlKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGRpZmYgPSBvbGRjWy1zY2lkXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgc3RhdCA9IHRkaWZmW1NUQVRJQ107XG4gICAgICAgICAgbmRpZmYgPSB0aGlzLmNsb25lTWVyZ2UodGRpZmYsIGNkaWZmKTtcbiAgICAgICAgICBuZGlmZltTVEFUSUNdID0gc3RhdDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBuZGlmZiA9IGNkaWZmW1NUQVRJQ10gIT09IHZvaWQgMCA/IGNkaWZmIDogdGhpcy5jbG9uZU1lcmdlKG9sZGNbY2lkXSB8fCB7fSwgY2RpZmYpO1xuICAgICAgICB9XG4gICAgICAgIGNhY2hlW2NpZF0gPSBuZGlmZjtcbiAgICAgICAgcmV0dXJuIG5kaWZmO1xuICAgICAgfVxuICAgIH1cbiAgICBtdXRhYmxlTWVyZ2UodGFyZ2V0LCBzb3VyY2UpIHtcbiAgICAgIGlmIChzb3VyY2VbU1RBVElDXSAhPT0gdm9pZCAwKSB7XG4gICAgICAgIHJldHVybiBzb3VyY2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmRvTXV0YWJsZU1lcmdlKHRhcmdldCwgc291cmNlKTtcbiAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICAgIH1cbiAgICB9XG4gICAgZG9NdXRhYmxlTWVyZ2UodGFyZ2V0LCBzb3VyY2UpIHtcbiAgICAgIGZvciAobGV0IGtleSBpbiBzb3VyY2UpIHtcbiAgICAgICAgbGV0IHZhbCA9IHNvdXJjZVtrZXldO1xuICAgICAgICBsZXQgdGFyZ2V0VmFsID0gdGFyZ2V0W2tleV07XG4gICAgICAgIGlmIChpc09iamVjdCh2YWwpICYmIHZhbFtTVEFUSUNdID09PSB2b2lkIDAgJiYgaXNPYmplY3QodGFyZ2V0VmFsKSkge1xuICAgICAgICAgIHRoaXMuZG9NdXRhYmxlTWVyZ2UodGFyZ2V0VmFsLCB2YWwpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRhcmdldFtrZXldID0gdmFsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGNsb25lTWVyZ2UodGFyZ2V0LCBzb3VyY2UpIHtcbiAgICAgIGxldCBtZXJnZWQgPSBfX3NwcmVhZFZhbHVlcyhfX3NwcmVhZFZhbHVlcyh7fSwgdGFyZ2V0KSwgc291cmNlKTtcbiAgICAgIGZvciAobGV0IGtleSBpbiBtZXJnZWQpIHtcbiAgICAgICAgbGV0IHZhbCA9IHNvdXJjZVtrZXldO1xuICAgICAgICBsZXQgdGFyZ2V0VmFsID0gdGFyZ2V0W2tleV07XG4gICAgICAgIGlmIChpc09iamVjdCh2YWwpICYmIHZhbFtTVEFUSUNdID09PSB2b2lkIDAgJiYgaXNPYmplY3QodGFyZ2V0VmFsKSkge1xuICAgICAgICAgIG1lcmdlZFtrZXldID0gdGhpcy5jbG9uZU1lcmdlKHRhcmdldFZhbCwgdmFsKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG1lcmdlZDtcbiAgICB9XG4gICAgY29tcG9uZW50VG9TdHJpbmcoY2lkKSB7XG4gICAgICByZXR1cm4gdGhpcy5yZWN1cnNpdmVDSURUb1N0cmluZyh0aGlzLnJlbmRlcmVkW0NPTVBPTkVOVFNdLCBjaWQpO1xuICAgIH1cbiAgICBwcnVuZUNJRHMoY2lkcykge1xuICAgICAgY2lkcy5mb3JFYWNoKChjaWQpID0+IGRlbGV0ZSB0aGlzLnJlbmRlcmVkW0NPTVBPTkVOVFNdW2NpZF0pO1xuICAgIH1cbiAgICBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5yZW5kZXJlZDtcbiAgICB9XG4gICAgaXNOZXdGaW5nZXJwcmludChkaWZmID0ge30pIHtcbiAgICAgIHJldHVybiAhIWRpZmZbU1RBVElDXTtcbiAgICB9XG4gICAgdGVtcGxhdGVTdGF0aWMocGFydCwgdGVtcGxhdGVzKSB7XG4gICAgICBpZiAodHlwZW9mIHBhcnQgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgcmV0dXJuIHRlbXBsYXRlc1twYXJ0XTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBwYXJ0O1xuICAgICAgfVxuICAgIH1cbiAgICB0b091dHB1dEJ1ZmZlcihyZW5kZXJlZCwgdGVtcGxhdGVzLCBvdXRwdXQpIHtcbiAgICAgIGlmIChyZW5kZXJlZFtEWU5BTUlDU10pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcHJlaGVuc2lvblRvQnVmZmVyKHJlbmRlcmVkLCB0ZW1wbGF0ZXMsIG91dHB1dCk7XG4gICAgICB9XG4gICAgICBsZXQgeyBbU1RBVElDXTogc3RhdGljcyB9ID0gcmVuZGVyZWQ7XG4gICAgICBzdGF0aWNzID0gdGhpcy50ZW1wbGF0ZVN0YXRpYyhzdGF0aWNzLCB0ZW1wbGF0ZXMpO1xuICAgICAgb3V0cHV0LmJ1ZmZlciArPSBzdGF0aWNzWzBdO1xuICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCBzdGF0aWNzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRoaXMuZHluYW1pY1RvQnVmZmVyKHJlbmRlcmVkW2kgLSAxXSwgdGVtcGxhdGVzLCBvdXRwdXQpO1xuICAgICAgICBvdXRwdXQuYnVmZmVyICs9IHN0YXRpY3NbaV07XG4gICAgICB9XG4gICAgfVxuICAgIGNvbXByZWhlbnNpb25Ub0J1ZmZlcihyZW5kZXJlZCwgdGVtcGxhdGVzLCBvdXRwdXQpIHtcbiAgICAgIGxldCB7IFtEWU5BTUlDU106IGR5bmFtaWNzLCBbU1RBVElDXTogc3RhdGljcyB9ID0gcmVuZGVyZWQ7XG4gICAgICBzdGF0aWNzID0gdGhpcy50ZW1wbGF0ZVN0YXRpYyhzdGF0aWNzLCB0ZW1wbGF0ZXMpO1xuICAgICAgbGV0IGNvbXBUZW1wbGF0ZXMgPSByZW5kZXJlZFtURU1QTEFURVNdO1xuICAgICAgZm9yIChsZXQgZCA9IDA7IGQgPCBkeW5hbWljcy5sZW5ndGg7IGQrKykge1xuICAgICAgICBsZXQgZHluYW1pYyA9IGR5bmFtaWNzW2RdO1xuICAgICAgICBvdXRwdXQuYnVmZmVyICs9IHN0YXRpY3NbMF07XG4gICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgc3RhdGljcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHRoaXMuZHluYW1pY1RvQnVmZmVyKGR5bmFtaWNbaSAtIDFdLCBjb21wVGVtcGxhdGVzLCBvdXRwdXQpO1xuICAgICAgICAgIG91dHB1dC5idWZmZXIgKz0gc3RhdGljc1tpXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBkeW5hbWljVG9CdWZmZXIocmVuZGVyZWQsIHRlbXBsYXRlcywgb3V0cHV0KSB7XG4gICAgICBpZiAodHlwZW9mIHJlbmRlcmVkID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgIG91dHB1dC5idWZmZXIgKz0gdGhpcy5yZWN1cnNpdmVDSURUb1N0cmluZyhvdXRwdXQuY29tcG9uZW50cywgcmVuZGVyZWQsIG91dHB1dC5vbmx5Q2lkcyk7XG4gICAgICB9IGVsc2UgaWYgKGlzT2JqZWN0KHJlbmRlcmVkKSkge1xuICAgICAgICB0aGlzLnRvT3V0cHV0QnVmZmVyKHJlbmRlcmVkLCB0ZW1wbGF0ZXMsIG91dHB1dCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvdXRwdXQuYnVmZmVyICs9IHJlbmRlcmVkO1xuICAgICAgfVxuICAgIH1cbiAgICByZWN1cnNpdmVDSURUb1N0cmluZyhjb21wb25lbnRzLCBjaWQsIG9ubHlDaWRzKSB7XG4gICAgICBsZXQgY29tcG9uZW50ID0gY29tcG9uZW50c1tjaWRdIHx8IGxvZ0Vycm9yKGBubyBjb21wb25lbnQgZm9yIENJRCAke2NpZH1gLCBjb21wb25lbnRzKTtcbiAgICAgIGxldCB0ZW1wbGF0ZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJ0ZW1wbGF0ZVwiKTtcbiAgICAgIHRlbXBsYXRlLmlubmVySFRNTCA9IHRoaXMucmVjdXJzaXZlVG9TdHJpbmcoY29tcG9uZW50LCBjb21wb25lbnRzLCBvbmx5Q2lkcyk7XG4gICAgICBsZXQgY29udGFpbmVyID0gdGVtcGxhdGUuY29udGVudDtcbiAgICAgIGxldCBza2lwID0gb25seUNpZHMgJiYgIW9ubHlDaWRzLmhhcyhjaWQpO1xuICAgICAgbGV0IFtoYXNDaGlsZE5vZGVzLCBoYXNDaGlsZENvbXBvbmVudHNdID0gQXJyYXkuZnJvbShjb250YWluZXIuY2hpbGROb2RlcykucmVkdWNlKChbaGFzTm9kZXMsIGhhc0NvbXBvbmVudHNdLCBjaGlsZCwgaSkgPT4ge1xuICAgICAgICBpZiAoY2hpbGQubm9kZVR5cGUgPT09IE5vZGUuRUxFTUVOVF9OT0RFKSB7XG4gICAgICAgICAgaWYgKGNoaWxkLmdldEF0dHJpYnV0ZShQSFhfQ09NUE9ORU5UKSkge1xuICAgICAgICAgICAgcmV0dXJuIFtoYXNOb2RlcywgdHJ1ZV07XG4gICAgICAgICAgfVxuICAgICAgICAgIGNoaWxkLnNldEF0dHJpYnV0ZShQSFhfQ09NUE9ORU5ULCBjaWQpO1xuICAgICAgICAgIGlmICghY2hpbGQuaWQpIHtcbiAgICAgICAgICAgIGNoaWxkLmlkID0gYCR7dGhpcy5wYXJlbnRWaWV3SWQoKX0tJHtjaWR9LSR7aX1gO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoc2tpcCkge1xuICAgICAgICAgICAgY2hpbGQuc2V0QXR0cmlidXRlKFBIWF9TS0lQLCBcIlwiKTtcbiAgICAgICAgICAgIGNoaWxkLmlubmVySFRNTCA9IFwiXCI7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBbdHJ1ZSwgaGFzQ29tcG9uZW50c107XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKGNoaWxkLm5vZGVWYWx1ZS50cmltKCkgIT09IFwiXCIpIHtcbiAgICAgICAgICAgIGxvZ0Vycm9yKGBvbmx5IEhUTUwgZWxlbWVudCB0YWdzIGFyZSBhbGxvd2VkIGF0IHRoZSByb290IG9mIGNvbXBvbmVudHMuXG5cbmdvdDogXCIke2NoaWxkLm5vZGVWYWx1ZS50cmltKCl9XCJcblxud2l0aGluOlxuYCwgdGVtcGxhdGUuaW5uZXJIVE1MLnRyaW0oKSk7XG4gICAgICAgICAgICBjaGlsZC5yZXBsYWNlV2l0aCh0aGlzLmNyZWF0ZVNwYW4oY2hpbGQubm9kZVZhbHVlLCBjaWQpKTtcbiAgICAgICAgICAgIHJldHVybiBbdHJ1ZSwgaGFzQ29tcG9uZW50c107XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNoaWxkLnJlbW92ZSgpO1xuICAgICAgICAgICAgcmV0dXJuIFtoYXNOb2RlcywgaGFzQ29tcG9uZW50c107XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LCBbZmFsc2UsIGZhbHNlXSk7XG4gICAgICBpZiAoIWhhc0NoaWxkTm9kZXMgJiYgIWhhc0NoaWxkQ29tcG9uZW50cykge1xuICAgICAgICBsb2dFcnJvcihcImV4cGVjdGVkIGF0IGxlYXN0IG9uZSBIVE1MIGVsZW1lbnQgdGFnIGluc2lkZSBhIGNvbXBvbmVudCwgYnV0IHRoZSBjb21wb25lbnQgaXMgZW1wdHk6XFxuXCIsIHRlbXBsYXRlLmlubmVySFRNTC50cmltKCkpO1xuICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVTcGFuKFwiXCIsIGNpZCkub3V0ZXJIVE1MO1xuICAgICAgfSBlbHNlIGlmICghaGFzQ2hpbGROb2RlcyAmJiBoYXNDaGlsZENvbXBvbmVudHMpIHtcbiAgICAgICAgbG9nRXJyb3IoXCJleHBlY3RlZCBhdCBsZWFzdCBvbmUgSFRNTCBlbGVtZW50IHRhZyBkaXJlY3RseSBpbnNpZGUgYSBjb21wb25lbnQsIGJ1dCBvbmx5IHN1YmNvbXBvbmVudHMgd2VyZSBmb3VuZC4gQSBjb21wb25lbnQgbXVzdCByZW5kZXIgYXQgbGVhc3Qgb25lIEhUTUwgdGFnIGRpcmVjdGx5IGluc2lkZSBpdHNlbGYuXCIsIHRlbXBsYXRlLmlubmVySFRNTC50cmltKCkpO1xuICAgICAgICByZXR1cm4gdGVtcGxhdGUuaW5uZXJIVE1MO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRlbXBsYXRlLmlubmVySFRNTDtcbiAgICAgIH1cbiAgICB9XG4gICAgY3JlYXRlU3Bhbih0ZXh0LCBjaWQpIHtcbiAgICAgIGxldCBzcGFuID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIik7XG4gICAgICBzcGFuLmlubmVyVGV4dCA9IHRleHQ7XG4gICAgICBzcGFuLnNldEF0dHJpYnV0ZShQSFhfQ09NUE9ORU5ULCBjaWQpO1xuICAgICAgcmV0dXJuIHNwYW47XG4gICAgfVxuICB9O1xuXG4gIC8vIGpzL3Bob2VuaXhfbGl2ZV92aWV3L3ZpZXdfaG9vay5qc1xuICB2YXIgdmlld0hvb2tJRCA9IDE7XG4gIHZhciBWaWV3SG9vayA9IGNsYXNzIHtcbiAgICBzdGF0aWMgbWFrZUlEKCkge1xuICAgICAgcmV0dXJuIHZpZXdIb29rSUQrKztcbiAgICB9XG4gICAgc3RhdGljIGVsZW1lbnRJRChlbCkge1xuICAgICAgcmV0dXJuIGVsLnBoeEhvb2tJZDtcbiAgICB9XG4gICAgY29uc3RydWN0b3IodmlldywgZWwsIGNhbGxiYWNrcykge1xuICAgICAgdGhpcy5fX3ZpZXcgPSB2aWV3O1xuICAgICAgdGhpcy5fX2xpdmVTb2NrZXQgPSB2aWV3LmxpdmVTb2NrZXQ7XG4gICAgICB0aGlzLl9fY2FsbGJhY2tzID0gY2FsbGJhY2tzO1xuICAgICAgdGhpcy5fX2xpc3RlbmVycyA9IG5ldyBTZXQoKTtcbiAgICAgIHRoaXMuX19pc0Rpc2Nvbm5lY3RlZCA9IGZhbHNlO1xuICAgICAgdGhpcy5lbCA9IGVsO1xuICAgICAgdGhpcy5lbC5waHhIb29rSWQgPSB0aGlzLmNvbnN0cnVjdG9yLm1ha2VJRCgpO1xuICAgICAgZm9yIChsZXQga2V5IGluIHRoaXMuX19jYWxsYmFja3MpIHtcbiAgICAgICAgdGhpc1trZXldID0gdGhpcy5fX2NhbGxiYWNrc1trZXldO1xuICAgICAgfVxuICAgIH1cbiAgICBfX21vdW50ZWQoKSB7XG4gICAgICB0aGlzLm1vdW50ZWQgJiYgdGhpcy5tb3VudGVkKCk7XG4gICAgfVxuICAgIF9fdXBkYXRlZCgpIHtcbiAgICAgIHRoaXMudXBkYXRlZCAmJiB0aGlzLnVwZGF0ZWQoKTtcbiAgICB9XG4gICAgX19iZWZvcmVVcGRhdGUoKSB7XG4gICAgICB0aGlzLmJlZm9yZVVwZGF0ZSAmJiB0aGlzLmJlZm9yZVVwZGF0ZSgpO1xuICAgIH1cbiAgICBfX2Rlc3Ryb3llZCgpIHtcbiAgICAgIHRoaXMuZGVzdHJveWVkICYmIHRoaXMuZGVzdHJveWVkKCk7XG4gICAgfVxuICAgIF9fcmVjb25uZWN0ZWQoKSB7XG4gICAgICBpZiAodGhpcy5fX2lzRGlzY29ubmVjdGVkKSB7XG4gICAgICAgIHRoaXMuX19pc0Rpc2Nvbm5lY3RlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLnJlY29ubmVjdGVkICYmIHRoaXMucmVjb25uZWN0ZWQoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgX19kaXNjb25uZWN0ZWQoKSB7XG4gICAgICB0aGlzLl9faXNEaXNjb25uZWN0ZWQgPSB0cnVlO1xuICAgICAgdGhpcy5kaXNjb25uZWN0ZWQgJiYgdGhpcy5kaXNjb25uZWN0ZWQoKTtcbiAgICB9XG4gICAgcHVzaEV2ZW50KGV2ZW50LCBwYXlsb2FkID0ge30sIG9uUmVwbHkgPSBmdW5jdGlvbigpIHtcbiAgICB9KSB7XG4gICAgICByZXR1cm4gdGhpcy5fX3ZpZXcucHVzaEhvb2tFdmVudChudWxsLCBldmVudCwgcGF5bG9hZCwgb25SZXBseSk7XG4gICAgfVxuICAgIHB1c2hFdmVudFRvKHBoeFRhcmdldCwgZXZlbnQsIHBheWxvYWQgPSB7fSwgb25SZXBseSA9IGZ1bmN0aW9uKCkge1xuICAgIH0pIHtcbiAgICAgIHJldHVybiB0aGlzLl9fdmlldy53aXRoaW5UYXJnZXRzKHBoeFRhcmdldCwgKHZpZXcsIHRhcmdldEN0eCkgPT4ge1xuICAgICAgICByZXR1cm4gdmlldy5wdXNoSG9va0V2ZW50KHRhcmdldEN0eCwgZXZlbnQsIHBheWxvYWQsIG9uUmVwbHkpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIGhhbmRsZUV2ZW50KGV2ZW50LCBjYWxsYmFjaykge1xuICAgICAgbGV0IGNhbGxiYWNrUmVmID0gKGN1c3RvbUV2ZW50LCBieXBhc3MpID0+IGJ5cGFzcyA/IGV2ZW50IDogY2FsbGJhY2soY3VzdG9tRXZlbnQuZGV0YWlsKTtcbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKGBwaHg6JHtldmVudH1gLCBjYWxsYmFja1JlZik7XG4gICAgICB0aGlzLl9fbGlzdGVuZXJzLmFkZChjYWxsYmFja1JlZik7XG4gICAgICByZXR1cm4gY2FsbGJhY2tSZWY7XG4gICAgfVxuICAgIHJlbW92ZUhhbmRsZUV2ZW50KGNhbGxiYWNrUmVmKSB7XG4gICAgICBsZXQgZXZlbnQgPSBjYWxsYmFja1JlZihudWxsLCB0cnVlKTtcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKGBwaHg6JHtldmVudH1gLCBjYWxsYmFja1JlZik7XG4gICAgICB0aGlzLl9fbGlzdGVuZXJzLmRlbGV0ZShjYWxsYmFja1JlZik7XG4gICAgfVxuICAgIHVwbG9hZChuYW1lLCBmaWxlcykge1xuICAgICAgcmV0dXJuIHRoaXMuX192aWV3LmRpc3BhdGNoVXBsb2FkcyhuYW1lLCBmaWxlcyk7XG4gICAgfVxuICAgIHVwbG9hZFRvKHBoeFRhcmdldCwgbmFtZSwgZmlsZXMpIHtcbiAgICAgIHJldHVybiB0aGlzLl9fdmlldy53aXRoaW5UYXJnZXRzKHBoeFRhcmdldCwgKHZpZXcpID0+IHZpZXcuZGlzcGF0Y2hVcGxvYWRzKG5hbWUsIGZpbGVzKSk7XG4gICAgfVxuICAgIF9fY2xlYW51cF9fKCkge1xuICAgICAgdGhpcy5fX2xpc3RlbmVycy5mb3JFYWNoKChjYWxsYmFja1JlZikgPT4gdGhpcy5yZW1vdmVIYW5kbGVFdmVudChjYWxsYmFja1JlZikpO1xuICAgIH1cbiAgfTtcblxuICAvLyBqcy9waG9lbml4X2xpdmVfdmlldy9qcy5qc1xuICB2YXIgSlMgPSB7XG4gICAgZXhlYyhldmVudFR5cGUsIHBoeEV2ZW50LCB2aWV3LCBlbCwgZGVmYXVsdHMpIHtcbiAgICAgIGxldCBbZGVmYXVsdEtpbmQsIGRlZmF1bHRBcmdzXSA9IGRlZmF1bHRzIHx8IFtudWxsLCB7fV07XG4gICAgICBsZXQgY29tbWFuZHMgPSBwaHhFdmVudC5jaGFyQXQoMCkgPT09IFwiW1wiID8gSlNPTi5wYXJzZShwaHhFdmVudCkgOiBbW2RlZmF1bHRLaW5kLCBkZWZhdWx0QXJnc11dO1xuICAgICAgY29tbWFuZHMuZm9yRWFjaCgoW2tpbmQsIGFyZ3NdKSA9PiB7XG4gICAgICAgIGlmIChraW5kID09PSBkZWZhdWx0S2luZCAmJiBkZWZhdWx0QXJncy5kYXRhKSB7XG4gICAgICAgICAgYXJncy5kYXRhID0gT2JqZWN0LmFzc2lnbihhcmdzLmRhdGEgfHwge30sIGRlZmF1bHRBcmdzLmRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXNbYGV4ZWNfJHtraW5kfWBdKGV2ZW50VHlwZSwgcGh4RXZlbnQsIHZpZXcsIGVsLCBhcmdzKTtcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgaXNWaXNpYmxlKGVsKSB7XG4gICAgICBsZXQgc3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbCk7XG4gICAgICByZXR1cm4gIShzdHlsZS5vcGFjaXR5ID09PSAwIHx8IHN0eWxlLmRpc3BsYXkgPT09IFwibm9uZVwiKTtcbiAgICB9LFxuICAgIGV4ZWNfZGlzcGF0Y2goZXZlbnRUeXBlLCBwaHhFdmVudCwgdmlldywgc291cmNlRWwsIHsgdG8sIGV2ZW50LCBkZXRhaWwgfSkge1xuICAgICAgaWYgKHRvKSB7XG4gICAgICAgIGRvbV9kZWZhdWx0LmFsbChkb2N1bWVudCwgdG8sIChlbCkgPT4gZG9tX2RlZmF1bHQuZGlzcGF0Y2hFdmVudChlbCwgZXZlbnQsIGRldGFpbCkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZG9tX2RlZmF1bHQuZGlzcGF0Y2hFdmVudChzb3VyY2VFbCwgZXZlbnQsIGRldGFpbCk7XG4gICAgICB9XG4gICAgfSxcbiAgICBleGVjX3B1c2goZXZlbnRUeXBlLCBwaHhFdmVudCwgdmlldywgc291cmNlRWwsIGFyZ3MpIHtcbiAgICAgIGxldCB7IGV2ZW50LCBkYXRhLCB0YXJnZXQsIHBhZ2VfbG9hZGluZywgbG9hZGluZywgdmFsdWUgfSA9IGFyZ3M7XG4gICAgICBsZXQgcHVzaE9wdHMgPSB7IHBhZ2VfbG9hZGluZzogISFwYWdlX2xvYWRpbmcsIGxvYWRpbmcsIHZhbHVlIH07XG4gICAgICBsZXQgdGFyZ2V0U3JjID0gZXZlbnRUeXBlID09PSBcImNoYW5nZVwiID8gc291cmNlRWwuZm9ybSA6IHNvdXJjZUVsO1xuICAgICAgbGV0IHBoeFRhcmdldCA9IHRhcmdldCB8fCB0YXJnZXRTcmMuZ2V0QXR0cmlidXRlKHZpZXcuYmluZGluZyhcInRhcmdldFwiKSkgfHwgdGFyZ2V0U3JjO1xuICAgICAgdmlldy53aXRoaW5UYXJnZXRzKHBoeFRhcmdldCwgKHRhcmdldFZpZXcsIHRhcmdldEN0eCkgPT4ge1xuICAgICAgICBpZiAoZXZlbnRUeXBlID09PSBcImNoYW5nZVwiKSB7XG4gICAgICAgICAgbGV0IHsgbmV3Q2lkLCBfdGFyZ2V0LCBjYWxsYmFjayB9ID0gYXJncztcbiAgICAgICAgICBpZiAoX3RhcmdldCkge1xuICAgICAgICAgICAgcHVzaE9wdHMuX3RhcmdldCA9IF90YXJnZXQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRhcmdldFZpZXcucHVzaElucHV0KHNvdXJjZUVsLCB0YXJnZXRDdHgsIG5ld0NpZCwgZXZlbnQgfHwgcGh4RXZlbnQsIHB1c2hPcHRzLCBjYWxsYmFjayk7XG4gICAgICAgIH0gZWxzZSBpZiAoZXZlbnRUeXBlID09PSBcInN1Ym1pdFwiKSB7XG4gICAgICAgICAgdGFyZ2V0Vmlldy5zdWJtaXRGb3JtKHNvdXJjZUVsLCB0YXJnZXRDdHgsIGV2ZW50IHx8IHBoeEV2ZW50LCBwdXNoT3B0cyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGFyZ2V0Vmlldy5wdXNoRXZlbnQoZXZlbnRUeXBlLCBzb3VyY2VFbCwgdGFyZ2V0Q3R4LCBldmVudCB8fCBwaHhFdmVudCwgZGF0YSwgcHVzaE9wdHMpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9LFxuICAgIGV4ZWNfYWRkX2NsYXNzKGV2ZW50VHlwZSwgcGh4RXZlbnQsIHZpZXcsIHNvdXJjZUVsLCB7IHRvLCBuYW1lcywgdHJhbnNpdGlvbiwgdGltZSB9KSB7XG4gICAgICBpZiAodG8pIHtcbiAgICAgICAgZG9tX2RlZmF1bHQuYWxsKGRvY3VtZW50LCB0bywgKGVsKSA9PiB0aGlzLmFkZE9yUmVtb3ZlQ2xhc3NlcyhlbCwgbmFtZXMsIFtdLCB0cmFuc2l0aW9uLCB0aW1lLCB2aWV3KSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmFkZE9yUmVtb3ZlQ2xhc3Nlcyhzb3VyY2VFbCwgbmFtZXMsIFtdLCB0cmFuc2l0aW9uLCB2aWV3KTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGV4ZWNfcmVtb3ZlX2NsYXNzKGV2ZW50VHlwZSwgcGh4RXZlbnQsIHZpZXcsIHNvdXJjZUVsLCB7IHRvLCBuYW1lcywgdHJhbnNpdGlvbiwgdGltZSB9KSB7XG4gICAgICBpZiAodG8pIHtcbiAgICAgICAgZG9tX2RlZmF1bHQuYWxsKGRvY3VtZW50LCB0bywgKGVsKSA9PiB0aGlzLmFkZE9yUmVtb3ZlQ2xhc3NlcyhlbCwgW10sIG5hbWVzLCB0cmFuc2l0aW9uLCB0aW1lLCB2aWV3KSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmFkZE9yUmVtb3ZlQ2xhc3Nlcyhzb3VyY2VFbCwgW10sIG5hbWVzLCB0cmFuc2l0aW9uLCB0aW1lLCB2aWV3KTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGV4ZWNfdHJhbnNpdGlvbihldmVudFR5cGUsIHBoeEV2ZW50LCB2aWV3LCBzb3VyY2VFbCwgeyB0aW1lLCB0bywgdHJhbnNpdGlvbiB9KSB7XG4gICAgICBsZXQgZWxzID0gdG8gPyBkb21fZGVmYXVsdC5hbGwoZG9jdW1lbnQsIHRvKSA6IFtzb3VyY2VFbF07XG4gICAgICBsZXQgW3RyYW5zaXRpb25fc3RhcnQsIHJ1bm5pbmcsIHRyYW5zaXRpb25fZW5kXSA9IHRyYW5zaXRpb247XG4gICAgICBlbHMuZm9yRWFjaCgoZWwpID0+IHtcbiAgICAgICAgbGV0IG9uU3RhcnQgPSAoKSA9PiB0aGlzLmFkZE9yUmVtb3ZlQ2xhc3NlcyhlbCwgdHJhbnNpdGlvbl9zdGFydC5jb25jYXQocnVubmluZyksIFtdKTtcbiAgICAgICAgbGV0IG9uRG9uZSA9ICgpID0+IHRoaXMuYWRkT3JSZW1vdmVDbGFzc2VzKGVsLCB0cmFuc2l0aW9uX2VuZCwgdHJhbnNpdGlvbl9zdGFydC5jb25jYXQocnVubmluZykpO1xuICAgICAgICB2aWV3LnRyYW5zaXRpb24odGltZSwgb25TdGFydCwgb25Eb25lKTtcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgZXhlY190b2dnbGUoZXZlbnRUeXBlLCBwaHhFdmVudCwgdmlldywgc291cmNlRWwsIHsgdG8sIGRpc3BsYXksIGlucywgb3V0cywgdGltZSB9KSB7XG4gICAgICBpZiAodG8pIHtcbiAgICAgICAgZG9tX2RlZmF1bHQuYWxsKGRvY3VtZW50LCB0bywgKGVsKSA9PiB0aGlzLnRvZ2dsZShldmVudFR5cGUsIHZpZXcsIGVsLCBkaXNwbGF5LCBpbnMsIG91dHMsIHRpbWUpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMudG9nZ2xlKGV2ZW50VHlwZSwgdmlldywgc291cmNlRWwsIGRpc3BsYXksIGlucywgb3V0cywgdGltZSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBleGVjX3Nob3coZXZlbnRUeXBlLCBwaHhFdmVudCwgdmlldywgc291cmNlRWwsIHsgdG8sIGRpc3BsYXksIHRyYW5zaXRpb24sIHRpbWUgfSkge1xuICAgICAgaWYgKHRvKSB7XG4gICAgICAgIGRvbV9kZWZhdWx0LmFsbChkb2N1bWVudCwgdG8sIChlbCkgPT4gdGhpcy5zaG93KGV2ZW50VHlwZSwgdmlldywgZWwsIGRpc3BsYXksIHRyYW5zaXRpb24sIHRpbWUpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuc2hvdyhldmVudFR5cGUsIHZpZXcsIHNvdXJjZUVsLCB0cmFuc2l0aW9uLCB0aW1lKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGV4ZWNfaGlkZShldmVudFR5cGUsIHBoeEV2ZW50LCB2aWV3LCBzb3VyY2VFbCwgeyB0bywgZGlzcGxheSwgdHJhbnNpdGlvbiwgdGltZSB9KSB7XG4gICAgICBpZiAodG8pIHtcbiAgICAgICAgZG9tX2RlZmF1bHQuYWxsKGRvY3VtZW50LCB0bywgKGVsKSA9PiB0aGlzLmhpZGUoZXZlbnRUeXBlLCB2aWV3LCBlbCwgZGlzcGxheSwgdHJhbnNpdGlvbiwgdGltZSkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5oaWRlKGV2ZW50VHlwZSwgdmlldywgc291cmNlRWwsIGRpc3BsYXksIHRyYW5zaXRpb24sIHRpbWUpO1xuICAgICAgfVxuICAgIH0sXG4gICAgc2hvdyhldmVudFR5cGUsIHZpZXcsIGVsLCBkaXNwbGF5LCB0cmFuc2l0aW9uLCB0aW1lKSB7XG4gICAgICBpZiAoIXRoaXMuaXNWaXNpYmxlKGVsKSkge1xuICAgICAgICB0aGlzLnRvZ2dsZShldmVudFR5cGUsIHZpZXcsIGVsLCBkaXNwbGF5LCB0cmFuc2l0aW9uLCBudWxsLCB0aW1lKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGhpZGUoZXZlbnRUeXBlLCB2aWV3LCBlbCwgZGlzcGxheSwgdHJhbnNpdGlvbiwgdGltZSkge1xuICAgICAgaWYgKHRoaXMuaXNWaXNpYmxlKGVsKSkge1xuICAgICAgICB0aGlzLnRvZ2dsZShldmVudFR5cGUsIHZpZXcsIGVsLCBkaXNwbGF5LCBudWxsLCB0cmFuc2l0aW9uLCB0aW1lKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHRvZ2dsZShldmVudFR5cGUsIHZpZXcsIGVsLCBkaXNwbGF5LCBpbnMsIG91dHMsIHRpbWUpIHtcbiAgICAgIGxldCBbaW5DbGFzc2VzLCBpblN0YXJ0Q2xhc3NlcywgaW5FbmRDbGFzc2VzXSA9IGlucyB8fCBbW10sIFtdLCBbXV07XG4gICAgICBsZXQgW291dENsYXNzZXMsIG91dFN0YXJ0Q2xhc3Nlcywgb3V0RW5kQ2xhc3Nlc10gPSBvdXRzIHx8IFtbXSwgW10sIFtdXTtcbiAgICAgIGlmIChpbkNsYXNzZXMubGVuZ3RoID4gMCB8fCBvdXRDbGFzc2VzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgaWYgKHRoaXMuaXNWaXNpYmxlKGVsKSkge1xuICAgICAgICAgIGxldCBvblN0YXJ0ID0gKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5hZGRPclJlbW92ZUNsYXNzZXMoZWwsIG91dFN0YXJ0Q2xhc3NlcywgaW5DbGFzc2VzLmNvbmNhdChpblN0YXJ0Q2xhc3NlcykuY29uY2F0KGluRW5kQ2xhc3NlcykpO1xuICAgICAgICAgICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICAgICAgICAgIHRoaXMuYWRkT3JSZW1vdmVDbGFzc2VzKGVsLCBvdXRDbGFzc2VzLCBbXSk7XG4gICAgICAgICAgICAgIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4gdGhpcy5hZGRPclJlbW92ZUNsYXNzZXMoZWwsIG91dEVuZENsYXNzZXMsIG91dFN0YXJ0Q2xhc3NlcykpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfTtcbiAgICAgICAgICB2aWV3LnRyYW5zaXRpb24odGltZSwgb25TdGFydCwgKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5hZGRPclJlbW92ZUNsYXNzZXMoZWwsIFtdLCBvdXRDbGFzc2VzLmNvbmNhdChvdXRFbmRDbGFzc2VzKSk7XG4gICAgICAgICAgICBkb21fZGVmYXVsdC5wdXRTdGlja3koZWwsIFwidG9nZ2xlXCIsIChjdXJyZW50RWwpID0+IGN1cnJlbnRFbC5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCIpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChldmVudFR5cGUgPT09IFwicmVtb3ZlXCIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgbGV0IG9uU3RhcnQgPSAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmFkZE9yUmVtb3ZlQ2xhc3NlcyhlbCwgaW5TdGFydENsYXNzZXMsIG91dENsYXNzZXMuY29uY2F0KG91dFN0YXJ0Q2xhc3NlcykuY29uY2F0KG91dEVuZENsYXNzZXMpKTtcbiAgICAgICAgICAgIGRvbV9kZWZhdWx0LnB1dFN0aWNreShlbCwgXCJ0b2dnbGVcIiwgKGN1cnJlbnRFbCkgPT4gY3VycmVudEVsLnN0eWxlLmRpc3BsYXkgPSBkaXNwbGF5IHx8IFwiYmxvY2tcIik7XG4gICAgICAgICAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgICAgICAgICAgdGhpcy5hZGRPclJlbW92ZUNsYXNzZXMoZWwsIGluQ2xhc3NlcywgW10pO1xuICAgICAgICAgICAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHRoaXMuYWRkT3JSZW1vdmVDbGFzc2VzKGVsLCBpbkVuZENsYXNzZXMsIGluU3RhcnRDbGFzc2VzKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIHZpZXcudHJhbnNpdGlvbih0aW1lLCBvblN0YXJ0LCAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmFkZE9yUmVtb3ZlQ2xhc3NlcyhlbCwgW10sIGluQ2xhc3Nlcy5jb25jYXQoaW5FbmRDbGFzc2VzKSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxldCBuZXdEaXNwbGF5ID0gdGhpcy5pc1Zpc2libGUoZWwpID8gXCJub25lXCIgOiBkaXNwbGF5IHx8IFwiYmxvY2tcIjtcbiAgICAgICAgZG9tX2RlZmF1bHQucHV0U3RpY2t5KGVsLCBcInRvZ2dsZVwiLCAoY3VycmVudEVsKSA9PiBjdXJyZW50RWwuc3R5bGUuZGlzcGxheSA9IG5ld0Rpc3BsYXkpO1xuICAgICAgfVxuICAgIH0sXG4gICAgYWRkT3JSZW1vdmVDbGFzc2VzKGVsLCBhZGRzLCByZW1vdmVzLCB0cmFuc2l0aW9uLCB0aW1lLCB2aWV3KSB7XG4gICAgICBsZXQgW3RyYW5zaXRpb25fcnVuLCB0cmFuc2l0aW9uX3N0YXJ0LCB0cmFuc2l0aW9uX2VuZF0gPSB0cmFuc2l0aW9uIHx8IFtbXSwgW10sIFtdXTtcbiAgICAgIGlmICh0cmFuc2l0aW9uX3J1bi5sZW5ndGggPiAwKSB7XG4gICAgICAgIGxldCBvblN0YXJ0ID0gKCkgPT4gdGhpcy5hZGRPclJlbW92ZUNsYXNzZXMoZWwsIHRyYW5zaXRpb25fc3RhcnQuY29uY2F0KHRyYW5zaXRpb25fcnVuKSwgW10pO1xuICAgICAgICBsZXQgb25Eb25lID0gKCkgPT4gdGhpcy5hZGRPclJlbW92ZUNsYXNzZXMoZWwsIGFkZHMuY29uY2F0KHRyYW5zaXRpb25fZW5kKSwgcmVtb3Zlcy5jb25jYXQodHJhbnNpdGlvbl9ydW4pLmNvbmNhdCh0cmFuc2l0aW9uX3N0YXJ0KSk7XG4gICAgICAgIHJldHVybiB2aWV3LnRyYW5zaXRpb24odGltZSwgb25TdGFydCwgb25Eb25lKTtcbiAgICAgIH1cbiAgICAgIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgICBsZXQgW3ByZXZBZGRzLCBwcmV2UmVtb3Zlc10gPSBkb21fZGVmYXVsdC5nZXRTdGlja3koZWwsIFwiY2xhc3Nlc1wiLCBbW10sIFtdXSk7XG4gICAgICAgIGxldCBrZWVwQWRkcyA9IGFkZHMuZmlsdGVyKChuYW1lKSA9PiBwcmV2QWRkcy5pbmRleE9mKG5hbWUpIDwgMCAmJiAhZWwuY2xhc3NMaXN0LmNvbnRhaW5zKG5hbWUpKTtcbiAgICAgICAgbGV0IGtlZXBSZW1vdmVzID0gcmVtb3Zlcy5maWx0ZXIoKG5hbWUpID0+IHByZXZSZW1vdmVzLmluZGV4T2YobmFtZSkgPCAwICYmIGVsLmNsYXNzTGlzdC5jb250YWlucyhuYW1lKSk7XG4gICAgICAgIGxldCBuZXdBZGRzID0gcHJldkFkZHMuZmlsdGVyKChuYW1lKSA9PiByZW1vdmVzLmluZGV4T2YobmFtZSkgPCAwKS5jb25jYXQoa2VlcEFkZHMpO1xuICAgICAgICBsZXQgbmV3UmVtb3ZlcyA9IHByZXZSZW1vdmVzLmZpbHRlcigobmFtZSkgPT4gYWRkcy5pbmRleE9mKG5hbWUpIDwgMCkuY29uY2F0KGtlZXBSZW1vdmVzKTtcbiAgICAgICAgZG9tX2RlZmF1bHQucHV0U3RpY2t5KGVsLCBcImNsYXNzZXNcIiwgKGN1cnJlbnRFbCkgPT4ge1xuICAgICAgICAgIGN1cnJlbnRFbC5jbGFzc0xpc3QucmVtb3ZlKC4uLm5ld1JlbW92ZXMpO1xuICAgICAgICAgIGN1cnJlbnRFbC5jbGFzc0xpc3QuYWRkKC4uLm5ld0FkZHMpO1xuICAgICAgICAgIHJldHVybiBbbmV3QWRkcywgbmV3UmVtb3Zlc107XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSxcbiAgICBoYXNBbGxDbGFzc2VzKGVsLCBjbGFzc2VzKSB7XG4gICAgICByZXR1cm4gY2xhc3Nlcy5ldmVyeSgobmFtZSkgPT4gZWwuY2xhc3NMaXN0LmNvbnRhaW5zKG5hbWUpKTtcbiAgICB9LFxuICAgIGlzVG9nZ2xlZE91dChlbCwgb3V0Q2xhc3Nlcykge1xuICAgICAgcmV0dXJuICF0aGlzLmlzVmlzaWJsZShlbCkgfHwgdGhpcy5oYXNBbGxDbGFzc2VzKGVsLCBvdXRDbGFzc2VzKTtcbiAgICB9XG4gIH07XG4gIHZhciBqc19kZWZhdWx0ID0gSlM7XG5cbiAgLy8ganMvcGhvZW5peF9saXZlX3ZpZXcvdmlldy5qc1xuICB2YXIgc2VyaWFsaXplRm9ybSA9IChmb3JtLCBtZXRhID0ge30pID0+IHtcbiAgICBsZXQgZm9ybURhdGEgPSBuZXcgRm9ybURhdGEoZm9ybSk7XG4gICAgbGV0IHRvUmVtb3ZlID0gW107XG4gICAgZm9ybURhdGEuZm9yRWFjaCgodmFsLCBrZXksIF9pbmRleCkgPT4ge1xuICAgICAgaWYgKHZhbCBpbnN0YW5jZW9mIEZpbGUpIHtcbiAgICAgICAgdG9SZW1vdmUucHVzaChrZXkpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHRvUmVtb3ZlLmZvckVhY2goKGtleSkgPT4gZm9ybURhdGEuZGVsZXRlKGtleSkpO1xuICAgIGxldCBwYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKCk7XG4gICAgZm9yIChsZXQgW2tleSwgdmFsXSBvZiBmb3JtRGF0YS5lbnRyaWVzKCkpIHtcbiAgICAgIHBhcmFtcy5hcHBlbmQoa2V5LCB2YWwpO1xuICAgIH1cbiAgICBmb3IgKGxldCBtZXRhS2V5IGluIG1ldGEpIHtcbiAgICAgIHBhcmFtcy5hcHBlbmQobWV0YUtleSwgbWV0YVttZXRhS2V5XSk7XG4gICAgfVxuICAgIHJldHVybiBwYXJhbXMudG9TdHJpbmcoKTtcbiAgfTtcbiAgdmFyIFZpZXcgPSBjbGFzcyB7XG4gICAgY29uc3RydWN0b3IoZWwsIGxpdmVTb2NrZXQsIHBhcmVudFZpZXcsIGZsYXNoKSB7XG4gICAgICB0aGlzLmxpdmVTb2NrZXQgPSBsaXZlU29ja2V0O1xuICAgICAgdGhpcy5mbGFzaCA9IGZsYXNoO1xuICAgICAgdGhpcy5wYXJlbnQgPSBwYXJlbnRWaWV3O1xuICAgICAgdGhpcy5yb290ID0gcGFyZW50VmlldyA/IHBhcmVudFZpZXcucm9vdCA6IHRoaXM7XG4gICAgICB0aGlzLmVsID0gZWw7XG4gICAgICB0aGlzLmlkID0gdGhpcy5lbC5pZDtcbiAgICAgIHRoaXMucmVmID0gMDtcbiAgICAgIHRoaXMuY2hpbGRKb2lucyA9IDA7XG4gICAgICB0aGlzLmxvYWRlclRpbWVyID0gbnVsbDtcbiAgICAgIHRoaXMucGVuZGluZ0RpZmZzID0gW107XG4gICAgICB0aGlzLnBydW5pbmdDSURzID0gW107XG4gICAgICB0aGlzLnJlZGlyZWN0ID0gZmFsc2U7XG4gICAgICB0aGlzLmhyZWYgPSBudWxsO1xuICAgICAgdGhpcy5qb2luQ291bnQgPSB0aGlzLnBhcmVudCA/IHRoaXMucGFyZW50LmpvaW5Db3VudCAtIDEgOiAwO1xuICAgICAgdGhpcy5qb2luUGVuZGluZyA9IHRydWU7XG4gICAgICB0aGlzLmRlc3Ryb3llZCA9IGZhbHNlO1xuICAgICAgdGhpcy5qb2luQ2FsbGJhY2sgPSBmdW5jdGlvbihvbkRvbmUpIHtcbiAgICAgICAgb25Eb25lICYmIG9uRG9uZSgpO1xuICAgICAgfTtcbiAgICAgIHRoaXMuc3RvcENhbGxiYWNrID0gZnVuY3Rpb24oKSB7XG4gICAgICB9O1xuICAgICAgdGhpcy5wZW5kaW5nSm9pbk9wcyA9IHRoaXMucGFyZW50ID8gbnVsbCA6IFtdO1xuICAgICAgdGhpcy52aWV3SG9va3MgPSB7fTtcbiAgICAgIHRoaXMudXBsb2FkZXJzID0ge307XG4gICAgICB0aGlzLmZvcm1TdWJtaXRzID0gW107XG4gICAgICB0aGlzLmNoaWxkcmVuID0gdGhpcy5wYXJlbnQgPyBudWxsIDoge307XG4gICAgICB0aGlzLnJvb3QuY2hpbGRyZW5bdGhpcy5pZF0gPSB7fTtcbiAgICAgIHRoaXMuY2hhbm5lbCA9IHRoaXMubGl2ZVNvY2tldC5jaGFubmVsKGBsdjoke3RoaXMuaWR9YCwgKCkgPT4ge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHJlZGlyZWN0OiB0aGlzLnJlZGlyZWN0ID8gdGhpcy5ocmVmIDogdm9pZCAwLFxuICAgICAgICAgIHVybDogdGhpcy5yZWRpcmVjdCA/IHZvaWQgMCA6IHRoaXMuaHJlZiB8fCB2b2lkIDAsXG4gICAgICAgICAgcGFyYW1zOiB0aGlzLmNvbm5lY3RQYXJhbXMoKSxcbiAgICAgICAgICBzZXNzaW9uOiB0aGlzLmdldFNlc3Npb24oKSxcbiAgICAgICAgICBzdGF0aWM6IHRoaXMuZ2V0U3RhdGljKCksXG4gICAgICAgICAgZmxhc2g6IHRoaXMuZmxhc2hcbiAgICAgICAgfTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5zaG93TG9hZGVyKHRoaXMubGl2ZVNvY2tldC5sb2FkZXJUaW1lb3V0KTtcbiAgICAgIHRoaXMuYmluZENoYW5uZWwoKTtcbiAgICB9XG4gICAgc2V0SHJlZihocmVmKSB7XG4gICAgICB0aGlzLmhyZWYgPSBocmVmO1xuICAgIH1cbiAgICBzZXRSZWRpcmVjdChocmVmKSB7XG4gICAgICB0aGlzLnJlZGlyZWN0ID0gdHJ1ZTtcbiAgICAgIHRoaXMuaHJlZiA9IGhyZWY7XG4gICAgfVxuICAgIGlzTWFpbigpIHtcbiAgICAgIHJldHVybiB0aGlzLmxpdmVTb2NrZXQubWFpbiA9PT0gdGhpcztcbiAgICB9XG4gICAgY29ubmVjdFBhcmFtcygpIHtcbiAgICAgIGxldCBwYXJhbXMgPSB0aGlzLmxpdmVTb2NrZXQucGFyYW1zKHRoaXMuZWwpO1xuICAgICAgbGV0IG1hbmlmZXN0ID0gZG9tX2RlZmF1bHQuYWxsKGRvY3VtZW50LCBgWyR7dGhpcy5iaW5kaW5nKFBIWF9UUkFDS19TVEFUSUMpfV1gKS5tYXAoKG5vZGUpID0+IG5vZGUuc3JjIHx8IG5vZGUuaHJlZikuZmlsdGVyKCh1cmwpID0+IHR5cGVvZiB1cmwgPT09IFwic3RyaW5nXCIpO1xuICAgICAgaWYgKG1hbmlmZXN0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgcGFyYW1zW1wiX3RyYWNrX3N0YXRpY1wiXSA9IG1hbmlmZXN0O1xuICAgICAgfVxuICAgICAgcGFyYW1zW1wiX21vdW50c1wiXSA9IHRoaXMuam9pbkNvdW50O1xuICAgICAgcmV0dXJuIHBhcmFtcztcbiAgICB9XG4gICAgaXNDb25uZWN0ZWQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5jaGFubmVsLmNhblB1c2goKTtcbiAgICB9XG4gICAgZ2V0U2Vzc2lvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLmVsLmdldEF0dHJpYnV0ZShQSFhfU0VTU0lPTik7XG4gICAgfVxuICAgIGdldFN0YXRpYygpIHtcbiAgICAgIGxldCB2YWwgPSB0aGlzLmVsLmdldEF0dHJpYnV0ZShQSFhfU1RBVElDKTtcbiAgICAgIHJldHVybiB2YWwgPT09IFwiXCIgPyBudWxsIDogdmFsO1xuICAgIH1cbiAgICBkZXN0cm95KGNhbGxiYWNrID0gZnVuY3Rpb24oKSB7XG4gICAgfSkge1xuICAgICAgdGhpcy5kZXN0cm95QWxsQ2hpbGRyZW4oKTtcbiAgICAgIHRoaXMuZGVzdHJveWVkID0gdHJ1ZTtcbiAgICAgIGRlbGV0ZSB0aGlzLnJvb3QuY2hpbGRyZW5bdGhpcy5pZF07XG4gICAgICBpZiAodGhpcy5wYXJlbnQpIHtcbiAgICAgICAgZGVsZXRlIHRoaXMucm9vdC5jaGlsZHJlblt0aGlzLnBhcmVudC5pZF1bdGhpcy5pZF07XG4gICAgICB9XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy5sb2FkZXJUaW1lcik7XG4gICAgICBsZXQgb25GaW5pc2hlZCA9ICgpID0+IHtcbiAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgZm9yIChsZXQgaWQgaW4gdGhpcy52aWV3SG9va3MpIHtcbiAgICAgICAgICB0aGlzLmRlc3Ryb3lIb29rKHRoaXMudmlld0hvb2tzW2lkXSk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBkb21fZGVmYXVsdC5tYXJrUGh4Q2hpbGREZXN0cm95ZWQodGhpcy5lbCk7XG4gICAgICB0aGlzLmxvZyhcImRlc3Ryb3llZFwiLCAoKSA9PiBbXCJ0aGUgY2hpbGQgaGFzIGJlZW4gcmVtb3ZlZCBmcm9tIHRoZSBwYXJlbnRcIl0pO1xuICAgICAgdGhpcy5jaGFubmVsLmxlYXZlKCkucmVjZWl2ZShcIm9rXCIsIG9uRmluaXNoZWQpLnJlY2VpdmUoXCJlcnJvclwiLCBvbkZpbmlzaGVkKS5yZWNlaXZlKFwidGltZW91dFwiLCBvbkZpbmlzaGVkKTtcbiAgICB9XG4gICAgc2V0Q29udGFpbmVyQ2xhc3NlcyguLi5jbGFzc2VzKSB7XG4gICAgICB0aGlzLmVsLmNsYXNzTGlzdC5yZW1vdmUoUEhYX0NPTk5FQ1RFRF9DTEFTUywgUEhYX0RJU0NPTk5FQ1RFRF9DTEFTUywgUEhYX0VSUk9SX0NMQVNTKTtcbiAgICAgIHRoaXMuZWwuY2xhc3NMaXN0LmFkZCguLi5jbGFzc2VzKTtcbiAgICB9XG4gICAgc2hvd0xvYWRlcih0aW1lb3V0KSB7XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy5sb2FkZXJUaW1lcik7XG4gICAgICBpZiAodGltZW91dCkge1xuICAgICAgICB0aGlzLmxvYWRlclRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB0aGlzLnNob3dMb2FkZXIoKSwgdGltZW91dCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKGxldCBpZCBpbiB0aGlzLnZpZXdIb29rcykge1xuICAgICAgICAgIHRoaXMudmlld0hvb2tzW2lkXS5fX2Rpc2Nvbm5lY3RlZCgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2V0Q29udGFpbmVyQ2xhc3NlcyhQSFhfRElTQ09OTkVDVEVEX0NMQVNTKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaGlkZUxvYWRlcigpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLmxvYWRlclRpbWVyKTtcbiAgICAgIHRoaXMuc2V0Q29udGFpbmVyQ2xhc3NlcyhQSFhfQ09OTkVDVEVEX0NMQVNTKTtcbiAgICB9XG4gICAgdHJpZ2dlclJlY29ubmVjdGVkKCkge1xuICAgICAgZm9yIChsZXQgaWQgaW4gdGhpcy52aWV3SG9va3MpIHtcbiAgICAgICAgdGhpcy52aWV3SG9va3NbaWRdLl9fcmVjb25uZWN0ZWQoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgbG9nKGtpbmQsIG1zZ0NhbGxiYWNrKSB7XG4gICAgICB0aGlzLmxpdmVTb2NrZXQubG9nKHRoaXMsIGtpbmQsIG1zZ0NhbGxiYWNrKTtcbiAgICB9XG4gICAgdHJhbnNpdGlvbih0aW1lLCBvblN0YXJ0LCBvbkRvbmUgPSBmdW5jdGlvbigpIHtcbiAgICB9KSB7XG4gICAgICB0aGlzLmxpdmVTb2NrZXQudHJhbnNpdGlvbih0aW1lLCBvblN0YXJ0LCBvbkRvbmUpO1xuICAgIH1cbiAgICB3aXRoaW5UYXJnZXRzKHBoeFRhcmdldCwgY2FsbGJhY2spIHtcbiAgICAgIGlmIChwaHhUYXJnZXQgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCB8fCBwaHhUYXJnZXQgaW5zdGFuY2VvZiBTVkdFbGVtZW50KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxpdmVTb2NrZXQub3duZXIocGh4VGFyZ2V0LCAodmlldykgPT4gY2FsbGJhY2sodmlldywgcGh4VGFyZ2V0KSk7XG4gICAgICB9XG4gICAgICBpZiAoaXNDaWQocGh4VGFyZ2V0KSkge1xuICAgICAgICBsZXQgdGFyZ2V0cyA9IGRvbV9kZWZhdWx0LmZpbmRDb21wb25lbnROb2RlTGlzdCh0aGlzLmVsLCBwaHhUYXJnZXQpO1xuICAgICAgICBpZiAodGFyZ2V0cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICBsb2dFcnJvcihgbm8gY29tcG9uZW50IGZvdW5kIG1hdGNoaW5nIHBoeC10YXJnZXQgb2YgJHtwaHhUYXJnZXR9YCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY2FsbGJhY2sodGhpcywgcGFyc2VJbnQocGh4VGFyZ2V0KSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxldCB0YXJnZXRzID0gQXJyYXkuZnJvbShkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKHBoeFRhcmdldCkpO1xuICAgICAgICBpZiAodGFyZ2V0cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICBsb2dFcnJvcihgbm90aGluZyBmb3VuZCBtYXRjaGluZyB0aGUgcGh4LXRhcmdldCBzZWxlY3RvciBcIiR7cGh4VGFyZ2V0fVwiYCk7XG4gICAgICAgIH1cbiAgICAgICAgdGFyZ2V0cy5mb3JFYWNoKCh0YXJnZXQpID0+IHRoaXMubGl2ZVNvY2tldC5vd25lcih0YXJnZXQsICh2aWV3KSA9PiBjYWxsYmFjayh2aWV3LCB0YXJnZXQpKSk7XG4gICAgICB9XG4gICAgfVxuICAgIGFwcGx5RGlmZih0eXBlLCByYXdEaWZmLCBjYWxsYmFjaykge1xuICAgICAgdGhpcy5sb2codHlwZSwgKCkgPT4gW1wiXCIsIGNsb25lKHJhd0RpZmYpXSk7XG4gICAgICBsZXQgeyBkaWZmLCByZXBseSwgZXZlbnRzLCB0aXRsZSB9ID0gUmVuZGVyZWQuZXh0cmFjdChyYXdEaWZmKTtcbiAgICAgIGlmICh0aXRsZSkge1xuICAgICAgICBkb21fZGVmYXVsdC5wdXRUaXRsZSh0aXRsZSk7XG4gICAgICB9XG4gICAgICBjYWxsYmFjayh7IGRpZmYsIHJlcGx5LCBldmVudHMgfSk7XG4gICAgICByZXR1cm4gcmVwbHk7XG4gICAgfVxuICAgIG9uSm9pbihyZXNwKSB7XG4gICAgICBsZXQgeyByZW5kZXJlZCwgY29udGFpbmVyIH0gPSByZXNwO1xuICAgICAgaWYgKGNvbnRhaW5lcikge1xuICAgICAgICBsZXQgW3RhZywgYXR0cnNdID0gY29udGFpbmVyO1xuICAgICAgICB0aGlzLmVsID0gZG9tX2RlZmF1bHQucmVwbGFjZVJvb3RDb250YWluZXIodGhpcy5lbCwgdGFnLCBhdHRycyk7XG4gICAgICB9XG4gICAgICB0aGlzLmNoaWxkSm9pbnMgPSAwO1xuICAgICAgdGhpcy5qb2luUGVuZGluZyA9IHRydWU7XG4gICAgICB0aGlzLmZsYXNoID0gbnVsbDtcbiAgICAgIGJyb3dzZXJfZGVmYXVsdC5kcm9wTG9jYWwodGhpcy5saXZlU29ja2V0LmxvY2FsU3RvcmFnZSwgd2luZG93LmxvY2F0aW9uLnBhdGhuYW1lLCBDT05TRUNVVElWRV9SRUxPQURTKTtcbiAgICAgIHRoaXMuYXBwbHlEaWZmKFwibW91bnRcIiwgcmVuZGVyZWQsICh7IGRpZmYsIGV2ZW50cyB9KSA9PiB7XG4gICAgICAgIHRoaXMucmVuZGVyZWQgPSBuZXcgUmVuZGVyZWQodGhpcy5pZCwgZGlmZik7XG4gICAgICAgIGxldCBodG1sID0gdGhpcy5yZW5kZXJDb250YWluZXIobnVsbCwgXCJqb2luXCIpO1xuICAgICAgICB0aGlzLmRyb3BQZW5kaW5nUmVmcygpO1xuICAgICAgICBsZXQgZm9ybXMgPSB0aGlzLmZvcm1zRm9yUmVjb3ZlcnkoaHRtbCk7XG4gICAgICAgIHRoaXMuam9pbkNvdW50Kys7XG4gICAgICAgIGlmIChmb3Jtcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgZm9ybXMuZm9yRWFjaCgoW2Zvcm0sIG5ld0Zvcm0sIG5ld0NpZF0sIGkpID0+IHtcbiAgICAgICAgICAgIHRoaXMucHVzaEZvcm1SZWNvdmVyeShmb3JtLCBuZXdDaWQsIChyZXNwMikgPT4ge1xuICAgICAgICAgICAgICBpZiAoaSA9PT0gZm9ybXMubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAgIHRoaXMub25Kb2luQ29tcGxldGUocmVzcDIsIGh0bWwsIGV2ZW50cyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMub25Kb2luQ29tcGxldGUocmVzcCwgaHRtbCwgZXZlbnRzKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIGRyb3BQZW5kaW5nUmVmcygpIHtcbiAgICAgIGRvbV9kZWZhdWx0LmFsbCh0aGlzLmVsLCBgWyR7UEhYX1JFRn1dYCwgKGVsKSA9PiBlbC5yZW1vdmVBdHRyaWJ1dGUoUEhYX1JFRikpO1xuICAgIH1cbiAgICBvbkpvaW5Db21wbGV0ZSh7IGxpdmVfcGF0Y2ggfSwgaHRtbCwgZXZlbnRzKSB7XG4gICAgICBpZiAodGhpcy5qb2luQ291bnQgPiAxIHx8IHRoaXMucGFyZW50ICYmICF0aGlzLnBhcmVudC5pc0pvaW5QZW5kaW5nKCkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXBwbHlKb2luUGF0Y2gobGl2ZV9wYXRjaCwgaHRtbCwgZXZlbnRzKTtcbiAgICAgIH1cbiAgICAgIGxldCBuZXdDaGlsZHJlbiA9IGRvbV9kZWZhdWx0LmZpbmRQaHhDaGlsZHJlbkluRnJhZ21lbnQoaHRtbCwgdGhpcy5pZCkuZmlsdGVyKCh0b0VsKSA9PiB7XG4gICAgICAgIGxldCBmcm9tRWwgPSB0b0VsLmlkICYmIHRoaXMuZWwucXVlcnlTZWxlY3RvcihgW2lkPVwiJHt0b0VsLmlkfVwiXWApO1xuICAgICAgICBsZXQgcGh4U3RhdGljID0gZnJvbUVsICYmIGZyb21FbC5nZXRBdHRyaWJ1dGUoUEhYX1NUQVRJQyk7XG4gICAgICAgIGlmIChwaHhTdGF0aWMpIHtcbiAgICAgICAgICB0b0VsLnNldEF0dHJpYnV0ZShQSFhfU1RBVElDLCBwaHhTdGF0aWMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmpvaW5DaGlsZCh0b0VsKTtcbiAgICAgIH0pO1xuICAgICAgaWYgKG5ld0NoaWxkcmVuLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBpZiAodGhpcy5wYXJlbnQpIHtcbiAgICAgICAgICB0aGlzLnJvb3QucGVuZGluZ0pvaW5PcHMucHVzaChbdGhpcywgKCkgPT4gdGhpcy5hcHBseUpvaW5QYXRjaChsaXZlX3BhdGNoLCBodG1sLCBldmVudHMpXSk7XG4gICAgICAgICAgdGhpcy5wYXJlbnQuYWNrSm9pbih0aGlzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLm9uQWxsQ2hpbGRKb2luc0NvbXBsZXRlKCk7XG4gICAgICAgICAgdGhpcy5hcHBseUpvaW5QYXRjaChsaXZlX3BhdGNoLCBodG1sLCBldmVudHMpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnJvb3QucGVuZGluZ0pvaW5PcHMucHVzaChbdGhpcywgKCkgPT4gdGhpcy5hcHBseUpvaW5QYXRjaChsaXZlX3BhdGNoLCBodG1sLCBldmVudHMpXSk7XG4gICAgICB9XG4gICAgfVxuICAgIGF0dGFjaFRydWVEb2NFbCgpIHtcbiAgICAgIHRoaXMuZWwgPSBkb21fZGVmYXVsdC5ieUlkKHRoaXMuaWQpO1xuICAgICAgdGhpcy5lbC5zZXRBdHRyaWJ1dGUoUEhYX1JPT1RfSUQsIHRoaXMucm9vdC5pZCk7XG4gICAgfVxuICAgIGFwcGx5Sm9pblBhdGNoKGxpdmVfcGF0Y2gsIGh0bWwsIGV2ZW50cykge1xuICAgICAgdGhpcy5hdHRhY2hUcnVlRG9jRWwoKTtcbiAgICAgIGxldCBwYXRjaCA9IG5ldyBET01QYXRjaCh0aGlzLCB0aGlzLmVsLCB0aGlzLmlkLCBodG1sLCBudWxsKTtcbiAgICAgIHBhdGNoLm1hcmtQcnVuYWJsZUNvbnRlbnRGb3JSZW1vdmFsKCk7XG4gICAgICB0aGlzLnBlcmZvcm1QYXRjaChwYXRjaCwgZmFsc2UpO1xuICAgICAgdGhpcy5qb2luTmV3Q2hpbGRyZW4oKTtcbiAgICAgIGRvbV9kZWZhdWx0LmFsbCh0aGlzLmVsLCBgWyR7dGhpcy5iaW5kaW5nKFBIWF9IT09LKX1dLCBbZGF0YS1waHgtJHtQSFhfSE9PS31dYCwgKGhvb2tFbCkgPT4ge1xuICAgICAgICBsZXQgaG9vayA9IHRoaXMuYWRkSG9vayhob29rRWwpO1xuICAgICAgICBpZiAoaG9vaykge1xuICAgICAgICAgIGhvb2suX19tb3VudGVkKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgdGhpcy5qb2luUGVuZGluZyA9IGZhbHNlO1xuICAgICAgdGhpcy5saXZlU29ja2V0LmRpc3BhdGNoRXZlbnRzKGV2ZW50cyk7XG4gICAgICB0aGlzLmFwcGx5UGVuZGluZ1VwZGF0ZXMoKTtcbiAgICAgIGlmIChsaXZlX3BhdGNoKSB7XG4gICAgICAgIGxldCB7IGtpbmQsIHRvIH0gPSBsaXZlX3BhdGNoO1xuICAgICAgICB0aGlzLmxpdmVTb2NrZXQuaGlzdG9yeVBhdGNoKHRvLCBraW5kKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuaGlkZUxvYWRlcigpO1xuICAgICAgaWYgKHRoaXMuam9pbkNvdW50ID4gMSkge1xuICAgICAgICB0aGlzLnRyaWdnZXJSZWNvbm5lY3RlZCgpO1xuICAgICAgfVxuICAgICAgdGhpcy5zdG9wQ2FsbGJhY2soKTtcbiAgICB9XG4gICAgdHJpZ2dlckJlZm9yZVVwZGF0ZUhvb2soZnJvbUVsLCB0b0VsKSB7XG4gICAgICB0aGlzLmxpdmVTb2NrZXQudHJpZ2dlckRPTShcIm9uQmVmb3JlRWxVcGRhdGVkXCIsIFtmcm9tRWwsIHRvRWxdKTtcbiAgICAgIGxldCBob29rID0gdGhpcy5nZXRIb29rKGZyb21FbCk7XG4gICAgICBsZXQgaXNJZ25vcmVkID0gaG9vayAmJiBkb21fZGVmYXVsdC5pc0lnbm9yZWQoZnJvbUVsLCB0aGlzLmJpbmRpbmcoUEhYX1VQREFURSkpO1xuICAgICAgaWYgKGhvb2sgJiYgIWZyb21FbC5pc0VxdWFsTm9kZSh0b0VsKSAmJiAhKGlzSWdub3JlZCAmJiBpc0VxdWFsT2JqKGZyb21FbC5kYXRhc2V0LCB0b0VsLmRhdGFzZXQpKSkge1xuICAgICAgICBob29rLl9fYmVmb3JlVXBkYXRlKCk7XG4gICAgICAgIHJldHVybiBob29rO1xuICAgICAgfVxuICAgIH1cbiAgICBwZXJmb3JtUGF0Y2gocGF0Y2gsIHBydW5lQ2lkcykge1xuICAgICAgbGV0IHJlbW92ZWRFbHMgPSBbXTtcbiAgICAgIGxldCBwaHhDaGlsZHJlbkFkZGVkID0gZmFsc2U7XG4gICAgICBsZXQgdXBkYXRlZEhvb2tJZHMgPSBuZXcgU2V0KCk7XG4gICAgICBwYXRjaC5hZnRlcihcImFkZGVkXCIsIChlbCkgPT4ge1xuICAgICAgICB0aGlzLmxpdmVTb2NrZXQudHJpZ2dlckRPTShcIm9uTm9kZUFkZGVkXCIsIFtlbF0pO1xuICAgICAgICBsZXQgbmV3SG9vayA9IHRoaXMuYWRkSG9vayhlbCk7XG4gICAgICAgIGlmIChuZXdIb29rKSB7XG4gICAgICAgICAgbmV3SG9vay5fX21vdW50ZWQoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBwYXRjaC5hZnRlcihcInBoeENoaWxkQWRkZWRcIiwgKF9lbCkgPT4gcGh4Q2hpbGRyZW5BZGRlZCA9IHRydWUpO1xuICAgICAgcGF0Y2guYmVmb3JlKFwidXBkYXRlZFwiLCAoZnJvbUVsLCB0b0VsKSA9PiB7XG4gICAgICAgIGxldCBob29rID0gdGhpcy50cmlnZ2VyQmVmb3JlVXBkYXRlSG9vayhmcm9tRWwsIHRvRWwpO1xuICAgICAgICBpZiAoaG9vaykge1xuICAgICAgICAgIHVwZGF0ZWRIb29rSWRzLmFkZChmcm9tRWwuaWQpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHBhdGNoLmFmdGVyKFwidXBkYXRlZFwiLCAoZWwpID0+IHtcbiAgICAgICAgaWYgKHVwZGF0ZWRIb29rSWRzLmhhcyhlbC5pZCkpIHtcbiAgICAgICAgICB0aGlzLmdldEhvb2soZWwpLl9fdXBkYXRlZCgpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHBhdGNoLmFmdGVyKFwiZGlzY2FyZGVkXCIsIChlbCkgPT4ge1xuICAgICAgICBpZiAoZWwubm9kZVR5cGUgPT09IE5vZGUuRUxFTUVOVF9OT0RFKSB7XG4gICAgICAgICAgcmVtb3ZlZEVscy5wdXNoKGVsKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBwYXRjaC5hZnRlcihcInRyYW5zaXRpb25zRGlzY2FyZGVkXCIsIChlbHMpID0+IHRoaXMuYWZ0ZXJFbGVtZW50c1JlbW92ZWQoZWxzLCBwcnVuZUNpZHMpKTtcbiAgICAgIHBhdGNoLnBlcmZvcm0oKTtcbiAgICAgIHRoaXMuYWZ0ZXJFbGVtZW50c1JlbW92ZWQocmVtb3ZlZEVscywgcHJ1bmVDaWRzKTtcbiAgICAgIHJldHVybiBwaHhDaGlsZHJlbkFkZGVkO1xuICAgIH1cbiAgICBhZnRlckVsZW1lbnRzUmVtb3ZlZChlbGVtZW50cywgcHJ1bmVDaWRzKSB7XG4gICAgICBsZXQgZGVzdHJveWVkQ0lEcyA9IFtdO1xuICAgICAgZWxlbWVudHMuZm9yRWFjaCgocGFyZW50KSA9PiB7XG4gICAgICAgIGxldCBjb21wb25lbnRzID0gZG9tX2RlZmF1bHQuYWxsKHBhcmVudCwgYFske1BIWF9DT01QT05FTlR9XWApO1xuICAgICAgICBjb21wb25lbnRzLmNvbmNhdChwYXJlbnQpLmZvckVhY2goKGVsKSA9PiB7XG4gICAgICAgICAgbGV0IGNpZCA9IHRoaXMuY29tcG9uZW50SUQoZWwpO1xuICAgICAgICAgIGlmIChpc0NpZChjaWQpICYmIGRlc3Ryb3llZENJRHMuaW5kZXhPZihjaWQpID09PSAtMSkge1xuICAgICAgICAgICAgZGVzdHJveWVkQ0lEcy5wdXNoKGNpZCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGxldCBob29rID0gdGhpcy5nZXRIb29rKGVsKTtcbiAgICAgICAgICBob29rICYmIHRoaXMuZGVzdHJveUhvb2soaG9vayk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgICBpZiAocHJ1bmVDaWRzKSB7XG4gICAgICAgIHRoaXMubWF5YmVQdXNoQ29tcG9uZW50c0Rlc3Ryb3llZChkZXN0cm95ZWRDSURzKTtcbiAgICAgIH1cbiAgICB9XG4gICAgam9pbk5ld0NoaWxkcmVuKCkge1xuICAgICAgZG9tX2RlZmF1bHQuZmluZFBoeENoaWxkcmVuKHRoaXMuZWwsIHRoaXMuaWQpLmZvckVhY2goKGVsKSA9PiB0aGlzLmpvaW5DaGlsZChlbCkpO1xuICAgIH1cbiAgICBnZXRDaGlsZEJ5SWQoaWQpIHtcbiAgICAgIHJldHVybiB0aGlzLnJvb3QuY2hpbGRyZW5bdGhpcy5pZF1baWRdO1xuICAgIH1cbiAgICBnZXREZXNjZW5kZW50QnlFbChlbCkge1xuICAgICAgaWYgKGVsLmlkID09PSB0aGlzLmlkKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hpbGRyZW5bZWwuZ2V0QXR0cmlidXRlKFBIWF9QQVJFTlRfSUQpXVtlbC5pZF07XG4gICAgICB9XG4gICAgfVxuICAgIGRlc3Ryb3lEZXNjZW5kZW50KGlkKSB7XG4gICAgICBmb3IgKGxldCBwYXJlbnRJZCBpbiB0aGlzLnJvb3QuY2hpbGRyZW4pIHtcbiAgICAgICAgZm9yIChsZXQgY2hpbGRJZCBpbiB0aGlzLnJvb3QuY2hpbGRyZW5bcGFyZW50SWRdKSB7XG4gICAgICAgICAgaWYgKGNoaWxkSWQgPT09IGlkKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yb290LmNoaWxkcmVuW3BhcmVudElkXVtjaGlsZElkXS5kZXN0cm95KCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGpvaW5DaGlsZChlbCkge1xuICAgICAgbGV0IGNoaWxkID0gdGhpcy5nZXRDaGlsZEJ5SWQoZWwuaWQpO1xuICAgICAgaWYgKCFjaGlsZCkge1xuICAgICAgICBsZXQgdmlldyA9IG5ldyBWaWV3KGVsLCB0aGlzLmxpdmVTb2NrZXQsIHRoaXMpO1xuICAgICAgICB0aGlzLnJvb3QuY2hpbGRyZW5bdGhpcy5pZF1bdmlldy5pZF0gPSB2aWV3O1xuICAgICAgICB2aWV3LmpvaW4oKTtcbiAgICAgICAgdGhpcy5jaGlsZEpvaW5zKys7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICBpc0pvaW5QZW5kaW5nKCkge1xuICAgICAgcmV0dXJuIHRoaXMuam9pblBlbmRpbmc7XG4gICAgfVxuICAgIGFja0pvaW4oX2NoaWxkKSB7XG4gICAgICB0aGlzLmNoaWxkSm9pbnMtLTtcbiAgICAgIGlmICh0aGlzLmNoaWxkSm9pbnMgPT09IDApIHtcbiAgICAgICAgaWYgKHRoaXMucGFyZW50KSB7XG4gICAgICAgICAgdGhpcy5wYXJlbnQuYWNrSm9pbih0aGlzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLm9uQWxsQ2hpbGRKb2luc0NvbXBsZXRlKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgb25BbGxDaGlsZEpvaW5zQ29tcGxldGUoKSB7XG4gICAgICB0aGlzLmpvaW5DYWxsYmFjaygoKSA9PiB7XG4gICAgICAgIHRoaXMucGVuZGluZ0pvaW5PcHMuZm9yRWFjaCgoW3ZpZXcsIG9wXSkgPT4ge1xuICAgICAgICAgIGlmICghdmlldy5pc0Rlc3Ryb3llZCgpKSB7XG4gICAgICAgICAgICBvcCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucGVuZGluZ0pvaW5PcHMgPSBbXTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICB1cGRhdGUoZGlmZiwgZXZlbnRzKSB7XG4gICAgICBpZiAodGhpcy5pc0pvaW5QZW5kaW5nKCkgfHwgdGhpcy5saXZlU29ja2V0Lmhhc1BlbmRpbmdMaW5rKCkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGVuZGluZ0RpZmZzLnB1c2goeyBkaWZmLCBldmVudHMgfSk7XG4gICAgICB9XG4gICAgICB0aGlzLnJlbmRlcmVkLm1lcmdlRGlmZihkaWZmKTtcbiAgICAgIGxldCBwaHhDaGlsZHJlbkFkZGVkID0gZmFsc2U7XG4gICAgICBpZiAodGhpcy5yZW5kZXJlZC5pc0NvbXBvbmVudE9ubHlEaWZmKGRpZmYpKSB7XG4gICAgICAgIHRoaXMubGl2ZVNvY2tldC50aW1lKFwiY29tcG9uZW50IHBhdGNoIGNvbXBsZXRlXCIsICgpID0+IHtcbiAgICAgICAgICBsZXQgcGFyZW50Q2lkcyA9IGRvbV9kZWZhdWx0LmZpbmRQYXJlbnRDSURzKHRoaXMuZWwsIHRoaXMucmVuZGVyZWQuY29tcG9uZW50Q0lEcyhkaWZmKSk7XG4gICAgICAgICAgcGFyZW50Q2lkcy5mb3JFYWNoKChwYXJlbnRDSUQpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbXBvbmVudFBhdGNoKHRoaXMucmVuZGVyZWQuZ2V0Q29tcG9uZW50KGRpZmYsIHBhcmVudENJRCksIHBhcmVudENJRCkpIHtcbiAgICAgICAgICAgICAgcGh4Q2hpbGRyZW5BZGRlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIGlmICghaXNFbXB0eShkaWZmKSkge1xuICAgICAgICB0aGlzLmxpdmVTb2NrZXQudGltZShcImZ1bGwgcGF0Y2ggY29tcGxldGVcIiwgKCkgPT4ge1xuICAgICAgICAgIGxldCBodG1sID0gdGhpcy5yZW5kZXJDb250YWluZXIoZGlmZiwgXCJ1cGRhdGVcIik7XG4gICAgICAgICAgbGV0IHBhdGNoID0gbmV3IERPTVBhdGNoKHRoaXMsIHRoaXMuZWwsIHRoaXMuaWQsIGh0bWwsIG51bGwpO1xuICAgICAgICAgIHBoeENoaWxkcmVuQWRkZWQgPSB0aGlzLnBlcmZvcm1QYXRjaChwYXRjaCwgdHJ1ZSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgdGhpcy5saXZlU29ja2V0LmRpc3BhdGNoRXZlbnRzKGV2ZW50cyk7XG4gICAgICBpZiAocGh4Q2hpbGRyZW5BZGRlZCkge1xuICAgICAgICB0aGlzLmpvaW5OZXdDaGlsZHJlbigpO1xuICAgICAgfVxuICAgIH1cbiAgICByZW5kZXJDb250YWluZXIoZGlmZiwga2luZCkge1xuICAgICAgcmV0dXJuIHRoaXMubGl2ZVNvY2tldC50aW1lKGB0b1N0cmluZyBkaWZmICgke2tpbmR9KWAsICgpID0+IHtcbiAgICAgICAgbGV0IHRhZyA9IHRoaXMuZWwudGFnTmFtZTtcbiAgICAgICAgbGV0IGNpZHMgPSBkaWZmID8gdGhpcy5yZW5kZXJlZC5jb21wb25lbnRDSURzKGRpZmYpLmNvbmNhdCh0aGlzLnBydW5pbmdDSURzKSA6IG51bGw7XG4gICAgICAgIGxldCBodG1sID0gdGhpcy5yZW5kZXJlZC50b1N0cmluZyhjaWRzKTtcbiAgICAgICAgcmV0dXJuIGA8JHt0YWd9PiR7aHRtbH08LyR7dGFnfT5gO1xuICAgICAgfSk7XG4gICAgfVxuICAgIGNvbXBvbmVudFBhdGNoKGRpZmYsIGNpZCkge1xuICAgICAgaWYgKGlzRW1wdHkoZGlmZikpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIGxldCBodG1sID0gdGhpcy5yZW5kZXJlZC5jb21wb25lbnRUb1N0cmluZyhjaWQpO1xuICAgICAgbGV0IHBhdGNoID0gbmV3IERPTVBhdGNoKHRoaXMsIHRoaXMuZWwsIHRoaXMuaWQsIGh0bWwsIGNpZCk7XG4gICAgICBsZXQgY2hpbGRyZW5BZGRlZCA9IHRoaXMucGVyZm9ybVBhdGNoKHBhdGNoLCB0cnVlKTtcbiAgICAgIHJldHVybiBjaGlsZHJlbkFkZGVkO1xuICAgIH1cbiAgICBnZXRIb29rKGVsKSB7XG4gICAgICByZXR1cm4gdGhpcy52aWV3SG9va3NbVmlld0hvb2suZWxlbWVudElEKGVsKV07XG4gICAgfVxuICAgIGFkZEhvb2soZWwpIHtcbiAgICAgIGlmIChWaWV3SG9vay5lbGVtZW50SUQoZWwpIHx8ICFlbC5nZXRBdHRyaWJ1dGUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgbGV0IGhvb2tOYW1lID0gZWwuZ2V0QXR0cmlidXRlKGBkYXRhLXBoeC0ke1BIWF9IT09LfWApIHx8IGVsLmdldEF0dHJpYnV0ZSh0aGlzLmJpbmRpbmcoUEhYX0hPT0spKTtcbiAgICAgIGlmIChob29rTmFtZSAmJiAhdGhpcy5vd25zRWxlbWVudChlbCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgbGV0IGNhbGxiYWNrcyA9IHRoaXMubGl2ZVNvY2tldC5nZXRIb29rQ2FsbGJhY2tzKGhvb2tOYW1lKTtcbiAgICAgIGlmIChjYWxsYmFja3MpIHtcbiAgICAgICAgaWYgKCFlbC5pZCkge1xuICAgICAgICAgIGxvZ0Vycm9yKGBubyBET00gSUQgZm9yIGhvb2sgXCIke2hvb2tOYW1lfVwiLiBIb29rcyByZXF1aXJlIGEgdW5pcXVlIElEIG9uIGVhY2ggZWxlbWVudC5gLCBlbCk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGhvb2sgPSBuZXcgVmlld0hvb2sodGhpcywgZWwsIGNhbGxiYWNrcyk7XG4gICAgICAgIHRoaXMudmlld0hvb2tzW1ZpZXdIb29rLmVsZW1lbnRJRChob29rLmVsKV0gPSBob29rO1xuICAgICAgICByZXR1cm4gaG9vaztcbiAgICAgIH0gZWxzZSBpZiAoaG9va05hbWUgIT09IG51bGwpIHtcbiAgICAgICAgbG9nRXJyb3IoYHVua25vd24gaG9vayBmb3VuZCBmb3IgXCIke2hvb2tOYW1lfVwiYCwgZWwpO1xuICAgICAgfVxuICAgIH1cbiAgICBkZXN0cm95SG9vayhob29rKSB7XG4gICAgICBob29rLl9fZGVzdHJveWVkKCk7XG4gICAgICBob29rLl9fY2xlYW51cF9fKCk7XG4gICAgICBkZWxldGUgdGhpcy52aWV3SG9va3NbVmlld0hvb2suZWxlbWVudElEKGhvb2suZWwpXTtcbiAgICB9XG4gICAgYXBwbHlQZW5kaW5nVXBkYXRlcygpIHtcbiAgICAgIHRoaXMucGVuZGluZ0RpZmZzLmZvckVhY2goKHsgZGlmZiwgZXZlbnRzIH0pID0+IHRoaXMudXBkYXRlKGRpZmYsIGV2ZW50cykpO1xuICAgICAgdGhpcy5wZW5kaW5nRGlmZnMgPSBbXTtcbiAgICB9XG4gICAgb25DaGFubmVsKGV2ZW50LCBjYikge1xuICAgICAgdGhpcy5saXZlU29ja2V0Lm9uQ2hhbm5lbCh0aGlzLmNoYW5uZWwsIGV2ZW50LCAocmVzcCkgPT4ge1xuICAgICAgICBpZiAodGhpcy5pc0pvaW5QZW5kaW5nKCkpIHtcbiAgICAgICAgICB0aGlzLnJvb3QucGVuZGluZ0pvaW5PcHMucHVzaChbdGhpcywgKCkgPT4gY2IocmVzcCldKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmxpdmVTb2NrZXQucmVxdWVzdERPTVVwZGF0ZSgoKSA9PiBjYihyZXNwKSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICBiaW5kQ2hhbm5lbCgpIHtcbiAgICAgIHRoaXMubGl2ZVNvY2tldC5vbkNoYW5uZWwodGhpcy5jaGFubmVsLCBcImRpZmZcIiwgKHJhd0RpZmYpID0+IHtcbiAgICAgICAgdGhpcy5saXZlU29ja2V0LnJlcXVlc3RET01VcGRhdGUoKCkgPT4ge1xuICAgICAgICAgIHRoaXMuYXBwbHlEaWZmKFwidXBkYXRlXCIsIHJhd0RpZmYsICh7IGRpZmYsIGV2ZW50cyB9KSA9PiB0aGlzLnVwZGF0ZShkaWZmLCBldmVudHMpKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMub25DaGFubmVsKFwicmVkaXJlY3RcIiwgKHsgdG8sIGZsYXNoIH0pID0+IHRoaXMub25SZWRpcmVjdCh7IHRvLCBmbGFzaCB9KSk7XG4gICAgICB0aGlzLm9uQ2hhbm5lbChcImxpdmVfcGF0Y2hcIiwgKHJlZGlyKSA9PiB0aGlzLm9uTGl2ZVBhdGNoKHJlZGlyKSk7XG4gICAgICB0aGlzLm9uQ2hhbm5lbChcImxpdmVfcmVkaXJlY3RcIiwgKHJlZGlyKSA9PiB0aGlzLm9uTGl2ZVJlZGlyZWN0KHJlZGlyKSk7XG4gICAgICB0aGlzLmNoYW5uZWwub25FcnJvcigocmVhc29uKSA9PiB0aGlzLm9uRXJyb3IocmVhc29uKSk7XG4gICAgICB0aGlzLmNoYW5uZWwub25DbG9zZSgocmVhc29uKSA9PiB0aGlzLm9uQ2xvc2UocmVhc29uKSk7XG4gICAgfVxuICAgIGRlc3Ryb3lBbGxDaGlsZHJlbigpIHtcbiAgICAgIGZvciAobGV0IGlkIGluIHRoaXMucm9vdC5jaGlsZHJlblt0aGlzLmlkXSkge1xuICAgICAgICB0aGlzLmdldENoaWxkQnlJZChpZCkuZGVzdHJveSgpO1xuICAgICAgfVxuICAgIH1cbiAgICBvbkxpdmVSZWRpcmVjdChyZWRpcikge1xuICAgICAgbGV0IHsgdG8sIGtpbmQsIGZsYXNoIH0gPSByZWRpcjtcbiAgICAgIGxldCB1cmwgPSB0aGlzLmV4cGFuZFVSTCh0byk7XG4gICAgICB0aGlzLmxpdmVTb2NrZXQuaGlzdG9yeVJlZGlyZWN0KHVybCwga2luZCwgZmxhc2gpO1xuICAgIH1cbiAgICBvbkxpdmVQYXRjaChyZWRpcikge1xuICAgICAgbGV0IHsgdG8sIGtpbmQgfSA9IHJlZGlyO1xuICAgICAgdGhpcy5ocmVmID0gdGhpcy5leHBhbmRVUkwodG8pO1xuICAgICAgdGhpcy5saXZlU29ja2V0Lmhpc3RvcnlQYXRjaCh0bywga2luZCk7XG4gICAgfVxuICAgIGV4cGFuZFVSTCh0bykge1xuICAgICAgcmV0dXJuIHRvLnN0YXJ0c1dpdGgoXCIvXCIpID8gYCR7d2luZG93LmxvY2F0aW9uLnByb3RvY29sfS8vJHt3aW5kb3cubG9jYXRpb24uaG9zdH0ke3RvfWAgOiB0bztcbiAgICB9XG4gICAgb25SZWRpcmVjdCh7IHRvLCBmbGFzaCB9KSB7XG4gICAgICB0aGlzLmxpdmVTb2NrZXQucmVkaXJlY3QodG8sIGZsYXNoKTtcbiAgICB9XG4gICAgaXNEZXN0cm95ZWQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5kZXN0cm95ZWQ7XG4gICAgfVxuICAgIGpvaW4oY2FsbGJhY2spIHtcbiAgICAgIGlmICghdGhpcy5wYXJlbnQpIHtcbiAgICAgICAgdGhpcy5zdG9wQ2FsbGJhY2sgPSB0aGlzLmxpdmVTb2NrZXQud2l0aFBhZ2VMb2FkaW5nKHsgdG86IHRoaXMuaHJlZiwga2luZDogXCJpbml0aWFsXCIgfSk7XG4gICAgICB9XG4gICAgICB0aGlzLmpvaW5DYWxsYmFjayA9IChvbkRvbmUpID0+IHtcbiAgICAgICAgb25Eb25lID0gb25Eb25lIHx8IGZ1bmN0aW9uKCkge1xuICAgICAgICB9O1xuICAgICAgICBjYWxsYmFjayA/IGNhbGxiYWNrKHRoaXMuam9pbkNvdW50LCBvbkRvbmUpIDogb25Eb25lKCk7XG4gICAgICB9O1xuICAgICAgdGhpcy5saXZlU29ja2V0LndyYXBQdXNoKHRoaXMsIHsgdGltZW91dDogZmFsc2UgfSwgKCkgPT4ge1xuICAgICAgICByZXR1cm4gdGhpcy5jaGFubmVsLmpvaW4oKS5yZWNlaXZlKFwib2tcIiwgKGRhdGEpID0+IHtcbiAgICAgICAgICBpZiAoIXRoaXMuaXNEZXN0cm95ZWQoKSkge1xuICAgICAgICAgICAgdGhpcy5saXZlU29ja2V0LnJlcXVlc3RET01VcGRhdGUoKCkgPT4gdGhpcy5vbkpvaW4oZGF0YSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSkucmVjZWl2ZShcImVycm9yXCIsIChyZXNwKSA9PiAhdGhpcy5pc0Rlc3Ryb3llZCgpICYmIHRoaXMub25Kb2luRXJyb3IocmVzcCkpLnJlY2VpdmUoXCJ0aW1lb3V0XCIsICgpID0+ICF0aGlzLmlzRGVzdHJveWVkKCkgJiYgdGhpcy5vbkpvaW5FcnJvcih7IHJlYXNvbjogXCJ0aW1lb3V0XCIgfSkpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIG9uSm9pbkVycm9yKHJlc3ApIHtcbiAgICAgIGlmIChyZXNwLnJlYXNvbiA9PT0gXCJ1bmF1dGhvcml6ZWRcIiB8fCByZXNwLnJlYXNvbiA9PT0gXCJzdGFsZVwiKSB7XG4gICAgICAgIHRoaXMubG9nKFwiZXJyb3JcIiwgKCkgPT4gW1widW5hdXRob3JpemVkIGxpdmVfcmVkaXJlY3QuIEZhbGxpbmcgYmFjayB0byBwYWdlIHJlcXVlc3RcIiwgcmVzcF0pO1xuICAgICAgICByZXR1cm4gdGhpcy5vblJlZGlyZWN0KHsgdG86IHRoaXMuaHJlZiB9KTtcbiAgICAgIH1cbiAgICAgIGlmIChyZXNwLnJlZGlyZWN0IHx8IHJlc3AubGl2ZV9yZWRpcmVjdCkge1xuICAgICAgICB0aGlzLmpvaW5QZW5kaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuY2hhbm5lbC5sZWF2ZSgpO1xuICAgICAgfVxuICAgICAgaWYgKHJlc3AucmVkaXJlY3QpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub25SZWRpcmVjdChyZXNwLnJlZGlyZWN0KTtcbiAgICAgIH1cbiAgICAgIGlmIChyZXNwLmxpdmVfcmVkaXJlY3QpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub25MaXZlUmVkaXJlY3QocmVzcC5saXZlX3JlZGlyZWN0KTtcbiAgICAgIH1cbiAgICAgIHRoaXMubG9nKFwiZXJyb3JcIiwgKCkgPT4gW1widW5hYmxlIHRvIGpvaW5cIiwgcmVzcF0pO1xuICAgICAgcmV0dXJuIHRoaXMubGl2ZVNvY2tldC5yZWxvYWRXaXRoSml0dGVyKHRoaXMpO1xuICAgIH1cbiAgICBvbkNsb3NlKHJlYXNvbikge1xuICAgICAgaWYgKHRoaXMuaXNEZXN0cm95ZWQoKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5pc0pvaW5QZW5kaW5nKCkgJiYgZG9jdW1lbnQudmlzaWJpbGl0eVN0YXRlICE9PSBcImhpZGRlblwiIHx8IHRoaXMubGl2ZVNvY2tldC5oYXNQZW5kaW5nTGluaygpICYmIHJlYXNvbiAhPT0gXCJsZWF2ZVwiKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxpdmVTb2NrZXQucmVsb2FkV2l0aEppdHRlcih0aGlzKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuZGVzdHJveUFsbENoaWxkcmVuKCk7XG4gICAgICB0aGlzLmxpdmVTb2NrZXQuZHJvcEFjdGl2ZUVsZW1lbnQodGhpcyk7XG4gICAgICBpZiAoZG9jdW1lbnQuYWN0aXZlRWxlbWVudCkge1xuICAgICAgICBkb2N1bWVudC5hY3RpdmVFbGVtZW50LmJsdXIoKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmxpdmVTb2NrZXQuaXNVbmxvYWRlZCgpKSB7XG4gICAgICAgIHRoaXMuc2hvd0xvYWRlcihCRUZPUkVfVU5MT0FEX0xPQURFUl9USU1FT1VUKTtcbiAgICAgIH1cbiAgICB9XG4gICAgb25FcnJvcihyZWFzb24pIHtcbiAgICAgIHRoaXMub25DbG9zZShyZWFzb24pO1xuICAgICAgdGhpcy5sb2coXCJlcnJvclwiLCAoKSA9PiBbXCJ2aWV3IGNyYXNoZWRcIiwgcmVhc29uXSk7XG4gICAgICBpZiAoIXRoaXMubGl2ZVNvY2tldC5pc1VubG9hZGVkKCkpIHtcbiAgICAgICAgdGhpcy5kaXNwbGF5RXJyb3IoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZGlzcGxheUVycm9yKCkge1xuICAgICAgaWYgKHRoaXMuaXNNYWluKCkpIHtcbiAgICAgICAgZG9tX2RlZmF1bHQuZGlzcGF0Y2hFdmVudCh3aW5kb3csIFwicGh4OnBhZ2UtbG9hZGluZy1zdGFydFwiLCB7IHRvOiB0aGlzLmhyZWYsIGtpbmQ6IFwiZXJyb3JcIiB9KTtcbiAgICAgIH1cbiAgICAgIHRoaXMuc2hvd0xvYWRlcigpO1xuICAgICAgdGhpcy5zZXRDb250YWluZXJDbGFzc2VzKFBIWF9ESVNDT05ORUNURURfQ0xBU1MsIFBIWF9FUlJPUl9DTEFTUyk7XG4gICAgfVxuICAgIHB1c2hXaXRoUmVwbHkocmVmR2VuZXJhdG9yLCBldmVudCwgcGF5bG9hZCwgb25SZXBseSA9IGZ1bmN0aW9uKCkge1xuICAgIH0pIHtcbiAgICAgIGlmICghdGhpcy5pc0Nvbm5lY3RlZCgpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGxldCBbcmVmLCBbZWxdLCBvcHRzXSA9IHJlZkdlbmVyYXRvciA/IHJlZkdlbmVyYXRvcigpIDogW251bGwsIFtdLCB7fV07XG4gICAgICBsZXQgb25Mb2FkaW5nRG9uZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgfTtcbiAgICAgIGlmIChvcHRzLnBhZ2VfbG9hZGluZyB8fCBlbCAmJiBlbC5nZXRBdHRyaWJ1dGUodGhpcy5iaW5kaW5nKFBIWF9QQUdFX0xPQURJTkcpKSAhPT0gbnVsbCkge1xuICAgICAgICBvbkxvYWRpbmdEb25lID0gdGhpcy5saXZlU29ja2V0LndpdGhQYWdlTG9hZGluZyh7IGtpbmQ6IFwiZWxlbWVudFwiLCB0YXJnZXQ6IGVsIH0pO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBwYXlsb2FkLmNpZCAhPT0gXCJudW1iZXJcIikge1xuICAgICAgICBkZWxldGUgcGF5bG9hZC5jaWQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5saXZlU29ja2V0LndyYXBQdXNoKHRoaXMsIHsgdGltZW91dDogdHJ1ZSB9LCAoKSA9PiB7XG4gICAgICAgIHJldHVybiB0aGlzLmNoYW5uZWwucHVzaChldmVudCwgcGF5bG9hZCwgUFVTSF9USU1FT1VUKS5yZWNlaXZlKFwib2tcIiwgKHJlc3ApID0+IHtcbiAgICAgICAgICB0aGlzLmxpdmVTb2NrZXQucmVxdWVzdERPTVVwZGF0ZSgoKSA9PiB7XG4gICAgICAgICAgICBsZXQgaG9va1JlcGx5ID0gbnVsbDtcbiAgICAgICAgICAgIGlmIChyZWYgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgdGhpcy51bmRvUmVmcyhyZWYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlc3AuZGlmZikge1xuICAgICAgICAgICAgICBob29rUmVwbHkgPSB0aGlzLmFwcGx5RGlmZihcInVwZGF0ZVwiLCByZXNwLmRpZmYsICh7IGRpZmYsIGV2ZW50cyB9KSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGUoZGlmZiwgZXZlbnRzKTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVzcC5yZWRpcmVjdCkge1xuICAgICAgICAgICAgICB0aGlzLm9uUmVkaXJlY3QocmVzcC5yZWRpcmVjdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVzcC5saXZlX3BhdGNoKSB7XG4gICAgICAgICAgICAgIHRoaXMub25MaXZlUGF0Y2gocmVzcC5saXZlX3BhdGNoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXNwLmxpdmVfcmVkaXJlY3QpIHtcbiAgICAgICAgICAgICAgdGhpcy5vbkxpdmVSZWRpcmVjdChyZXNwLmxpdmVfcmVkaXJlY3QpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb25Mb2FkaW5nRG9uZSgpO1xuICAgICAgICAgICAgb25SZXBseShyZXNwLCBob29rUmVwbHkpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICB1bmRvUmVmcyhyZWYpIHtcbiAgICAgIGRvbV9kZWZhdWx0LmFsbCh0aGlzLmVsLCBgWyR7UEhYX1JFRn09XCIke3JlZn1cIl1gLCAoZWwpID0+IHtcbiAgICAgICAgbGV0IGRpc2FibGVkVmFsID0gZWwuZ2V0QXR0cmlidXRlKFBIWF9ESVNBQkxFRCk7XG4gICAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZShQSFhfUkVGKTtcbiAgICAgICAgaWYgKGVsLmdldEF0dHJpYnV0ZShQSFhfUkVBRE9OTFkpICE9PSBudWxsKSB7XG4gICAgICAgICAgZWwucmVhZE9ubHkgPSBmYWxzZTtcbiAgICAgICAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoUEhYX1JFQURPTkxZKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGlzYWJsZWRWYWwgIT09IG51bGwpIHtcbiAgICAgICAgICBlbC5kaXNhYmxlZCA9IGRpc2FibGVkVmFsID09PSBcInRydWVcIiA/IHRydWUgOiBmYWxzZTtcbiAgICAgICAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoUEhYX0RJU0FCTEVEKTtcbiAgICAgICAgfVxuICAgICAgICBQSFhfRVZFTlRfQ0xBU1NFUy5mb3JFYWNoKChjbGFzc05hbWUpID0+IGRvbV9kZWZhdWx0LnJlbW92ZUNsYXNzKGVsLCBjbGFzc05hbWUpKTtcbiAgICAgICAgbGV0IGRpc2FibGVSZXN0b3JlID0gZWwuZ2V0QXR0cmlidXRlKFBIWF9ESVNBQkxFX1dJVEhfUkVTVE9SRSk7XG4gICAgICAgIGlmIChkaXNhYmxlUmVzdG9yZSAhPT0gbnVsbCkge1xuICAgICAgICAgIGVsLmlubmVyVGV4dCA9IGRpc2FibGVSZXN0b3JlO1xuICAgICAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZShQSFhfRElTQUJMRV9XSVRIX1JFU1RPUkUpO1xuICAgICAgICB9XG4gICAgICAgIGxldCB0b0VsID0gZG9tX2RlZmF1bHQucHJpdmF0ZShlbCwgUEhYX1JFRik7XG4gICAgICAgIGlmICh0b0VsKSB7XG4gICAgICAgICAgbGV0IGhvb2sgPSB0aGlzLnRyaWdnZXJCZWZvcmVVcGRhdGVIb29rKGVsLCB0b0VsKTtcbiAgICAgICAgICBET01QYXRjaC5wYXRjaEVsKGVsLCB0b0VsLCB0aGlzLmxpdmVTb2NrZXQuZ2V0QWN0aXZlRWxlbWVudCgpKTtcbiAgICAgICAgICBpZiAoaG9vaykge1xuICAgICAgICAgICAgaG9vay5fX3VwZGF0ZWQoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZG9tX2RlZmF1bHQuZGVsZXRlUHJpdmF0ZShlbCwgUEhYX1JFRik7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICBwdXRSZWYoZWxlbWVudHMsIGV2ZW50LCBvcHRzID0ge30pIHtcbiAgICAgIGxldCBuZXdSZWYgPSB0aGlzLnJlZisrO1xuICAgICAgbGV0IGRpc2FibGVXaXRoID0gdGhpcy5iaW5kaW5nKFBIWF9ESVNBQkxFX1dJVEgpO1xuICAgICAgaWYgKG9wdHMubG9hZGluZykge1xuICAgICAgICBlbGVtZW50cyA9IGVsZW1lbnRzLmNvbmNhdChkb21fZGVmYXVsdC5hbGwoZG9jdW1lbnQsIG9wdHMubG9hZGluZykpO1xuICAgICAgfVxuICAgICAgZWxlbWVudHMuZm9yRWFjaCgoZWwpID0+IHtcbiAgICAgICAgZWwuY2xhc3NMaXN0LmFkZChgcGh4LSR7ZXZlbnR9LWxvYWRpbmdgKTtcbiAgICAgICAgZWwuc2V0QXR0cmlidXRlKFBIWF9SRUYsIG5ld1JlZik7XG4gICAgICAgIGxldCBkaXNhYmxlVGV4dCA9IGVsLmdldEF0dHJpYnV0ZShkaXNhYmxlV2l0aCk7XG4gICAgICAgIGlmIChkaXNhYmxlVGV4dCAhPT0gbnVsbCkge1xuICAgICAgICAgIGlmICghZWwuZ2V0QXR0cmlidXRlKFBIWF9ESVNBQkxFX1dJVEhfUkVTVE9SRSkpIHtcbiAgICAgICAgICAgIGVsLnNldEF0dHJpYnV0ZShQSFhfRElTQUJMRV9XSVRIX1JFU1RPUkUsIGVsLmlubmVyVGV4dCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsLmlubmVyVGV4dCA9IGRpc2FibGVUZXh0O1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBbbmV3UmVmLCBlbGVtZW50cywgb3B0c107XG4gICAgfVxuICAgIGNvbXBvbmVudElEKGVsKSB7XG4gICAgICBsZXQgY2lkID0gZWwuZ2V0QXR0cmlidXRlICYmIGVsLmdldEF0dHJpYnV0ZShQSFhfQ09NUE9ORU5UKTtcbiAgICAgIHJldHVybiBjaWQgPyBwYXJzZUludChjaWQpIDogbnVsbDtcbiAgICB9XG4gICAgdGFyZ2V0Q29tcG9uZW50SUQodGFyZ2V0LCB0YXJnZXRDdHgpIHtcbiAgICAgIGlmIChpc0NpZCh0YXJnZXRDdHgpKSB7XG4gICAgICAgIHJldHVybiB0YXJnZXRDdHg7XG4gICAgICB9XG4gICAgICBsZXQgY2lkT3JTZWxlY3RvciA9IHRhcmdldC5nZXRBdHRyaWJ1dGUodGhpcy5iaW5kaW5nKFwidGFyZ2V0XCIpKTtcbiAgICAgIGlmIChpc0NpZChjaWRPclNlbGVjdG9yKSkge1xuICAgICAgICByZXR1cm4gcGFyc2VJbnQoY2lkT3JTZWxlY3Rvcik7XG4gICAgICB9IGVsc2UgaWYgKHRhcmdldEN0eCAmJiBjaWRPclNlbGVjdG9yICE9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNsb3Nlc3RDb21wb25lbnRJRCh0YXJnZXRDdHgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgfVxuICAgIGNsb3Nlc3RDb21wb25lbnRJRCh0YXJnZXRDdHgpIHtcbiAgICAgIGlmIChpc0NpZCh0YXJnZXRDdHgpKSB7XG4gICAgICAgIHJldHVybiB0YXJnZXRDdHg7XG4gICAgICB9IGVsc2UgaWYgKHRhcmdldEN0eCkge1xuICAgICAgICByZXR1cm4gbWF5YmUodGFyZ2V0Q3R4LmNsb3Nlc3QoYFske1BIWF9DT01QT05FTlR9XWApLCAoZWwpID0+IHRoaXMub3duc0VsZW1lbnQoZWwpICYmIHRoaXMuY29tcG9uZW50SUQoZWwpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgICBwdXNoSG9va0V2ZW50KHRhcmdldEN0eCwgZXZlbnQsIHBheWxvYWQsIG9uUmVwbHkpIHtcbiAgICAgIGlmICghdGhpcy5pc0Nvbm5lY3RlZCgpKSB7XG4gICAgICAgIHRoaXMubG9nKFwiaG9va1wiLCAoKSA9PiBbXCJ1bmFibGUgdG8gcHVzaCBob29rIGV2ZW50LiBMaXZlVmlldyBub3QgY29ubmVjdGVkXCIsIGV2ZW50LCBwYXlsb2FkXSk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGxldCBbcmVmLCBlbHMsIG9wdHNdID0gdGhpcy5wdXRSZWYoW10sIFwiaG9va1wiKTtcbiAgICAgIHRoaXMucHVzaFdpdGhSZXBseSgoKSA9PiBbcmVmLCBlbHMsIG9wdHNdLCBcImV2ZW50XCIsIHtcbiAgICAgICAgdHlwZTogXCJob29rXCIsXG4gICAgICAgIGV2ZW50LFxuICAgICAgICB2YWx1ZTogcGF5bG9hZCxcbiAgICAgICAgY2lkOiB0aGlzLmNsb3Nlc3RDb21wb25lbnRJRCh0YXJnZXRDdHgpXG4gICAgICB9LCAocmVzcCwgcmVwbHkpID0+IG9uUmVwbHkocmVwbHksIHJlZikpO1xuICAgICAgcmV0dXJuIHJlZjtcbiAgICB9XG4gICAgZXh0cmFjdE1ldGEoZWwsIG1ldGEsIHZhbHVlKSB7XG4gICAgICBsZXQgcHJlZml4ID0gdGhpcy5iaW5kaW5nKFwidmFsdWUtXCIpO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBlbC5hdHRyaWJ1dGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICghbWV0YSkge1xuICAgICAgICAgIG1ldGEgPSB7fTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgbmFtZSA9IGVsLmF0dHJpYnV0ZXNbaV0ubmFtZTtcbiAgICAgICAgaWYgKG5hbWUuc3RhcnRzV2l0aChwcmVmaXgpKSB7XG4gICAgICAgICAgbWV0YVtuYW1lLnJlcGxhY2UocHJlZml4LCBcIlwiKV0gPSBlbC5nZXRBdHRyaWJ1dGUobmFtZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChlbC52YWx1ZSAhPT0gdm9pZCAwKSB7XG4gICAgICAgIGlmICghbWV0YSkge1xuICAgICAgICAgIG1ldGEgPSB7fTtcbiAgICAgICAgfVxuICAgICAgICBtZXRhLnZhbHVlID0gZWwudmFsdWU7XG4gICAgICAgIGlmIChlbC50YWdOYW1lID09PSBcIklOUFVUXCIgJiYgQ0hFQ0tBQkxFX0lOUFVUUy5pbmRleE9mKGVsLnR5cGUpID49IDAgJiYgIWVsLmNoZWNrZWQpIHtcbiAgICAgICAgICBkZWxldGUgbWV0YS52YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgIGlmICghbWV0YSkge1xuICAgICAgICAgIG1ldGEgPSB7fTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBrZXkgaW4gdmFsdWUpIHtcbiAgICAgICAgICBtZXRhW2tleV0gPSB2YWx1ZVtrZXldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbWV0YTtcbiAgICB9XG4gICAgcHVzaEV2ZW50KHR5cGUsIGVsLCB0YXJnZXRDdHgsIHBoeEV2ZW50LCBtZXRhLCBvcHRzID0ge30pIHtcbiAgICAgIHRoaXMucHVzaFdpdGhSZXBseSgoKSA9PiB0aGlzLnB1dFJlZihbZWxdLCB0eXBlLCBvcHRzKSwgXCJldmVudFwiLCB7XG4gICAgICAgIHR5cGUsXG4gICAgICAgIGV2ZW50OiBwaHhFdmVudCxcbiAgICAgICAgdmFsdWU6IHRoaXMuZXh0cmFjdE1ldGEoZWwsIG1ldGEsIG9wdHMudmFsdWUpLFxuICAgICAgICBjaWQ6IHRoaXMudGFyZ2V0Q29tcG9uZW50SUQoZWwsIHRhcmdldEN0eClcbiAgICAgIH0pO1xuICAgIH1cbiAgICBwdXNoRmlsZVByb2dyZXNzKGZpbGVFbCwgZW50cnlSZWYsIHByb2dyZXNzLCBvblJlcGx5ID0gZnVuY3Rpb24oKSB7XG4gICAgfSkge1xuICAgICAgdGhpcy5saXZlU29ja2V0LndpdGhpbk93bmVycyhmaWxlRWwuZm9ybSwgKHZpZXcsIHRhcmdldEN0eCkgPT4ge1xuICAgICAgICB2aWV3LnB1c2hXaXRoUmVwbHkobnVsbCwgXCJwcm9ncmVzc1wiLCB7XG4gICAgICAgICAgZXZlbnQ6IGZpbGVFbC5nZXRBdHRyaWJ1dGUodmlldy5iaW5kaW5nKFBIWF9QUk9HUkVTUykpLFxuICAgICAgICAgIHJlZjogZmlsZUVsLmdldEF0dHJpYnV0ZShQSFhfVVBMT0FEX1JFRiksXG4gICAgICAgICAgZW50cnlfcmVmOiBlbnRyeVJlZixcbiAgICAgICAgICBwcm9ncmVzcyxcbiAgICAgICAgICBjaWQ6IHZpZXcudGFyZ2V0Q29tcG9uZW50SUQoZmlsZUVsLmZvcm0sIHRhcmdldEN0eClcbiAgICAgICAgfSwgb25SZXBseSk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgcHVzaElucHV0KGlucHV0RWwsIHRhcmdldEN0eCwgZm9yY2VDaWQsIHBoeEV2ZW50LCBvcHRzLCBjYWxsYmFjaykge1xuICAgICAgbGV0IHVwbG9hZHM7XG4gICAgICBsZXQgY2lkID0gaXNDaWQoZm9yY2VDaWQpID8gZm9yY2VDaWQgOiB0aGlzLnRhcmdldENvbXBvbmVudElEKGlucHV0RWwuZm9ybSwgdGFyZ2V0Q3R4KTtcbiAgICAgIGxldCByZWZHZW5lcmF0b3IgPSAoKSA9PiB0aGlzLnB1dFJlZihbaW5wdXRFbCwgaW5wdXRFbC5mb3JtXSwgXCJjaGFuZ2VcIiwgb3B0cyk7XG4gICAgICBsZXQgZm9ybURhdGEgPSBzZXJpYWxpemVGb3JtKGlucHV0RWwuZm9ybSwgeyBfdGFyZ2V0OiBvcHRzLl90YXJnZXQgfSk7XG4gICAgICBpZiAoZG9tX2RlZmF1bHQuaXNVcGxvYWRJbnB1dChpbnB1dEVsKSAmJiBpbnB1dEVsLmZpbGVzICYmIGlucHV0RWwuZmlsZXMubGVuZ3RoID4gMCkge1xuICAgICAgICBMaXZlVXBsb2FkZXIudHJhY2tGaWxlcyhpbnB1dEVsLCBBcnJheS5mcm9tKGlucHV0RWwuZmlsZXMpKTtcbiAgICAgIH1cbiAgICAgIHVwbG9hZHMgPSBMaXZlVXBsb2FkZXIuc2VyaWFsaXplVXBsb2FkcyhpbnB1dEVsKTtcbiAgICAgIGxldCBldmVudCA9IHtcbiAgICAgICAgdHlwZTogXCJmb3JtXCIsXG4gICAgICAgIGV2ZW50OiBwaHhFdmVudCxcbiAgICAgICAgdmFsdWU6IGZvcm1EYXRhLFxuICAgICAgICB1cGxvYWRzLFxuICAgICAgICBjaWRcbiAgICAgIH07XG4gICAgICB0aGlzLnB1c2hXaXRoUmVwbHkocmVmR2VuZXJhdG9yLCBcImV2ZW50XCIsIGV2ZW50LCAocmVzcCkgPT4ge1xuICAgICAgICBkb21fZGVmYXVsdC5zaG93RXJyb3IoaW5wdXRFbCwgdGhpcy5saXZlU29ja2V0LmJpbmRpbmcoUEhYX0ZFRURCQUNLX0ZPUikpO1xuICAgICAgICBpZiAoZG9tX2RlZmF1bHQuaXNVcGxvYWRJbnB1dChpbnB1dEVsKSAmJiBpbnB1dEVsLmdldEF0dHJpYnV0ZShcImRhdGEtcGh4LWF1dG8tdXBsb2FkXCIpICE9PSBudWxsKSB7XG4gICAgICAgICAgaWYgKExpdmVVcGxvYWRlci5maWxlc0F3YWl0aW5nUHJlZmxpZ2h0KGlucHV0RWwpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGxldCBbcmVmLCBfZWxzXSA9IHJlZkdlbmVyYXRvcigpO1xuICAgICAgICAgICAgdGhpcy51cGxvYWRGaWxlcyhpbnB1dEVsLmZvcm0sIHRhcmdldEN0eCwgcmVmLCBjaWQsIChfdXBsb2FkcykgPT4ge1xuICAgICAgICAgICAgICBjYWxsYmFjayAmJiBjYWxsYmFjayhyZXNwKTtcbiAgICAgICAgICAgICAgdGhpcy50cmlnZ2VyQXdhaXRpbmdTdWJtaXQoaW5wdXRFbC5mb3JtKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjYWxsYmFjayAmJiBjYWxsYmFjayhyZXNwKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIHRyaWdnZXJBd2FpdGluZ1N1Ym1pdChmb3JtRWwpIHtcbiAgICAgIGxldCBhd2FpdGluZ1N1Ym1pdCA9IHRoaXMuZ2V0U2NoZWR1bGVkU3VibWl0KGZvcm1FbCk7XG4gICAgICBpZiAoYXdhaXRpbmdTdWJtaXQpIHtcbiAgICAgICAgbGV0IFtfZWwsIF9yZWYsIF9vcHRzLCBjYWxsYmFja10gPSBhd2FpdGluZ1N1Ym1pdDtcbiAgICAgICAgdGhpcy5jYW5jZWxTdWJtaXQoZm9ybUVsKTtcbiAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZ2V0U2NoZWR1bGVkU3VibWl0KGZvcm1FbCkge1xuICAgICAgcmV0dXJuIHRoaXMuZm9ybVN1Ym1pdHMuZmluZCgoW2VsLCBfcmVmLCBfb3B0cywgX2NhbGxiYWNrXSkgPT4gZWwuaXNTYW1lTm9kZShmb3JtRWwpKTtcbiAgICB9XG4gICAgc2NoZWR1bGVTdWJtaXQoZm9ybUVsLCByZWYsIG9wdHMsIGNhbGxiYWNrKSB7XG4gICAgICBpZiAodGhpcy5nZXRTY2hlZHVsZWRTdWJtaXQoZm9ybUVsKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHRoaXMuZm9ybVN1Ym1pdHMucHVzaChbZm9ybUVsLCByZWYsIG9wdHMsIGNhbGxiYWNrXSk7XG4gICAgfVxuICAgIGNhbmNlbFN1Ym1pdChmb3JtRWwpIHtcbiAgICAgIHRoaXMuZm9ybVN1Ym1pdHMgPSB0aGlzLmZvcm1TdWJtaXRzLmZpbHRlcigoW2VsLCByZWYsIF9jYWxsYmFja10pID0+IHtcbiAgICAgICAgaWYgKGVsLmlzU2FtZU5vZGUoZm9ybUVsKSkge1xuICAgICAgICAgIHRoaXMudW5kb1JlZnMocmVmKTtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICBwdXNoRm9ybVN1Ym1pdChmb3JtRWwsIHRhcmdldEN0eCwgcGh4RXZlbnQsIG9wdHMsIG9uUmVwbHkpIHtcbiAgICAgIGxldCBmaWx0ZXJJZ25vcmVkID0gKGVsKSA9PiB7XG4gICAgICAgIGxldCB1c2VySWdub3JlZCA9IGNsb3Nlc3RQaHhCaW5kaW5nKGVsLCBgJHt0aGlzLmJpbmRpbmcoUEhYX1VQREFURSl9PWlnbm9yZWAsIGVsLmZvcm0pO1xuICAgICAgICByZXR1cm4gISh1c2VySWdub3JlZCB8fCBjbG9zZXN0UGh4QmluZGluZyhlbCwgXCJkYXRhLXBoeC11cGRhdGU9aWdub3JlXCIsIGVsLmZvcm0pKTtcbiAgICAgIH07XG4gICAgICBsZXQgZmlsdGVyRGlzYWJsZXMgPSAoZWwpID0+IHtcbiAgICAgICAgcmV0dXJuIGVsLmhhc0F0dHJpYnV0ZSh0aGlzLmJpbmRpbmcoUEhYX0RJU0FCTEVfV0lUSCkpO1xuICAgICAgfTtcbiAgICAgIGxldCBmaWx0ZXJCdXR0b24gPSAoZWwpID0+IGVsLnRhZ05hbWUgPT0gXCJCVVRUT05cIjtcbiAgICAgIGxldCBmaWx0ZXJJbnB1dCA9IChlbCkgPT4gW1wiSU5QVVRcIiwgXCJURVhUQVJFQVwiLCBcIlNFTEVDVFwiXS5pbmNsdWRlcyhlbC50YWdOYW1lKTtcbiAgICAgIGxldCByZWZHZW5lcmF0b3IgPSAoKSA9PiB7XG4gICAgICAgIGxldCBmb3JtRWxlbWVudHMgPSBBcnJheS5mcm9tKGZvcm1FbC5lbGVtZW50cyk7XG4gICAgICAgIGxldCBkaXNhYmxlcyA9IGZvcm1FbGVtZW50cy5maWx0ZXIoZmlsdGVyRGlzYWJsZXMpO1xuICAgICAgICBsZXQgYnV0dG9ucyA9IGZvcm1FbGVtZW50cy5maWx0ZXIoZmlsdGVyQnV0dG9uKS5maWx0ZXIoZmlsdGVySWdub3JlZCk7XG4gICAgICAgIGxldCBpbnB1dHMgPSBmb3JtRWxlbWVudHMuZmlsdGVyKGZpbHRlcklucHV0KS5maWx0ZXIoZmlsdGVySWdub3JlZCk7XG4gICAgICAgIGJ1dHRvbnMuZm9yRWFjaCgoYnV0dG9uKSA9PiB7XG4gICAgICAgICAgYnV0dG9uLnNldEF0dHJpYnV0ZShQSFhfRElTQUJMRUQsIGJ1dHRvbi5kaXNhYmxlZCk7XG4gICAgICAgICAgYnV0dG9uLmRpc2FibGVkID0gdHJ1ZTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlucHV0cy5mb3JFYWNoKChpbnB1dCkgPT4ge1xuICAgICAgICAgIGlucHV0LnNldEF0dHJpYnV0ZShQSFhfUkVBRE9OTFksIGlucHV0LnJlYWRPbmx5KTtcbiAgICAgICAgICBpbnB1dC5yZWFkT25seSA9IHRydWU7XG4gICAgICAgICAgaWYgKGlucHV0LmZpbGVzKSB7XG4gICAgICAgICAgICBpbnB1dC5zZXRBdHRyaWJ1dGUoUEhYX0RJU0FCTEVELCBpbnB1dC5kaXNhYmxlZCk7XG4gICAgICAgICAgICBpbnB1dC5kaXNhYmxlZCA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgZm9ybUVsLnNldEF0dHJpYnV0ZSh0aGlzLmJpbmRpbmcoUEhYX1BBR0VfTE9BRElORyksIFwiXCIpO1xuICAgICAgICByZXR1cm4gdGhpcy5wdXRSZWYoW2Zvcm1FbF0uY29uY2F0KGRpc2FibGVzKS5jb25jYXQoYnV0dG9ucykuY29uY2F0KGlucHV0cyksIFwic3VibWl0XCIsIG9wdHMpO1xuICAgICAgfTtcbiAgICAgIGxldCBjaWQgPSB0aGlzLnRhcmdldENvbXBvbmVudElEKGZvcm1FbCwgdGFyZ2V0Q3R4KTtcbiAgICAgIGlmIChMaXZlVXBsb2FkZXIuaGFzVXBsb2Fkc0luUHJvZ3Jlc3MoZm9ybUVsKSkge1xuICAgICAgICBsZXQgW3JlZiwgX2Vsc10gPSByZWZHZW5lcmF0b3IoKTtcbiAgICAgICAgbGV0IHB1c2ggPSAoKSA9PiB0aGlzLnB1c2hGb3JtU3VibWl0KGZvcm1FbCwgdGFyZ2V0Q3R4LCBwaHhFdmVudCwgb3B0cywgb25SZXBseSk7XG4gICAgICAgIHJldHVybiB0aGlzLnNjaGVkdWxlU3VibWl0KGZvcm1FbCwgcmVmLCBvcHRzLCBwdXNoKTtcbiAgICAgIH0gZWxzZSBpZiAoTGl2ZVVwbG9hZGVyLmlucHV0c0F3YWl0aW5nUHJlZmxpZ2h0KGZvcm1FbCkubGVuZ3RoID4gMCkge1xuICAgICAgICBsZXQgW3JlZiwgZWxzXSA9IHJlZkdlbmVyYXRvcigpO1xuICAgICAgICBsZXQgcHJveHlSZWZHZW4gPSAoKSA9PiBbcmVmLCBlbHMsIG9wdHNdO1xuICAgICAgICB0aGlzLnVwbG9hZEZpbGVzKGZvcm1FbCwgdGFyZ2V0Q3R4LCByZWYsIGNpZCwgKF91cGxvYWRzKSA9PiB7XG4gICAgICAgICAgbGV0IGZvcm1EYXRhID0gc2VyaWFsaXplRm9ybShmb3JtRWwsIHt9KTtcbiAgICAgICAgICB0aGlzLnB1c2hXaXRoUmVwbHkocHJveHlSZWZHZW4sIFwiZXZlbnRcIiwge1xuICAgICAgICAgICAgdHlwZTogXCJmb3JtXCIsXG4gICAgICAgICAgICBldmVudDogcGh4RXZlbnQsXG4gICAgICAgICAgICB2YWx1ZTogZm9ybURhdGEsXG4gICAgICAgICAgICBjaWRcbiAgICAgICAgICB9LCBvblJlcGx5KTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsZXQgZm9ybURhdGEgPSBzZXJpYWxpemVGb3JtKGZvcm1FbCk7XG4gICAgICAgIHRoaXMucHVzaFdpdGhSZXBseShyZWZHZW5lcmF0b3IsIFwiZXZlbnRcIiwge1xuICAgICAgICAgIHR5cGU6IFwiZm9ybVwiLFxuICAgICAgICAgIGV2ZW50OiBwaHhFdmVudCxcbiAgICAgICAgICB2YWx1ZTogZm9ybURhdGEsXG4gICAgICAgICAgY2lkXG4gICAgICAgIH0sIG9uUmVwbHkpO1xuICAgICAgfVxuICAgIH1cbiAgICB1cGxvYWRGaWxlcyhmb3JtRWwsIHRhcmdldEN0eCwgcmVmLCBjaWQsIG9uQ29tcGxldGUpIHtcbiAgICAgIGxldCBqb2luQ291bnRBdFVwbG9hZCA9IHRoaXMuam9pbkNvdW50O1xuICAgICAgbGV0IGlucHV0RWxzID0gTGl2ZVVwbG9hZGVyLmFjdGl2ZUZpbGVJbnB1dHMoZm9ybUVsKTtcbiAgICAgIGxldCBudW1GaWxlSW5wdXRzSW5Qcm9ncmVzcyA9IGlucHV0RWxzLmxlbmd0aDtcbiAgICAgIGlucHV0RWxzLmZvckVhY2goKGlucHV0RWwpID0+IHtcbiAgICAgICAgbGV0IHVwbG9hZGVyID0gbmV3IExpdmVVcGxvYWRlcihpbnB1dEVsLCB0aGlzLCAoKSA9PiB7XG4gICAgICAgICAgbnVtRmlsZUlucHV0c0luUHJvZ3Jlc3MtLTtcbiAgICAgICAgICBpZiAobnVtRmlsZUlucHV0c0luUHJvZ3Jlc3MgPT09IDApIHtcbiAgICAgICAgICAgIG9uQ29tcGxldGUoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnVwbG9hZGVyc1tpbnB1dEVsXSA9IHVwbG9hZGVyO1xuICAgICAgICBsZXQgZW50cmllcyA9IHVwbG9hZGVyLmVudHJpZXMoKS5tYXAoKGVudHJ5KSA9PiBlbnRyeS50b1ByZWZsaWdodFBheWxvYWQoKSk7XG4gICAgICAgIGxldCBwYXlsb2FkID0ge1xuICAgICAgICAgIHJlZjogaW5wdXRFbC5nZXRBdHRyaWJ1dGUoUEhYX1VQTE9BRF9SRUYpLFxuICAgICAgICAgIGVudHJpZXMsXG4gICAgICAgICAgY2lkOiB0aGlzLnRhcmdldENvbXBvbmVudElEKGlucHV0RWwuZm9ybSwgdGFyZ2V0Q3R4KVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmxvZyhcInVwbG9hZFwiLCAoKSA9PiBbXCJzZW5kaW5nIHByZWZsaWdodCByZXF1ZXN0XCIsIHBheWxvYWRdKTtcbiAgICAgICAgdGhpcy5wdXNoV2l0aFJlcGx5KG51bGwsIFwiYWxsb3dfdXBsb2FkXCIsIHBheWxvYWQsIChyZXNwKSA9PiB7XG4gICAgICAgICAgdGhpcy5sb2coXCJ1cGxvYWRcIiwgKCkgPT4gW1wiZ290IHByZWZsaWdodCByZXNwb25zZVwiLCByZXNwXSk7XG4gICAgICAgICAgaWYgKHJlc3AuZXJyb3IpIHtcbiAgICAgICAgICAgIHRoaXMudW5kb1JlZnMocmVmKTtcbiAgICAgICAgICAgIGxldCBbZW50cnlfcmVmLCByZWFzb25dID0gcmVzcC5lcnJvcjtcbiAgICAgICAgICAgIHRoaXMubG9nKFwidXBsb2FkXCIsICgpID0+IFtgZXJyb3IgZm9yIGVudHJ5ICR7ZW50cnlfcmVmfWAsIHJlYXNvbl0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsZXQgb25FcnJvciA9IChjYWxsYmFjaykgPT4ge1xuICAgICAgICAgICAgICB0aGlzLmNoYW5uZWwub25FcnJvcigoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuam9pbkNvdW50ID09PSBqb2luQ291bnRBdFVwbG9hZCkge1xuICAgICAgICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHVwbG9hZGVyLmluaXRBZGFwdGVyVXBsb2FkKHJlc3AsIG9uRXJyb3IsIHRoaXMubGl2ZVNvY2tldCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBkaXNwYXRjaFVwbG9hZHMobmFtZSwgZmlsZXNPckJsb2JzKSB7XG4gICAgICBsZXQgaW5wdXRzID0gZG9tX2RlZmF1bHQuZmluZFVwbG9hZElucHV0cyh0aGlzLmVsKS5maWx0ZXIoKGVsKSA9PiBlbC5uYW1lID09PSBuYW1lKTtcbiAgICAgIGlmIChpbnB1dHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGxvZ0Vycm9yKGBubyBsaXZlIGZpbGUgaW5wdXRzIGZvdW5kIG1hdGNoaW5nIHRoZSBuYW1lIFwiJHtuYW1lfVwiYCk7XG4gICAgICB9IGVsc2UgaWYgKGlucHV0cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGxvZ0Vycm9yKGBkdXBsaWNhdGUgbGl2ZSBmaWxlIGlucHV0cyBmb3VuZCBtYXRjaGluZyB0aGUgbmFtZSBcIiR7bmFtZX1cImApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZG9tX2RlZmF1bHQuZGlzcGF0Y2hFdmVudChpbnB1dHNbMF0sIFBIWF9UUkFDS19VUExPQURTLCB7IGZpbGVzOiBmaWxlc09yQmxvYnMgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIHB1c2hGb3JtUmVjb3ZlcnkoZm9ybSwgbmV3Q2lkLCBjYWxsYmFjaykge1xuICAgICAgdGhpcy5saXZlU29ja2V0LndpdGhpbk93bmVycyhmb3JtLCAodmlldywgdGFyZ2V0Q3R4KSA9PiB7XG4gICAgICAgIGxldCBpbnB1dCA9IGZvcm0uZWxlbWVudHNbMF07XG4gICAgICAgIGxldCBwaHhFdmVudCA9IGZvcm0uZ2V0QXR0cmlidXRlKHRoaXMuYmluZGluZyhQSFhfQVVUT19SRUNPVkVSKSkgfHwgZm9ybS5nZXRBdHRyaWJ1dGUodGhpcy5iaW5kaW5nKFwiY2hhbmdlXCIpKTtcbiAgICAgICAganNfZGVmYXVsdC5leGVjKFwiY2hhbmdlXCIsIHBoeEV2ZW50LCB2aWV3LCBpbnB1dCwgW1wicHVzaFwiLCB7IF90YXJnZXQ6IGlucHV0Lm5hbWUsIG5ld0NpZCwgY2FsbGJhY2sgfV0pO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHB1c2hMaW5rUGF0Y2goaHJlZiwgdGFyZ2V0RWwsIGNhbGxiYWNrKSB7XG4gICAgICBsZXQgbGlua1JlZiA9IHRoaXMubGl2ZVNvY2tldC5zZXRQZW5kaW5nTGluayhocmVmKTtcbiAgICAgIGxldCByZWZHZW4gPSB0YXJnZXRFbCA/ICgpID0+IHRoaXMucHV0UmVmKFt0YXJnZXRFbF0sIFwiY2xpY2tcIikgOiBudWxsO1xuICAgICAgdGhpcy5wdXNoV2l0aFJlcGx5KHJlZkdlbiwgXCJsaXZlX3BhdGNoXCIsIHsgdXJsOiBocmVmIH0sIChyZXNwKSA9PiB7XG4gICAgICAgIHRoaXMubGl2ZVNvY2tldC5yZXF1ZXN0RE9NVXBkYXRlKCgpID0+IHtcbiAgICAgICAgICBpZiAocmVzcC5saW5rX3JlZGlyZWN0KSB7XG4gICAgICAgICAgICB0aGlzLmxpdmVTb2NrZXQucmVwbGFjZU1haW4oaHJlZiwgbnVsbCwgY2FsbGJhY2ssIGxpbmtSZWYpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAodGhpcy5saXZlU29ja2V0LmNvbW1pdFBlbmRpbmdMaW5rKGxpbmtSZWYpKSB7XG4gICAgICAgICAgICAgIHRoaXMuaHJlZiA9IGhyZWY7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmFwcGx5UGVuZGluZ1VwZGF0ZXMoKTtcbiAgICAgICAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKGxpbmtSZWYpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9KS5yZWNlaXZlKFwidGltZW91dFwiLCAoKSA9PiB0aGlzLmxpdmVTb2NrZXQucmVkaXJlY3Qod2luZG93LmxvY2F0aW9uLmhyZWYpKTtcbiAgICB9XG4gICAgZm9ybXNGb3JSZWNvdmVyeShodG1sKSB7XG4gICAgICBpZiAodGhpcy5qb2luQ291bnQgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgICAgbGV0IHBoeENoYW5nZSA9IHRoaXMuYmluZGluZyhcImNoYW5nZVwiKTtcbiAgICAgIGxldCB0ZW1wbGF0ZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJ0ZW1wbGF0ZVwiKTtcbiAgICAgIHRlbXBsYXRlLmlubmVySFRNTCA9IGh0bWw7XG4gICAgICByZXR1cm4gZG9tX2RlZmF1bHQuYWxsKHRoaXMuZWwsIGBmb3JtWyR7cGh4Q2hhbmdlfV1gKS5maWx0ZXIoKGZvcm0pID0+IGZvcm0uaWQgJiYgdGhpcy5vd25zRWxlbWVudChmb3JtKSkuZmlsdGVyKChmb3JtKSA9PiBmb3JtLmVsZW1lbnRzLmxlbmd0aCA+IDApLmZpbHRlcigoZm9ybSkgPT4gZm9ybS5nZXRBdHRyaWJ1dGUodGhpcy5iaW5kaW5nKFBIWF9BVVRPX1JFQ09WRVIpKSAhPT0gXCJpZ25vcmVcIikubWFwKChmb3JtKSA9PiB7XG4gICAgICAgIGxldCBuZXdGb3JtID0gdGVtcGxhdGUuY29udGVudC5xdWVyeVNlbGVjdG9yKGBmb3JtW2lkPVwiJHtmb3JtLmlkfVwiXVske3BoeENoYW5nZX09XCIke2Zvcm0uZ2V0QXR0cmlidXRlKHBoeENoYW5nZSl9XCJdYCk7XG4gICAgICAgIGlmIChuZXdGb3JtKSB7XG4gICAgICAgICAgcmV0dXJuIFtmb3JtLCBuZXdGb3JtLCB0aGlzLnRhcmdldENvbXBvbmVudElEKG5ld0Zvcm0pXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gW2Zvcm0sIG51bGwsIG51bGxdO1xuICAgICAgICB9XG4gICAgICB9KS5maWx0ZXIoKFtmb3JtLCBuZXdGb3JtLCBuZXdDaWRdKSA9PiBuZXdGb3JtKTtcbiAgICB9XG4gICAgbWF5YmVQdXNoQ29tcG9uZW50c0Rlc3Ryb3llZChkZXN0cm95ZWRDSURzKSB7XG4gICAgICBsZXQgd2lsbERlc3Ryb3lDSURzID0gZGVzdHJveWVkQ0lEcy5maWx0ZXIoKGNpZCkgPT4ge1xuICAgICAgICByZXR1cm4gZG9tX2RlZmF1bHQuZmluZENvbXBvbmVudE5vZGVMaXN0KHRoaXMuZWwsIGNpZCkubGVuZ3RoID09PSAwO1xuICAgICAgfSk7XG4gICAgICBpZiAod2lsbERlc3Ryb3lDSURzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdGhpcy5wcnVuaW5nQ0lEcy5wdXNoKC4uLndpbGxEZXN0cm95Q0lEcyk7XG4gICAgICAgIHRoaXMucHVzaFdpdGhSZXBseShudWxsLCBcImNpZHNfd2lsbF9kZXN0cm95XCIsIHsgY2lkczogd2lsbERlc3Ryb3lDSURzIH0sICgpID0+IHtcbiAgICAgICAgICB0aGlzLnBydW5pbmdDSURzID0gdGhpcy5wcnVuaW5nQ0lEcy5maWx0ZXIoKGNpZCkgPT4gd2lsbERlc3Ryb3lDSURzLmluZGV4T2YoY2lkKSAhPT0gLTEpO1xuICAgICAgICAgIGxldCBjb21wbGV0ZWx5RGVzdHJveUNJRHMgPSB3aWxsRGVzdHJveUNJRHMuZmlsdGVyKChjaWQpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBkb21fZGVmYXVsdC5maW5kQ29tcG9uZW50Tm9kZUxpc3QodGhpcy5lbCwgY2lkKS5sZW5ndGggPT09IDA7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgaWYgKGNvbXBsZXRlbHlEZXN0cm95Q0lEcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB0aGlzLnB1c2hXaXRoUmVwbHkobnVsbCwgXCJjaWRzX2Rlc3Ryb3llZFwiLCB7IGNpZHM6IGNvbXBsZXRlbHlEZXN0cm95Q0lEcyB9LCAocmVzcCkgPT4ge1xuICAgICAgICAgICAgICB0aGlzLnJlbmRlcmVkLnBydW5lQ0lEcyhyZXNwLmNpZHMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgb3duc0VsZW1lbnQoZWwpIHtcbiAgICAgIHJldHVybiBlbC5nZXRBdHRyaWJ1dGUoUEhYX1BBUkVOVF9JRCkgPT09IHRoaXMuaWQgfHwgbWF5YmUoZWwuY2xvc2VzdChQSFhfVklFV19TRUxFQ1RPUiksIChub2RlKSA9PiBub2RlLmlkKSA9PT0gdGhpcy5pZDtcbiAgICB9XG4gICAgc3VibWl0Rm9ybShmb3JtLCB0YXJnZXRDdHgsIHBoeEV2ZW50LCBvcHRzID0ge30pIHtcbiAgICAgIGRvbV9kZWZhdWx0LnB1dFByaXZhdGUoZm9ybSwgUEhYX0hBU19TVUJNSVRURUQsIHRydWUpO1xuICAgICAgdGhpcy5saXZlU29ja2V0LmJsdXJBY3RpdmVFbGVtZW50KHRoaXMpO1xuICAgICAgdGhpcy5wdXNoRm9ybVN1Ym1pdChmb3JtLCB0YXJnZXRDdHgsIHBoeEV2ZW50LCBvcHRzLCAoKSA9PiB7XG4gICAgICAgIHRoaXMubGl2ZVNvY2tldC5yZXN0b3JlUHJldmlvdXNseUFjdGl2ZUZvY3VzKCk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgYmluZGluZyhraW5kKSB7XG4gICAgICByZXR1cm4gdGhpcy5saXZlU29ja2V0LmJpbmRpbmcoa2luZCk7XG4gICAgfVxuICB9O1xuXG4gIC8vIGpzL3Bob2VuaXhfbGl2ZV92aWV3L2xpdmVfc29ja2V0LmpzXG4gIHZhciBMaXZlU29ja2V0ID0gY2xhc3Mge1xuICAgIGNvbnN0cnVjdG9yKHVybCwgcGh4U29ja2V0LCBvcHRzID0ge30pIHtcbiAgICAgIHRoaXMudW5sb2FkZWQgPSBmYWxzZTtcbiAgICAgIGlmICghcGh4U29ja2V0IHx8IHBoeFNvY2tldC5jb25zdHJ1Y3Rvci5uYW1lID09PSBcIk9iamVjdFwiKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgXG4gICAgICBhIHBob2VuaXggU29ja2V0IG11c3QgYmUgcHJvdmlkZWQgYXMgdGhlIHNlY29uZCBhcmd1bWVudCB0byB0aGUgTGl2ZVNvY2tldCBjb25zdHJ1Y3Rvci4gRm9yIGV4YW1wbGU6XG5cbiAgICAgICAgICBpbXBvcnQge1NvY2tldH0gZnJvbSBcInBob2VuaXhcIlxuICAgICAgICAgIGltcG9ydCBMaXZlU29ja2V0IGZyb20gXCJwaG9lbml4X2xpdmVfdmlld1wiXG4gICAgICAgICAgbGV0IGxpdmVTb2NrZXQgPSBuZXcgTGl2ZVNvY2tldChcIi9saXZlXCIsIFNvY2tldCwgey4uLn0pXG4gICAgICBgKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuc29ja2V0ID0gbmV3IHBoeFNvY2tldCh1cmwsIG9wdHMpO1xuICAgICAgdGhpcy5iaW5kaW5nUHJlZml4ID0gb3B0cy5iaW5kaW5nUHJlZml4IHx8IEJJTkRJTkdfUFJFRklYO1xuICAgICAgdGhpcy5vcHRzID0gb3B0cztcbiAgICAgIHRoaXMucGFyYW1zID0gY2xvc3VyZShvcHRzLnBhcmFtcyB8fCB7fSk7XG4gICAgICB0aGlzLnZpZXdMb2dnZXIgPSBvcHRzLnZpZXdMb2dnZXI7XG4gICAgICB0aGlzLm1ldGFkYXRhQ2FsbGJhY2tzID0gb3B0cy5tZXRhZGF0YSB8fCB7fTtcbiAgICAgIHRoaXMuZGVmYXVsdHMgPSBPYmplY3QuYXNzaWduKGNsb25lKERFRkFVTFRTKSwgb3B0cy5kZWZhdWx0cyB8fCB7fSk7XG4gICAgICB0aGlzLmFjdGl2ZUVsZW1lbnQgPSBudWxsO1xuICAgICAgdGhpcy5wcmV2QWN0aXZlID0gbnVsbDtcbiAgICAgIHRoaXMuc2lsZW5jZWQgPSBmYWxzZTtcbiAgICAgIHRoaXMubWFpbiA9IG51bGw7XG4gICAgICB0aGlzLmxpbmtSZWYgPSAxO1xuICAgICAgdGhpcy5yb290cyA9IHt9O1xuICAgICAgdGhpcy5ocmVmID0gd2luZG93LmxvY2F0aW9uLmhyZWY7XG4gICAgICB0aGlzLnBlbmRpbmdMaW5rID0gbnVsbDtcbiAgICAgIHRoaXMuY3VycmVudExvY2F0aW9uID0gY2xvbmUod2luZG93LmxvY2F0aW9uKTtcbiAgICAgIHRoaXMuaG9va3MgPSBvcHRzLmhvb2tzIHx8IHt9O1xuICAgICAgdGhpcy51cGxvYWRlcnMgPSBvcHRzLnVwbG9hZGVycyB8fCB7fTtcbiAgICAgIHRoaXMubG9hZGVyVGltZW91dCA9IG9wdHMubG9hZGVyVGltZW91dCB8fCBMT0FERVJfVElNRU9VVDtcbiAgICAgIHRoaXMubG9jYWxTdG9yYWdlID0gb3B0cy5sb2NhbFN0b3JhZ2UgfHwgd2luZG93LmxvY2FsU3RvcmFnZTtcbiAgICAgIHRoaXMuc2Vzc2lvblN0b3JhZ2UgPSBvcHRzLnNlc3Npb25TdG9yYWdlIHx8IHdpbmRvdy5zZXNzaW9uU3RvcmFnZTtcbiAgICAgIHRoaXMuYm91bmRUb3BMZXZlbEV2ZW50cyA9IGZhbHNlO1xuICAgICAgdGhpcy5kb21DYWxsYmFja3MgPSBPYmplY3QuYXNzaWduKHsgb25Ob2RlQWRkZWQ6IGNsb3N1cmUoKSwgb25CZWZvcmVFbFVwZGF0ZWQ6IGNsb3N1cmUoKSB9LCBvcHRzLmRvbSB8fCB7fSk7XG4gICAgICB0aGlzLnRyYW5zaXRpb25zID0gbmV3IFRyYW5zaXRpb25TZXQoKTtcbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwicGFnZWhpZGVcIiwgKF9lKSA9PiB7XG4gICAgICAgIHRoaXMudW5sb2FkZWQgPSB0cnVlO1xuICAgICAgfSk7XG4gICAgICB0aGlzLnNvY2tldC5vbk9wZW4oKCkgPT4ge1xuICAgICAgICBpZiAodGhpcy5pc1VubG9hZGVkKCkpIHtcbiAgICAgICAgICB3aW5kb3cubG9jYXRpb24ucmVsb2FkKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICBpc1Byb2ZpbGVFbmFibGVkKCkge1xuICAgICAgcmV0dXJuIHRoaXMuc2Vzc2lvblN0b3JhZ2UuZ2V0SXRlbShQSFhfTFZfUFJPRklMRSkgPT09IFwidHJ1ZVwiO1xuICAgIH1cbiAgICBpc0RlYnVnRW5hYmxlZCgpIHtcbiAgICAgIHJldHVybiB0aGlzLnNlc3Npb25TdG9yYWdlLmdldEl0ZW0oUEhYX0xWX0RFQlVHKSA9PT0gXCJ0cnVlXCI7XG4gICAgfVxuICAgIGVuYWJsZURlYnVnKCkge1xuICAgICAgdGhpcy5zZXNzaW9uU3RvcmFnZS5zZXRJdGVtKFBIWF9MVl9ERUJVRywgXCJ0cnVlXCIpO1xuICAgIH1cbiAgICBlbmFibGVQcm9maWxpbmcoKSB7XG4gICAgICB0aGlzLnNlc3Npb25TdG9yYWdlLnNldEl0ZW0oUEhYX0xWX1BST0ZJTEUsIFwidHJ1ZVwiKTtcbiAgICB9XG4gICAgZGlzYWJsZURlYnVnKCkge1xuICAgICAgdGhpcy5zZXNzaW9uU3RvcmFnZS5yZW1vdmVJdGVtKFBIWF9MVl9ERUJVRyk7XG4gICAgfVxuICAgIGRpc2FibGVQcm9maWxpbmcoKSB7XG4gICAgICB0aGlzLnNlc3Npb25TdG9yYWdlLnJlbW92ZUl0ZW0oUEhYX0xWX1BST0ZJTEUpO1xuICAgIH1cbiAgICBlbmFibGVMYXRlbmN5U2ltKHVwcGVyQm91bmRNcykge1xuICAgICAgdGhpcy5lbmFibGVEZWJ1ZygpO1xuICAgICAgY29uc29sZS5sb2coXCJsYXRlbmN5IHNpbXVsYXRvciBlbmFibGVkIGZvciB0aGUgZHVyYXRpb24gb2YgdGhpcyBicm93c2VyIHNlc3Npb24uIENhbGwgZGlzYWJsZUxhdGVuY3lTaW0oKSB0byBkaXNhYmxlXCIpO1xuICAgICAgdGhpcy5zZXNzaW9uU3RvcmFnZS5zZXRJdGVtKFBIWF9MVl9MQVRFTkNZX1NJTSwgdXBwZXJCb3VuZE1zKTtcbiAgICB9XG4gICAgZGlzYWJsZUxhdGVuY3lTaW0oKSB7XG4gICAgICB0aGlzLnNlc3Npb25TdG9yYWdlLnJlbW92ZUl0ZW0oUEhYX0xWX0xBVEVOQ1lfU0lNKTtcbiAgICB9XG4gICAgZ2V0TGF0ZW5jeVNpbSgpIHtcbiAgICAgIGxldCBzdHIgPSB0aGlzLnNlc3Npb25TdG9yYWdlLmdldEl0ZW0oUEhYX0xWX0xBVEVOQ1lfU0lNKTtcbiAgICAgIHJldHVybiBzdHIgPyBwYXJzZUludChzdHIpIDogbnVsbDtcbiAgICB9XG4gICAgZ2V0U29ja2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuc29ja2V0O1xuICAgIH1cbiAgICBjb25uZWN0KCkge1xuICAgICAgbGV0IGRvQ29ubmVjdCA9ICgpID0+IHtcbiAgICAgICAgaWYgKHRoaXMuam9pblJvb3RWaWV3cygpKSB7XG4gICAgICAgICAgdGhpcy5iaW5kVG9wTGV2ZWxFdmVudHMoKTtcbiAgICAgICAgICB0aGlzLnNvY2tldC5jb25uZWN0KCk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBpZiAoW1wiY29tcGxldGVcIiwgXCJsb2FkZWRcIiwgXCJpbnRlcmFjdGl2ZVwiXS5pbmRleE9mKGRvY3VtZW50LnJlYWR5U3RhdGUpID49IDApIHtcbiAgICAgICAgZG9Db25uZWN0KCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwiRE9NQ29udGVudExvYWRlZFwiLCAoKSA9PiBkb0Nvbm5lY3QoKSk7XG4gICAgICB9XG4gICAgfVxuICAgIGRpc2Nvbm5lY3QoY2FsbGJhY2spIHtcbiAgICAgIHRoaXMuc29ja2V0LmRpc2Nvbm5lY3QoY2FsbGJhY2spO1xuICAgIH1cbiAgICBleGVjSlMoZWwsIGVuY29kZWRKUywgZXZlbnRUeXBlID0gbnVsbCkge1xuICAgICAgdGhpcy5vd25lcihlbCwgKHZpZXcpID0+IGpzX2RlZmF1bHQuZXhlYyhldmVudFR5cGUsIGVuY29kZWRKUywgdmlldywgZWwpKTtcbiAgICB9XG4gICAgdHJpZ2dlckRPTShraW5kLCBhcmdzKSB7XG4gICAgICB0aGlzLmRvbUNhbGxiYWNrc1traW5kXSguLi5hcmdzKTtcbiAgICB9XG4gICAgdGltZShuYW1lLCBmdW5jKSB7XG4gICAgICBpZiAoIXRoaXMuaXNQcm9maWxlRW5hYmxlZCgpIHx8ICFjb25zb2xlLnRpbWUpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmMoKTtcbiAgICAgIH1cbiAgICAgIGNvbnNvbGUudGltZShuYW1lKTtcbiAgICAgIGxldCByZXN1bHQgPSBmdW5jKCk7XG4gICAgICBjb25zb2xlLnRpbWVFbmQobmFtZSk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBsb2codmlldywga2luZCwgbXNnQ2FsbGJhY2spIHtcbiAgICAgIGlmICh0aGlzLnZpZXdMb2dnZXIpIHtcbiAgICAgICAgbGV0IFttc2csIG9ial0gPSBtc2dDYWxsYmFjaygpO1xuICAgICAgICB0aGlzLnZpZXdMb2dnZXIodmlldywga2luZCwgbXNnLCBvYmopO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLmlzRGVidWdFbmFibGVkKCkpIHtcbiAgICAgICAgbGV0IFttc2csIG9ial0gPSBtc2dDYWxsYmFjaygpO1xuICAgICAgICBkZWJ1Zyh2aWV3LCBraW5kLCBtc2csIG9iaik7XG4gICAgICB9XG4gICAgfVxuICAgIHJlcXVlc3RET01VcGRhdGUoY2FsbGJhY2spIHtcbiAgICAgIHRoaXMudHJhbnNpdGlvbnMuYWZ0ZXIoY2FsbGJhY2spO1xuICAgIH1cbiAgICB0cmFuc2l0aW9uKHRpbWUsIG9uU3RhcnQsIG9uRG9uZSA9IGZ1bmN0aW9uKCkge1xuICAgIH0pIHtcbiAgICAgIHRoaXMudHJhbnNpdGlvbnMuYWRkVHJhbnNpdGlvbih0aW1lLCBvblN0YXJ0LCBvbkRvbmUpO1xuICAgIH1cbiAgICBvbkNoYW5uZWwoY2hhbm5lbCwgZXZlbnQsIGNiKSB7XG4gICAgICBjaGFubmVsLm9uKGV2ZW50LCAoZGF0YSkgPT4ge1xuICAgICAgICBsZXQgbGF0ZW5jeSA9IHRoaXMuZ2V0TGF0ZW5jeVNpbSgpO1xuICAgICAgICBpZiAoIWxhdGVuY3kpIHtcbiAgICAgICAgICBjYihkYXRhKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zb2xlLmxvZyhgc2ltdWxhdGluZyAke2xhdGVuY3l9bXMgb2YgbGF0ZW5jeSBmcm9tIHNlcnZlciB0byBjbGllbnRgKTtcbiAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IGNiKGRhdGEpLCBsYXRlbmN5KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIHdyYXBQdXNoKHZpZXcsIG9wdHMsIHB1c2gpIHtcbiAgICAgIGxldCBsYXRlbmN5ID0gdGhpcy5nZXRMYXRlbmN5U2ltKCk7XG4gICAgICBsZXQgb2xkSm9pbkNvdW50ID0gdmlldy5qb2luQ291bnQ7XG4gICAgICBpZiAoIWxhdGVuY3kpIHtcbiAgICAgICAgaWYgKG9wdHMudGltZW91dCkge1xuICAgICAgICAgIHJldHVybiBwdXNoKCkucmVjZWl2ZShcInRpbWVvdXRcIiwgKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHZpZXcuam9pbkNvdW50ID09PSBvbGRKb2luQ291bnQgJiYgIXZpZXcuaXNEZXN0cm95ZWQoKSkge1xuICAgICAgICAgICAgICB0aGlzLnJlbG9hZFdpdGhKaXR0ZXIodmlldywgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMubG9nKHZpZXcsIFwidGltZW91dFwiLCAoKSA9PiBbXCJyZWNlaXZlZCB0aW1lb3V0IHdoaWxlIGNvbW11bmljYXRpbmcgd2l0aCBzZXJ2ZXIuIEZhbGxpbmcgYmFjayB0byBoYXJkIHJlZnJlc2ggZm9yIHJlY292ZXJ5XCJdKTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIHB1c2goKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29uc29sZS5sb2coYHNpbXVsYXRpbmcgJHtsYXRlbmN5fW1zIG9mIGxhdGVuY3kgZnJvbSBjbGllbnQgdG8gc2VydmVyYCk7XG4gICAgICBsZXQgZmFrZVB1c2ggPSB7XG4gICAgICAgIHJlY2VpdmVzOiBbXSxcbiAgICAgICAgcmVjZWl2ZShraW5kLCBjYikge1xuICAgICAgICAgIHRoaXMucmVjZWl2ZXMucHVzaChba2luZCwgY2JdKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBpZiAodmlldy5pc0Rlc3Ryb3llZCgpKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGZha2VQdXNoLnJlY2VpdmVzLnJlZHVjZSgoYWNjLCBba2luZCwgY2JdKSA9PiBhY2MucmVjZWl2ZShraW5kLCBjYiksIHB1c2goKSk7XG4gICAgICB9LCBsYXRlbmN5KTtcbiAgICAgIHJldHVybiBmYWtlUHVzaDtcbiAgICB9XG4gICAgcmVsb2FkV2l0aEppdHRlcih2aWV3LCBsb2cpIHtcbiAgICAgIHZpZXcuZGVzdHJveSgpO1xuICAgICAgdGhpcy5kaXNjb25uZWN0KCk7XG4gICAgICBsZXQgW21pbk1zLCBtYXhNc10gPSBSRUxPQURfSklUVEVSO1xuICAgICAgbGV0IGFmdGVyTXMgPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAobWF4TXMgLSBtaW5NcyArIDEpKSArIG1pbk1zO1xuICAgICAgbGV0IHRyaWVzID0gYnJvd3Nlcl9kZWZhdWx0LnVwZGF0ZUxvY2FsKHRoaXMubG9jYWxTdG9yYWdlLCB3aW5kb3cubG9jYXRpb24ucGF0aG5hbWUsIENPTlNFQ1VUSVZFX1JFTE9BRFMsIDAsIChjb3VudCkgPT4gY291bnQgKyAxKTtcbiAgICAgIGxvZyA/IGxvZygpIDogdGhpcy5sb2codmlldywgXCJqb2luXCIsICgpID0+IFtgZW5jb3VudGVyZWQgJHt0cmllc30gY29uc2VjdXRpdmUgcmVsb2Fkc2BdKTtcbiAgICAgIGlmICh0cmllcyA+IE1BWF9SRUxPQURTKSB7XG4gICAgICAgIHRoaXMubG9nKHZpZXcsIFwiam9pblwiLCAoKSA9PiBbYGV4Y2VlZGVkICR7TUFYX1JFTE9BRFN9IGNvbnNlY3V0aXZlIHJlbG9hZHMuIEVudGVyaW5nIGZhaWxzYWZlIG1vZGVgXSk7XG4gICAgICAgIGFmdGVyTXMgPSBGQUlMU0FGRV9KSVRURVI7XG4gICAgICB9XG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgaWYgKHRoaXMuaGFzUGVuZGluZ0xpbmsoKSkge1xuICAgICAgICAgIHdpbmRvdy5sb2NhdGlvbiA9IHRoaXMucGVuZGluZ0xpbms7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgd2luZG93LmxvY2F0aW9uLnJlbG9hZCgpO1xuICAgICAgICB9XG4gICAgICB9LCBhZnRlck1zKTtcbiAgICB9XG4gICAgZ2V0SG9va0NhbGxiYWNrcyhuYW1lKSB7XG4gICAgICByZXR1cm4gbmFtZSAmJiBuYW1lLnN0YXJ0c1dpdGgoXCJQaG9lbml4LlwiKSA/IGhvb2tzX2RlZmF1bHRbbmFtZS5zcGxpdChcIi5cIilbMV1dIDogdGhpcy5ob29rc1tuYW1lXTtcbiAgICB9XG4gICAgaXNVbmxvYWRlZCgpIHtcbiAgICAgIHJldHVybiB0aGlzLnVubG9hZGVkO1xuICAgIH1cbiAgICBpc0Nvbm5lY3RlZCgpIHtcbiAgICAgIHJldHVybiB0aGlzLnNvY2tldC5pc0Nvbm5lY3RlZCgpO1xuICAgIH1cbiAgICBnZXRCaW5kaW5nUHJlZml4KCkge1xuICAgICAgcmV0dXJuIHRoaXMuYmluZGluZ1ByZWZpeDtcbiAgICB9XG4gICAgYmluZGluZyhraW5kKSB7XG4gICAgICByZXR1cm4gYCR7dGhpcy5nZXRCaW5kaW5nUHJlZml4KCl9JHtraW5kfWA7XG4gICAgfVxuICAgIGNoYW5uZWwodG9waWMsIHBhcmFtcykge1xuICAgICAgcmV0dXJuIHRoaXMuc29ja2V0LmNoYW5uZWwodG9waWMsIHBhcmFtcyk7XG4gICAgfVxuICAgIGpvaW5Sb290Vmlld3MoKSB7XG4gICAgICBsZXQgcm9vdHNGb3VuZCA9IGZhbHNlO1xuICAgICAgZG9tX2RlZmF1bHQuYWxsKGRvY3VtZW50LCBgJHtQSFhfVklFV19TRUxFQ1RPUn06bm90KFske1BIWF9QQVJFTlRfSUR9XSlgLCAocm9vdEVsKSA9PiB7XG4gICAgICAgIGlmICghdGhpcy5nZXRSb290QnlJZChyb290RWwuaWQpKSB7XG4gICAgICAgICAgbGV0IHZpZXcgPSB0aGlzLm5ld1Jvb3RWaWV3KHJvb3RFbCk7XG4gICAgICAgICAgdmlldy5zZXRIcmVmKHRoaXMuZ2V0SHJlZigpKTtcbiAgICAgICAgICB2aWV3LmpvaW4oKTtcbiAgICAgICAgICBpZiAocm9vdEVsLmdldEF0dHJpYnV0ZShQSFhfTUFJTikpIHtcbiAgICAgICAgICAgIHRoaXMubWFpbiA9IHZpZXc7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJvb3RzRm91bmQgPSB0cnVlO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gcm9vdHNGb3VuZDtcbiAgICB9XG4gICAgcmVkaXJlY3QodG8sIGZsYXNoKSB7XG4gICAgICB0aGlzLmRpc2Nvbm5lY3QoKTtcbiAgICAgIGJyb3dzZXJfZGVmYXVsdC5yZWRpcmVjdCh0bywgZmxhc2gpO1xuICAgIH1cbiAgICByZXBsYWNlTWFpbihocmVmLCBmbGFzaCwgY2FsbGJhY2sgPSBudWxsLCBsaW5rUmVmID0gdGhpcy5zZXRQZW5kaW5nTGluayhocmVmKSkge1xuICAgICAgbGV0IG9sZE1haW5FbCA9IHRoaXMubWFpbi5lbDtcbiAgICAgIGxldCBuZXdNYWluRWwgPSBkb21fZGVmYXVsdC5jbG9uZU5vZGUob2xkTWFpbkVsLCBcIlwiKTtcbiAgICAgIHRoaXMubWFpbi5zaG93TG9hZGVyKHRoaXMubG9hZGVyVGltZW91dCk7XG4gICAgICB0aGlzLm1haW4uZGVzdHJveSgpO1xuICAgICAgdGhpcy5tYWluID0gdGhpcy5uZXdSb290VmlldyhuZXdNYWluRWwsIGZsYXNoKTtcbiAgICAgIHRoaXMubWFpbi5zZXRSZWRpcmVjdChocmVmKTtcbiAgICAgIHRoaXMudHJhbnNpdGlvblJlbW92ZXMoKTtcbiAgICAgIHRoaXMubWFpbi5qb2luKChqb2luQ291bnQsIG9uRG9uZSkgPT4ge1xuICAgICAgICBpZiAoam9pbkNvdW50ID09PSAxICYmIHRoaXMuY29tbWl0UGVuZGluZ0xpbmsobGlua1JlZikpIHtcbiAgICAgICAgICB0aGlzLnJlcXVlc3RET01VcGRhdGUoKCkgPT4ge1xuICAgICAgICAgICAgb2xkTWFpbkVsLnJlcGxhY2VXaXRoKG5ld01haW5FbCk7XG4gICAgICAgICAgICBjYWxsYmFjayAmJiBjYWxsYmFjaygpO1xuICAgICAgICAgICAgb25Eb25lKCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICB0cmFuc2l0aW9uUmVtb3ZlcyhlbGVtZW50cykge1xuICAgICAgbGV0IHJlbW92ZUF0dHIgPSB0aGlzLmJpbmRpbmcoXCJyZW1vdmVcIik7XG4gICAgICBlbGVtZW50cyA9IGVsZW1lbnRzIHx8IGRvbV9kZWZhdWx0LmFsbChkb2N1bWVudCwgYFske3JlbW92ZUF0dHJ9XWApO1xuICAgICAgZWxlbWVudHMuZm9yRWFjaCgoZWwpID0+IHtcbiAgICAgICAgaWYgKGRvY3VtZW50LmJvZHkuY29udGFpbnMoZWwpKSB7XG4gICAgICAgICAgdGhpcy5leGVjSlMoZWwsIGVsLmdldEF0dHJpYnV0ZShyZW1vdmVBdHRyKSwgXCJyZW1vdmVcIik7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICBpc1BoeFZpZXcoZWwpIHtcbiAgICAgIHJldHVybiBlbC5nZXRBdHRyaWJ1dGUgJiYgZWwuZ2V0QXR0cmlidXRlKFBIWF9TRVNTSU9OKSAhPT0gbnVsbDtcbiAgICB9XG4gICAgbmV3Um9vdFZpZXcoZWwsIGZsYXNoKSB7XG4gICAgICBsZXQgdmlldyA9IG5ldyBWaWV3KGVsLCB0aGlzLCBudWxsLCBmbGFzaCk7XG4gICAgICB0aGlzLnJvb3RzW3ZpZXcuaWRdID0gdmlldztcbiAgICAgIHJldHVybiB2aWV3O1xuICAgIH1cbiAgICBvd25lcihjaGlsZEVsLCBjYWxsYmFjaykge1xuICAgICAgbGV0IHZpZXcgPSBtYXliZShjaGlsZEVsLmNsb3Nlc3QoUEhYX1ZJRVdfU0VMRUNUT1IpLCAoZWwpID0+IHRoaXMuZ2V0Vmlld0J5RWwoZWwpKSB8fCB0aGlzLm1haW47XG4gICAgICBpZiAodmlldykge1xuICAgICAgICBjYWxsYmFjayh2aWV3KTtcbiAgICAgIH1cbiAgICB9XG4gICAgd2l0aGluT3duZXJzKGNoaWxkRWwsIGNhbGxiYWNrKSB7XG4gICAgICB0aGlzLm93bmVyKGNoaWxkRWwsICh2aWV3KSA9PiBjYWxsYmFjayh2aWV3LCBjaGlsZEVsKSk7XG4gICAgfVxuICAgIGdldFZpZXdCeUVsKGVsKSB7XG4gICAgICBsZXQgcm9vdElkID0gZWwuZ2V0QXR0cmlidXRlKFBIWF9ST09UX0lEKTtcbiAgICAgIHJldHVybiBtYXliZSh0aGlzLmdldFJvb3RCeUlkKHJvb3RJZCksIChyb290KSA9PiByb290LmdldERlc2NlbmRlbnRCeUVsKGVsKSk7XG4gICAgfVxuICAgIGdldFJvb3RCeUlkKGlkKSB7XG4gICAgICByZXR1cm4gdGhpcy5yb290c1tpZF07XG4gICAgfVxuICAgIGRlc3Ryb3lBbGxWaWV3cygpIHtcbiAgICAgIGZvciAobGV0IGlkIGluIHRoaXMucm9vdHMpIHtcbiAgICAgICAgdGhpcy5yb290c1tpZF0uZGVzdHJveSgpO1xuICAgICAgICBkZWxldGUgdGhpcy5yb290c1tpZF07XG4gICAgICB9XG4gICAgfVxuICAgIGRlc3Ryb3lWaWV3QnlFbChlbCkge1xuICAgICAgbGV0IHJvb3QgPSB0aGlzLmdldFJvb3RCeUlkKGVsLmdldEF0dHJpYnV0ZShQSFhfUk9PVF9JRCkpO1xuICAgICAgaWYgKHJvb3QpIHtcbiAgICAgICAgcm9vdC5kZXN0cm95RGVzY2VuZGVudChlbC5pZCk7XG4gICAgICB9XG4gICAgfVxuICAgIHNldEFjdGl2ZUVsZW1lbnQodGFyZ2V0KSB7XG4gICAgICBpZiAodGhpcy5hY3RpdmVFbGVtZW50ID09PSB0YXJnZXQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5hY3RpdmVFbGVtZW50ID0gdGFyZ2V0O1xuICAgICAgbGV0IGNhbmNlbCA9ICgpID0+IHtcbiAgICAgICAgaWYgKHRhcmdldCA9PT0gdGhpcy5hY3RpdmVFbGVtZW50KSB7XG4gICAgICAgICAgdGhpcy5hY3RpdmVFbGVtZW50ID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB0YXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNldXBcIiwgdGhpcyk7XG4gICAgICAgIHRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKFwidG91Y2hlbmRcIiwgdGhpcyk7XG4gICAgICB9O1xuICAgICAgdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZXVwXCIsIGNhbmNlbCk7XG4gICAgICB0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcihcInRvdWNoZW5kXCIsIGNhbmNlbCk7XG4gICAgfVxuICAgIGdldEFjdGl2ZUVsZW1lbnQoKSB7XG4gICAgICBpZiAoZG9jdW1lbnQuYWN0aXZlRWxlbWVudCA9PT0gZG9jdW1lbnQuYm9keSkge1xuICAgICAgICByZXR1cm4gdGhpcy5hY3RpdmVFbGVtZW50IHx8IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZG9jdW1lbnQuYWN0aXZlRWxlbWVudCB8fCBkb2N1bWVudC5ib2R5O1xuICAgICAgfVxuICAgIH1cbiAgICBkcm9wQWN0aXZlRWxlbWVudCh2aWV3KSB7XG4gICAgICBpZiAodGhpcy5wcmV2QWN0aXZlICYmIHZpZXcub3duc0VsZW1lbnQodGhpcy5wcmV2QWN0aXZlKSkge1xuICAgICAgICB0aGlzLnByZXZBY3RpdmUgPSBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgICByZXN0b3JlUHJldmlvdXNseUFjdGl2ZUZvY3VzKCkge1xuICAgICAgaWYgKHRoaXMucHJldkFjdGl2ZSAmJiB0aGlzLnByZXZBY3RpdmUgIT09IGRvY3VtZW50LmJvZHkpIHtcbiAgICAgICAgdGhpcy5wcmV2QWN0aXZlLmZvY3VzKCk7XG4gICAgICB9XG4gICAgfVxuICAgIGJsdXJBY3RpdmVFbGVtZW50KCkge1xuICAgICAgdGhpcy5wcmV2QWN0aXZlID0gdGhpcy5nZXRBY3RpdmVFbGVtZW50KCk7XG4gICAgICBpZiAodGhpcy5wcmV2QWN0aXZlICE9PSBkb2N1bWVudC5ib2R5KSB7XG4gICAgICAgIHRoaXMucHJldkFjdGl2ZS5ibHVyKCk7XG4gICAgICB9XG4gICAgfVxuICAgIGJpbmRUb3BMZXZlbEV2ZW50cygpIHtcbiAgICAgIGlmICh0aGlzLmJvdW5kVG9wTGV2ZWxFdmVudHMpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5ib3VuZFRvcExldmVsRXZlbnRzID0gdHJ1ZTtcbiAgICAgIGRvY3VtZW50LmJvZHkuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgfSk7XG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInBhZ2VzaG93XCIsIChlKSA9PiB7XG4gICAgICAgIGlmIChlLnBlcnNpc3RlZCkge1xuICAgICAgICAgIHRoaXMuZ2V0U29ja2V0KCkuZGlzY29ubmVjdCgpO1xuICAgICAgICAgIHRoaXMud2l0aFBhZ2VMb2FkaW5nKHsgdG86IHdpbmRvdy5sb2NhdGlvbi5ocmVmLCBraW5kOiBcInJlZGlyZWN0XCIgfSk7XG4gICAgICAgICAgd2luZG93LmxvY2F0aW9uLnJlbG9hZCgpO1xuICAgICAgICB9XG4gICAgICB9LCB0cnVlKTtcbiAgICAgIHRoaXMuYmluZE5hdigpO1xuICAgICAgdGhpcy5iaW5kQ2xpY2tzKCk7XG4gICAgICB0aGlzLmJpbmRGb3JtcygpO1xuICAgICAgdGhpcy5iaW5kKHsga2V5dXA6IFwia2V5dXBcIiwga2V5ZG93bjogXCJrZXlkb3duXCIgfSwgKGUsIHR5cGUsIHZpZXcsIHRhcmdldEVsLCBwaHhFdmVudCwgZXZlbnRUYXJnZXQpID0+IHtcbiAgICAgICAgbGV0IG1hdGNoS2V5ID0gdGFyZ2V0RWwuZ2V0QXR0cmlidXRlKHRoaXMuYmluZGluZyhQSFhfS0VZKSk7XG4gICAgICAgIGxldCBwcmVzc2VkS2V5ID0gZS5rZXkgJiYgZS5rZXkudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgaWYgKG1hdGNoS2V5ICYmIG1hdGNoS2V5LnRvTG93ZXJDYXNlKCkgIT09IHByZXNzZWRLZXkpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGRhdGEgPSBfX3NwcmVhZFZhbHVlcyh7IGtleTogZS5rZXkgfSwgdGhpcy5ldmVudE1ldGEodHlwZSwgZSwgdGFyZ2V0RWwpKTtcbiAgICAgICAganNfZGVmYXVsdC5leGVjKHR5cGUsIHBoeEV2ZW50LCB2aWV3LCB0YXJnZXRFbCwgW1wicHVzaFwiLCB7IGRhdGEgfV0pO1xuICAgICAgfSk7XG4gICAgICB0aGlzLmJpbmQoeyBibHVyOiBcImZvY3Vzb3V0XCIsIGZvY3VzOiBcImZvY3VzaW5cIiB9LCAoZSwgdHlwZSwgdmlldywgdGFyZ2V0RWwsIHBoeEV2ZW50LCBldmVudFRhcmdldCkgPT4ge1xuICAgICAgICBpZiAoIWV2ZW50VGFyZ2V0KSB7XG4gICAgICAgICAgbGV0IGRhdGEgPSBfX3NwcmVhZFZhbHVlcyh7IGtleTogZS5rZXkgfSwgdGhpcy5ldmVudE1ldGEodHlwZSwgZSwgdGFyZ2V0RWwpKTtcbiAgICAgICAgICBqc19kZWZhdWx0LmV4ZWModHlwZSwgcGh4RXZlbnQsIHZpZXcsIHRhcmdldEVsLCBbXCJwdXNoXCIsIHsgZGF0YSB9XSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgdGhpcy5iaW5kKHsgYmx1cjogXCJibHVyXCIsIGZvY3VzOiBcImZvY3VzXCIgfSwgKGUsIHR5cGUsIHZpZXcsIHRhcmdldEVsLCB0YXJnZXRDdHgsIHBoeEV2ZW50LCBwaHhUYXJnZXQpID0+IHtcbiAgICAgICAgaWYgKHBoeFRhcmdldCA9PT0gXCJ3aW5kb3dcIikge1xuICAgICAgICAgIGxldCBkYXRhID0gdGhpcy5ldmVudE1ldGEodHlwZSwgZSwgdGFyZ2V0RWwpO1xuICAgICAgICAgIGpzX2RlZmF1bHQuZXhlYyh0eXBlLCBwaHhFdmVudCwgdmlldywgdGFyZ2V0RWwsIFtcInB1c2hcIiwgeyBkYXRhIH1dKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcImRyYWdvdmVyXCIsIChlKSA9PiBlLnByZXZlbnREZWZhdWx0KCkpO1xuICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJkcm9wXCIsIChlKSA9PiB7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgbGV0IGRyb3BUYXJnZXRJZCA9IG1heWJlKGNsb3Nlc3RQaHhCaW5kaW5nKGUudGFyZ2V0LCB0aGlzLmJpbmRpbmcoUEhYX0RST1BfVEFSR0VUKSksICh0cnVlVGFyZ2V0KSA9PiB7XG4gICAgICAgICAgcmV0dXJuIHRydWVUYXJnZXQuZ2V0QXR0cmlidXRlKHRoaXMuYmluZGluZyhQSFhfRFJPUF9UQVJHRVQpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGxldCBkcm9wVGFyZ2V0ID0gZHJvcFRhcmdldElkICYmIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGRyb3BUYXJnZXRJZCk7XG4gICAgICAgIGxldCBmaWxlcyA9IEFycmF5LmZyb20oZS5kYXRhVHJhbnNmZXIuZmlsZXMgfHwgW10pO1xuICAgICAgICBpZiAoIWRyb3BUYXJnZXQgfHwgZHJvcFRhcmdldC5kaXNhYmxlZCB8fCBmaWxlcy5sZW5ndGggPT09IDAgfHwgIShkcm9wVGFyZ2V0LmZpbGVzIGluc3RhbmNlb2YgRmlsZUxpc3QpKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIExpdmVVcGxvYWRlci50cmFja0ZpbGVzKGRyb3BUYXJnZXQsIGZpbGVzKTtcbiAgICAgICAgZHJvcFRhcmdldC5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudChcImlucHV0XCIsIHsgYnViYmxlczogdHJ1ZSB9KSk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMub24oUEhYX1RSQUNLX1VQTE9BRFMsIChlKSA9PiB7XG4gICAgICAgIGxldCB1cGxvYWRUYXJnZXQgPSBlLnRhcmdldDtcbiAgICAgICAgaWYgKCFkb21fZGVmYXVsdC5pc1VwbG9hZElucHV0KHVwbG9hZFRhcmdldCkpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGZpbGVzID0gQXJyYXkuZnJvbShlLmRldGFpbC5maWxlcyB8fCBbXSkuZmlsdGVyKChmKSA9PiBmIGluc3RhbmNlb2YgRmlsZSB8fCBmIGluc3RhbmNlb2YgQmxvYik7XG4gICAgICAgIExpdmVVcGxvYWRlci50cmFja0ZpbGVzKHVwbG9hZFRhcmdldCwgZmlsZXMpO1xuICAgICAgICB1cGxvYWRUYXJnZXQuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoXCJpbnB1dFwiLCB7IGJ1YmJsZXM6IHRydWUgfSkpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIGV2ZW50TWV0YShldmVudE5hbWUsIGUsIHRhcmdldEVsKSB7XG4gICAgICBsZXQgY2FsbGJhY2sgPSB0aGlzLm1ldGFkYXRhQ2FsbGJhY2tzW2V2ZW50TmFtZV07XG4gICAgICByZXR1cm4gY2FsbGJhY2sgPyBjYWxsYmFjayhlLCB0YXJnZXRFbCkgOiB7fTtcbiAgICB9XG4gICAgc2V0UGVuZGluZ0xpbmsoaHJlZikge1xuICAgICAgdGhpcy5saW5rUmVmKys7XG4gICAgICB0aGlzLnBlbmRpbmdMaW5rID0gaHJlZjtcbiAgICAgIHJldHVybiB0aGlzLmxpbmtSZWY7XG4gICAgfVxuICAgIGNvbW1pdFBlbmRpbmdMaW5rKGxpbmtSZWYpIHtcbiAgICAgIGlmICh0aGlzLmxpbmtSZWYgIT09IGxpbmtSZWYpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5ocmVmID0gdGhpcy5wZW5kaW5nTGluaztcbiAgICAgICAgdGhpcy5wZW5kaW5nTGluayA9IG51bGw7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICBnZXRIcmVmKCkge1xuICAgICAgcmV0dXJuIHRoaXMuaHJlZjtcbiAgICB9XG4gICAgaGFzUGVuZGluZ0xpbmsoKSB7XG4gICAgICByZXR1cm4gISF0aGlzLnBlbmRpbmdMaW5rO1xuICAgIH1cbiAgICBiaW5kKGV2ZW50cywgY2FsbGJhY2spIHtcbiAgICAgIGZvciAobGV0IGV2ZW50IGluIGV2ZW50cykge1xuICAgICAgICBsZXQgYnJvd3NlckV2ZW50TmFtZSA9IGV2ZW50c1tldmVudF07XG4gICAgICAgIHRoaXMub24oYnJvd3NlckV2ZW50TmFtZSwgKGUpID0+IHtcbiAgICAgICAgICBsZXQgYmluZGluZyA9IHRoaXMuYmluZGluZyhldmVudCk7XG4gICAgICAgICAgbGV0IHdpbmRvd0JpbmRpbmcgPSB0aGlzLmJpbmRpbmcoYHdpbmRvdy0ke2V2ZW50fWApO1xuICAgICAgICAgIGxldCB0YXJnZXRQaHhFdmVudCA9IGUudGFyZ2V0LmdldEF0dHJpYnV0ZSAmJiBlLnRhcmdldC5nZXRBdHRyaWJ1dGUoYmluZGluZyk7XG4gICAgICAgICAgaWYgKHRhcmdldFBoeEV2ZW50KSB7XG4gICAgICAgICAgICB0aGlzLmRlYm91bmNlKGUudGFyZ2V0LCBlLCAoKSA9PiB7XG4gICAgICAgICAgICAgIHRoaXMud2l0aGluT3duZXJzKGUudGFyZ2V0LCAodmlldykgPT4ge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKGUsIGV2ZW50LCB2aWV3LCBlLnRhcmdldCwgdGFyZ2V0UGh4RXZlbnQsIG51bGwpO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkb21fZGVmYXVsdC5hbGwoZG9jdW1lbnQsIGBbJHt3aW5kb3dCaW5kaW5nfV1gLCAoZWwpID0+IHtcbiAgICAgICAgICAgICAgbGV0IHBoeEV2ZW50ID0gZWwuZ2V0QXR0cmlidXRlKHdpbmRvd0JpbmRpbmcpO1xuICAgICAgICAgICAgICB0aGlzLmRlYm91bmNlKGVsLCBlLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy53aXRoaW5Pd25lcnMoZWwsICh2aWV3KSA9PiB7XG4gICAgICAgICAgICAgICAgICBjYWxsYmFjayhlLCBldmVudCwgdmlldywgZWwsIHBoeEV2ZW50LCBcIndpbmRvd1wiKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICBiaW5kQ2xpY2tzKCkge1xuICAgICAgdGhpcy5iaW5kQ2xpY2soXCJjbGlja1wiLCBcImNsaWNrXCIsIGZhbHNlKTtcbiAgICAgIHRoaXMuYmluZENsaWNrKFwibW91c2Vkb3duXCIsIFwiY2FwdHVyZS1jbGlja1wiLCB0cnVlKTtcbiAgICB9XG4gICAgYmluZENsaWNrKGV2ZW50TmFtZSwgYmluZGluZ05hbWUsIGNhcHR1cmUpIHtcbiAgICAgIGxldCBjbGljayA9IHRoaXMuYmluZGluZyhiaW5kaW5nTmFtZSk7XG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIChlKSA9PiB7XG4gICAgICAgIGlmICghdGhpcy5pc0Nvbm5lY3RlZCgpKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGxldCB0YXJnZXQgPSBudWxsO1xuICAgICAgICBpZiAoY2FwdHVyZSkge1xuICAgICAgICAgIHRhcmdldCA9IGUudGFyZ2V0Lm1hdGNoZXMoYFske2NsaWNrfV1gKSA/IGUudGFyZ2V0IDogZS50YXJnZXQucXVlcnlTZWxlY3RvcihgWyR7Y2xpY2t9XWApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRhcmdldCA9IGNsb3Nlc3RQaHhCaW5kaW5nKGUudGFyZ2V0LCBjbGljayk7XG4gICAgICAgICAgdGhpcy5kaXNwYXRjaENsaWNrQXdheShlKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcGh4RXZlbnQgPSB0YXJnZXQgJiYgdGFyZ2V0LmdldEF0dHJpYnV0ZShjbGljayk7XG4gICAgICAgIGlmICghcGh4RXZlbnQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRhcmdldC5nZXRBdHRyaWJ1dGUoXCJocmVmXCIpID09PSBcIiNcIikge1xuICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRlYm91bmNlKHRhcmdldCwgZSwgKCkgPT4ge1xuICAgICAgICAgIHRoaXMud2l0aGluT3duZXJzKHRhcmdldCwgKHZpZXcpID0+IHtcbiAgICAgICAgICAgIGpzX2RlZmF1bHQuZXhlYyhcImNsaWNrXCIsIHBoeEV2ZW50LCB2aWV3LCB0YXJnZXQsIFtcInB1c2hcIiwgeyBkYXRhOiB0aGlzLmV2ZW50TWV0YShcImNsaWNrXCIsIGUsIHRhcmdldCkgfV0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH0sIGNhcHR1cmUpO1xuICAgIH1cbiAgICBkaXNwYXRjaENsaWNrQXdheShlKSB7XG4gICAgICBsZXQgYmluZGluZyA9IHRoaXMuYmluZGluZyhcImNsaWNrLWF3YXlcIik7XG4gICAgICBkb21fZGVmYXVsdC5hbGwoZG9jdW1lbnQsIGBbJHtiaW5kaW5nfV1gLCAoZWwpID0+IHtcbiAgICAgICAgaWYgKCEoZWwuaXNTYW1lTm9kZShlLnRhcmdldCkgfHwgZWwuY29udGFpbnMoZS50YXJnZXQpKSkge1xuICAgICAgICAgIHRoaXMud2l0aGluT3duZXJzKGUudGFyZ2V0LCAodmlldykgPT4ge1xuICAgICAgICAgICAgbGV0IHBoeEV2ZW50ID0gZWwuZ2V0QXR0cmlidXRlKGJpbmRpbmcpO1xuICAgICAgICAgICAgaWYgKGpzX2RlZmF1bHQuaXNWaXNpYmxlKGVsKSkge1xuICAgICAgICAgICAgICBqc19kZWZhdWx0LmV4ZWMoXCJjbGlja1wiLCBwaHhFdmVudCwgdmlldywgZS50YXJnZXQsIFtcInB1c2hcIiwgeyBkYXRhOiB0aGlzLmV2ZW50TWV0YShcImNsaWNrXCIsIGUsIGUudGFyZ2V0KSB9XSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICBiaW5kTmF2KCkge1xuICAgICAgaWYgKCFicm93c2VyX2RlZmF1bHQuY2FuUHVzaFN0YXRlKCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGhpc3Rvcnkuc2Nyb2xsUmVzdG9yYXRpb24pIHtcbiAgICAgICAgaGlzdG9yeS5zY3JvbGxSZXN0b3JhdGlvbiA9IFwibWFudWFsXCI7XG4gICAgICB9XG4gICAgICBsZXQgc2Nyb2xsVGltZXIgPSBudWxsO1xuICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJzY3JvbGxcIiwgKF9lKSA9PiB7XG4gICAgICAgIGNsZWFyVGltZW91dChzY3JvbGxUaW1lcik7XG4gICAgICAgIHNjcm9sbFRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgYnJvd3Nlcl9kZWZhdWx0LnVwZGF0ZUN1cnJlbnRTdGF0ZSgoc3RhdGUpID0+IE9iamVjdC5hc3NpZ24oc3RhdGUsIHsgc2Nyb2xsOiB3aW5kb3cuc2Nyb2xsWSB9KSk7XG4gICAgICAgIH0sIDEwMCk7XG4gICAgICB9KTtcbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwicG9wc3RhdGVcIiwgKGV2ZW50KSA9PiB7XG4gICAgICAgIGlmICghdGhpcy5yZWdpc3Rlck5ld0xvY2F0aW9uKHdpbmRvdy5sb2NhdGlvbikpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHsgdHlwZSwgaWQsIHJvb3QsIHNjcm9sbCB9ID0gZXZlbnQuc3RhdGUgfHwge307XG4gICAgICAgIGxldCBocmVmID0gd2luZG93LmxvY2F0aW9uLmhyZWY7XG4gICAgICAgIHRoaXMucmVxdWVzdERPTVVwZGF0ZSgoKSA9PiB7XG4gICAgICAgICAgaWYgKHRoaXMubWFpbi5pc0Nvbm5lY3RlZCgpICYmICh0eXBlID09PSBcInBhdGNoXCIgJiYgaWQgPT09IHRoaXMubWFpbi5pZCkpIHtcbiAgICAgICAgICAgIHRoaXMubWFpbi5wdXNoTGlua1BhdGNoKGhyZWYsIG51bGwpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnJlcGxhY2VNYWluKGhyZWYsIG51bGwsICgpID0+IHtcbiAgICAgICAgICAgICAgaWYgKHJvb3QpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlcGxhY2VSb290SGlzdG9yeSgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmICh0eXBlb2Ygc2Nyb2xsID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICB3aW5kb3cuc2Nyb2xsVG8oMCwgc2Nyb2xsKTtcbiAgICAgICAgICAgICAgICB9LCAwKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0sIGZhbHNlKTtcbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgKGUpID0+IHtcbiAgICAgICAgbGV0IHRhcmdldCA9IGNsb3Nlc3RQaHhCaW5kaW5nKGUudGFyZ2V0LCBQSFhfTElWRV9MSU5LKTtcbiAgICAgICAgbGV0IHR5cGUgPSB0YXJnZXQgJiYgdGFyZ2V0LmdldEF0dHJpYnV0ZShQSFhfTElWRV9MSU5LKTtcbiAgICAgICAgbGV0IHdhbnRzTmV3VGFiID0gZS5tZXRhS2V5IHx8IGUuY3RybEtleSB8fCBlLmJ1dHRvbiA9PT0gMTtcbiAgICAgICAgaWYgKCF0eXBlIHx8ICF0aGlzLmlzQ29ubmVjdGVkKCkgfHwgIXRoaXMubWFpbiB8fCB3YW50c05ld1RhYikge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgaHJlZiA9IHRhcmdldC5ocmVmO1xuICAgICAgICBsZXQgbGlua1N0YXRlID0gdGFyZ2V0LmdldEF0dHJpYnV0ZShQSFhfTElOS19TVEFURSk7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgaWYgKHRoaXMucGVuZGluZ0xpbmsgPT09IGhyZWYpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZXF1ZXN0RE9NVXBkYXRlKCgpID0+IHtcbiAgICAgICAgICBpZiAodHlwZSA9PT0gXCJwYXRjaFwiKSB7XG4gICAgICAgICAgICB0aGlzLnB1c2hIaXN0b3J5UGF0Y2goaHJlZiwgbGlua1N0YXRlLCB0YXJnZXQpO1xuICAgICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gXCJyZWRpcmVjdFwiKSB7XG4gICAgICAgICAgICB0aGlzLmhpc3RvcnlSZWRpcmVjdChocmVmLCBsaW5rU3RhdGUpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGV4cGVjdGVkICR7UEhYX0xJVkVfTElOS30gdG8gYmUgXCJwYXRjaFwiIG9yIFwicmVkaXJlY3RcIiwgZ290OiAke3R5cGV9YCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0sIGZhbHNlKTtcbiAgICB9XG4gICAgZGlzcGF0Y2hFdmVudChldmVudCwgcGF5bG9hZCA9IHt9KSB7XG4gICAgICBkb21fZGVmYXVsdC5kaXNwYXRjaEV2ZW50KHdpbmRvdywgYHBoeDoke2V2ZW50fWAsIHBheWxvYWQpO1xuICAgIH1cbiAgICBkaXNwYXRjaEV2ZW50cyhldmVudHMpIHtcbiAgICAgIGV2ZW50cy5mb3JFYWNoKChbZXZlbnQsIHBheWxvYWRdKSA9PiB0aGlzLmRpc3BhdGNoRXZlbnQoZXZlbnQsIHBheWxvYWQpKTtcbiAgICB9XG4gICAgd2l0aFBhZ2VMb2FkaW5nKGluZm8sIGNhbGxiYWNrKSB7XG4gICAgICBkb21fZGVmYXVsdC5kaXNwYXRjaEV2ZW50KHdpbmRvdywgXCJwaHg6cGFnZS1sb2FkaW5nLXN0YXJ0XCIsIGluZm8pO1xuICAgICAgbGV0IGRvbmUgPSAoKSA9PiBkb21fZGVmYXVsdC5kaXNwYXRjaEV2ZW50KHdpbmRvdywgXCJwaHg6cGFnZS1sb2FkaW5nLXN0b3BcIiwgaW5mbyk7XG4gICAgICByZXR1cm4gY2FsbGJhY2sgPyBjYWxsYmFjayhkb25lKSA6IGRvbmU7XG4gICAgfVxuICAgIHB1c2hIaXN0b3J5UGF0Y2goaHJlZiwgbGlua1N0YXRlLCB0YXJnZXRFbCkge1xuICAgICAgdGhpcy53aXRoUGFnZUxvYWRpbmcoeyB0bzogaHJlZiwga2luZDogXCJwYXRjaFwiIH0sIChkb25lKSA9PiB7XG4gICAgICAgIHRoaXMubWFpbi5wdXNoTGlua1BhdGNoKGhyZWYsIHRhcmdldEVsLCAobGlua1JlZikgPT4ge1xuICAgICAgICAgIHRoaXMuaGlzdG9yeVBhdGNoKGhyZWYsIGxpbmtTdGF0ZSwgbGlua1JlZik7XG4gICAgICAgICAgZG9uZSgpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBoaXN0b3J5UGF0Y2goaHJlZiwgbGlua1N0YXRlLCBsaW5rUmVmID0gdGhpcy5zZXRQZW5kaW5nTGluayhocmVmKSkge1xuICAgICAgaWYgKCF0aGlzLmNvbW1pdFBlbmRpbmdMaW5rKGxpbmtSZWYpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGJyb3dzZXJfZGVmYXVsdC5wdXNoU3RhdGUobGlua1N0YXRlLCB7IHR5cGU6IFwicGF0Y2hcIiwgaWQ6IHRoaXMubWFpbi5pZCB9LCBocmVmKTtcbiAgICAgIHRoaXMucmVnaXN0ZXJOZXdMb2NhdGlvbih3aW5kb3cubG9jYXRpb24pO1xuICAgIH1cbiAgICBoaXN0b3J5UmVkaXJlY3QoaHJlZiwgbGlua1N0YXRlLCBmbGFzaCkge1xuICAgICAgbGV0IHNjcm9sbCA9IHdpbmRvdy5zY3JvbGxZO1xuICAgICAgdGhpcy53aXRoUGFnZUxvYWRpbmcoeyB0bzogaHJlZiwga2luZDogXCJyZWRpcmVjdFwiIH0sIChkb25lKSA9PiB7XG4gICAgICAgIHRoaXMucmVwbGFjZU1haW4oaHJlZiwgZmxhc2gsICgpID0+IHtcbiAgICAgICAgICBicm93c2VyX2RlZmF1bHQucHVzaFN0YXRlKGxpbmtTdGF0ZSwgeyB0eXBlOiBcInJlZGlyZWN0XCIsIGlkOiB0aGlzLm1haW4uaWQsIHNjcm9sbCB9LCBocmVmKTtcbiAgICAgICAgICB0aGlzLnJlZ2lzdGVyTmV3TG9jYXRpb24od2luZG93LmxvY2F0aW9uKTtcbiAgICAgICAgICBkb25lKCk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHJlcGxhY2VSb290SGlzdG9yeSgpIHtcbiAgICAgIGJyb3dzZXJfZGVmYXVsdC5wdXNoU3RhdGUoXCJyZXBsYWNlXCIsIHsgcm9vdDogdHJ1ZSwgdHlwZTogXCJwYXRjaFwiLCBpZDogdGhpcy5tYWluLmlkIH0pO1xuICAgIH1cbiAgICByZWdpc3Rlck5ld0xvY2F0aW9uKG5ld0xvY2F0aW9uKSB7XG4gICAgICBsZXQgeyBwYXRobmFtZSwgc2VhcmNoIH0gPSB0aGlzLmN1cnJlbnRMb2NhdGlvbjtcbiAgICAgIGlmIChwYXRobmFtZSArIHNlYXJjaCA9PT0gbmV3TG9jYXRpb24ucGF0aG5hbWUgKyBuZXdMb2NhdGlvbi5zZWFyY2gpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5jdXJyZW50TG9jYXRpb24gPSBjbG9uZShuZXdMb2NhdGlvbik7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICBiaW5kRm9ybXMoKSB7XG4gICAgICBsZXQgaXRlcmF0aW9ucyA9IDA7XG4gICAgICB0aGlzLm9uKFwic3VibWl0XCIsIChlKSA9PiB7XG4gICAgICAgIGxldCBwaHhFdmVudCA9IGUudGFyZ2V0LmdldEF0dHJpYnV0ZSh0aGlzLmJpbmRpbmcoXCJzdWJtaXRcIikpO1xuICAgICAgICBpZiAoIXBoeEV2ZW50KSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgZS50YXJnZXQuZGlzYWJsZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLndpdGhpbk93bmVycyhlLnRhcmdldCwgKHZpZXcpID0+IHtcbiAgICAgICAgICBqc19kZWZhdWx0LmV4ZWMoXCJzdWJtaXRcIiwgcGh4RXZlbnQsIHZpZXcsIGUudGFyZ2V0LCBbXCJwdXNoXCIsIHt9XSk7XG4gICAgICAgIH0pO1xuICAgICAgfSwgZmFsc2UpO1xuICAgICAgZm9yIChsZXQgdHlwZSBvZiBbXCJjaGFuZ2VcIiwgXCJpbnB1dFwiXSkge1xuICAgICAgICB0aGlzLm9uKHR5cGUsIChlKSA9PiB7XG4gICAgICAgICAgbGV0IGlucHV0ID0gZS50YXJnZXQ7XG4gICAgICAgICAgbGV0IHBoeEV2ZW50ID0gaW5wdXQuZm9ybSAmJiBpbnB1dC5mb3JtLmdldEF0dHJpYnV0ZSh0aGlzLmJpbmRpbmcoXCJjaGFuZ2VcIikpO1xuICAgICAgICAgIGlmICghcGh4RXZlbnQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGlucHV0LnR5cGUgPT09IFwibnVtYmVyXCIgJiYgaW5wdXQudmFsaWRpdHkgJiYgaW5wdXQudmFsaWRpdHkuYmFkSW5wdXQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgbGV0IGN1cnJlbnRJdGVyYXRpb25zID0gaXRlcmF0aW9ucztcbiAgICAgICAgICBpdGVyYXRpb25zKys7XG4gICAgICAgICAgbGV0IHsgYXQsIHR5cGU6IGxhc3RUeXBlIH0gPSBkb21fZGVmYXVsdC5wcml2YXRlKGlucHV0LCBcInByZXYtaXRlcmF0aW9uXCIpIHx8IHt9O1xuICAgICAgICAgIGlmIChhdCA9PT0gY3VycmVudEl0ZXJhdGlvbnMgLSAxICYmIHR5cGUgIT09IGxhc3RUeXBlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGRvbV9kZWZhdWx0LnB1dFByaXZhdGUoaW5wdXQsIFwicHJldi1pdGVyYXRpb25cIiwgeyBhdDogY3VycmVudEl0ZXJhdGlvbnMsIHR5cGUgfSk7XG4gICAgICAgICAgdGhpcy5kZWJvdW5jZShpbnB1dCwgZSwgKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy53aXRoaW5Pd25lcnMoaW5wdXQuZm9ybSwgKHZpZXcpID0+IHtcbiAgICAgICAgICAgICAgZG9tX2RlZmF1bHQucHV0UHJpdmF0ZShpbnB1dCwgUEhYX0hBU19GT0NVU0VELCB0cnVlKTtcbiAgICAgICAgICAgICAgaWYgKCFkb21fZGVmYXVsdC5pc1RleHR1YWxJbnB1dChpbnB1dCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldEFjdGl2ZUVsZW1lbnQoaW5wdXQpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGpzX2RlZmF1bHQuZXhlYyhcImNoYW5nZVwiLCBwaHhFdmVudCwgdmlldywgaW5wdXQsIFtcInB1c2hcIiwgeyBfdGFyZ2V0OiBlLnRhcmdldC5uYW1lIH1dKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9LCBmYWxzZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGRlYm91bmNlKGVsLCBldmVudCwgY2FsbGJhY2spIHtcbiAgICAgIGxldCBwaHhEZWJvdW5jZSA9IHRoaXMuYmluZGluZyhQSFhfREVCT1VOQ0UpO1xuICAgICAgbGV0IHBoeFRocm90dGxlID0gdGhpcy5iaW5kaW5nKFBIWF9USFJPVFRMRSk7XG4gICAgICBsZXQgZGVmYXVsdERlYm91bmNlID0gdGhpcy5kZWZhdWx0cy5kZWJvdW5jZS50b1N0cmluZygpO1xuICAgICAgbGV0IGRlZmF1bHRUaHJvdHRsZSA9IHRoaXMuZGVmYXVsdHMudGhyb3R0bGUudG9TdHJpbmcoKTtcbiAgICAgIGRvbV9kZWZhdWx0LmRlYm91bmNlKGVsLCBldmVudCwgcGh4RGVib3VuY2UsIGRlZmF1bHREZWJvdW5jZSwgcGh4VGhyb3R0bGUsIGRlZmF1bHRUaHJvdHRsZSwgY2FsbGJhY2spO1xuICAgIH1cbiAgICBzaWxlbmNlRXZlbnRzKGNhbGxiYWNrKSB7XG4gICAgICB0aGlzLnNpbGVuY2VkID0gdHJ1ZTtcbiAgICAgIGNhbGxiYWNrKCk7XG4gICAgICB0aGlzLnNpbGVuY2VkID0gZmFsc2U7XG4gICAgfVxuICAgIG9uKGV2ZW50LCBjYWxsYmFjaykge1xuICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIChlKSA9PiB7XG4gICAgICAgIGlmICghdGhpcy5zaWxlbmNlZCkge1xuICAgICAgICAgIGNhbGxiYWNrKGUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH07XG4gIHZhciBUcmFuc2l0aW9uU2V0ID0gY2xhc3Mge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgdGhpcy50cmFuc2l0aW9ucyA9IG5ldyBTZXQoKTtcbiAgICAgIHRoaXMucGVuZGluZ09wcyA9IFtdO1xuICAgICAgdGhpcy5yZXNldCgpO1xuICAgIH1cbiAgICByZXNldCgpIHtcbiAgICAgIHRoaXMudHJhbnNpdGlvbnMuZm9yRWFjaCgodGltZXIpID0+IHtcbiAgICAgICAgY2FuY2VsVGltZW91dCh0aW1lcik7XG4gICAgICAgIHRoaXMudHJhbnNpdGlvbnMuZGVsZXRlKHRpbWVyKTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5mbHVzaFBlbmRpbmdPcHMoKTtcbiAgICB9XG4gICAgYWZ0ZXIoY2FsbGJhY2spIHtcbiAgICAgIGlmICh0aGlzLnNpemUoKSA9PT0gMCkge1xuICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5wdXNoUGVuZGluZ09wKGNhbGxiYWNrKTtcbiAgICAgIH1cbiAgICB9XG4gICAgYWRkVHJhbnNpdGlvbih0aW1lLCBvblN0YXJ0LCBvbkRvbmUpIHtcbiAgICAgIG9uU3RhcnQoKTtcbiAgICAgIGxldCB0aW1lciA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICB0aGlzLnRyYW5zaXRpb25zLmRlbGV0ZSh0aW1lcik7XG4gICAgICAgIG9uRG9uZSgpO1xuICAgICAgICBpZiAodGhpcy5zaXplKCkgPT09IDApIHtcbiAgICAgICAgICB0aGlzLmZsdXNoUGVuZGluZ09wcygpO1xuICAgICAgICB9XG4gICAgICB9LCB0aW1lKTtcbiAgICAgIHRoaXMudHJhbnNpdGlvbnMuYWRkKHRpbWVyKTtcbiAgICB9XG4gICAgcHVzaFBlbmRpbmdPcChvcCkge1xuICAgICAgdGhpcy5wZW5kaW5nT3BzLnB1c2gob3ApO1xuICAgIH1cbiAgICBzaXplKCkge1xuICAgICAgcmV0dXJuIHRoaXMudHJhbnNpdGlvbnMuc2l6ZTtcbiAgICB9XG4gICAgZmx1c2hQZW5kaW5nT3BzKCkge1xuICAgICAgdGhpcy5wZW5kaW5nT3BzLmZvckVhY2goKG9wKSA9PiBvcCgpKTtcbiAgICAgIHRoaXMucGVuZGluZ09wcyA9IFtdO1xuICAgIH1cbiAgfTtcbiAgcmV0dXJuIHBob2VuaXhfbGl2ZV92aWV3X2V4cG9ydHM7XG59KSgpO1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBN0NBO0FBQ0E7QUErQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBbEVBO0FBbUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBN0NBO0FBOENBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBMVhBO0FBMlhBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTEE7QUFPQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQTlGQTtBQUNBO0FBZ0dBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBcEdBO0FBQ0E7QUFzR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQXZCQTtBQXdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBWkE7QUF6QkE7QUF1Q0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBOUNBO0FBQ0E7QUFnREE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUF4RUE7QUEwRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVBBO0FBU0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVJBO0FBVUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQXhHQTtBQTBHQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQTNQQTtBQUNBO0FBNlBBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQW5OQTtBQUNBO0FBcU5BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBdkVBO0FBQ0E7QUF5RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQTlKQTtBQStKQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFOQTtBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBTUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQU1BO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTEE7QUFPQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFMQTtBQU9BO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFNQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFuN0JBO0FBQ0E7QUFxN0JBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUxBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBMW9CQTtBQTJvQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUF6Q0E7QUEwQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../deps/phoenix_live_view/priv/static/phoenix_live_view.js\n");

/***/ }),

/***/ "./css/app.scss":
/*!**********************!*\
  !*** ./css/app.scss ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// extracted by mini-css-extract-plugin//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9jc3MvYXBwLnNjc3MuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9jc3MvYXBwLnNjc3M/NDY2OSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBleHRyYWN0ZWQgYnkgbWluaS1jc3MtZXh0cmFjdC1wbHVnaW4iXSwibWFwcGluZ3MiOiJBQUFBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./css/app.scss\n");

/***/ }),

/***/ "./js/app.js":
/*!*******************!*\
  !*** ./js/app.js ***!
  \*******************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _css_app_scss__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../css/app.scss */ \"./css/app.scss\");\n/* harmony import */ var _css_app_scss__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_css_app_scss__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var phoenix_html__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! phoenix_html */ \"../deps/phoenix_html/priv/static/phoenix_html.js\");\n/* harmony import */ var phoenix_html__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(phoenix_html__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var phoenix__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! phoenix */ \"../deps/phoenix/priv/static/phoenix.js\");\n/* harmony import */ var phoenix__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(phoenix__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var topbar__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! topbar */ \"./node_modules/topbar/topbar.js\");\n/* harmony import */ var topbar__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(topbar__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var phoenix_live_view__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! phoenix_live_view */ \"../deps/phoenix_live_view/priv/static/phoenix_live_view.js\");\n/* harmony import */ var phoenix_live_view__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(phoenix_live_view__WEBPACK_IMPORTED_MODULE_4__);\n// We need to import the CSS so that webpack will load it.\n// The MiniCssExtractPlugin is used to separate it out into\n// its own CSS file.\n // webpack automatically bundles all modules in your\n// entry points. Those entry points can be configured\n// in \"webpack.config.js\".\n//\n// Import deps with the dep name or local files with a relative path, for example:\n//\n//     import {Socket} from \"phoenix\"\n//     import socket from \"./socket\"\n//\n\n\n\n\n // window.twttr = (function(d, s, id) {\n//   var js, fjs = d.getElementsByTagName(s)[0],\n//     t = window.twttr || {};\n//   if (d.getElementById(id)) return;\n//   js = d.createElement(s);\n//   js.id = id;\n//   js.src = \"https://platform.twitter.com/widgets.js\";\n//   fjs.parentNode.insertBefore(js, fjs);\n// \n//   t._e = [];\n//   t.ready = function(f) {\n//     t._e.push(f);\n//   };\n// \n//   console.log('inject widget')\n// \n//   return t;\n// }(document, \"script\", \"twitter-wjs\"));\n\nvar csrfToken = document.querySelector(\"meta[name='csrf-token']\").getAttribute(\"content\");\nvar Hooks = {};\nHooks.ReloadTweets = {\n  updated: function updated() {\n    console.log('reload');\n    twttr.widgets.load();\n  }\n};\nvar liveSocket = new phoenix_live_view__WEBPACK_IMPORTED_MODULE_4__[\"LiveSocket\"](\"/live\", phoenix__WEBPACK_IMPORTED_MODULE_2__[\"Socket\"], {\n  params: {\n    _csrf_token: csrfToken\n  },\n  hooks: Hooks\n}); // Show progress bar on live navigation and form submits\n\ntopbar__WEBPACK_IMPORTED_MODULE_3___default.a.config({\n  barColors: {\n    0: \"#29d\"\n  },\n  shadowColor: \"rgba(0, 0, 0, .3)\"\n});\nwindow.addEventListener(\"phx:page-loading-start\", function (info) {\n  return topbar__WEBPACK_IMPORTED_MODULE_3___default.a.show();\n});\nwindow.addEventListener(\"phx:page-loading-stop\", function (info) {\n  return topbar__WEBPACK_IMPORTED_MODULE_3___default.a.hide();\n}); // connect if there are any LiveViews on the page\n\nliveSocket.connect(); // expose liveSocket on window for web console debug logs and latency simulation:\n// >> liveSocket.enableDebug()\n// >> liveSocket.enableLatencySim(1000)  // enabled for duration of browser session\n// >> liveSocket.disableLatencySim()\n\nwindow.liveSocket = liveSocket; // function hideBannerLoading(event) {\n//   document.getElementById(\"loading\").style.visibility = \"hidden\"\n// }\n// \n// twttr.ready(function (twttr) {\n//   twttr.events.bind('rendered', hideBannerLoading);\n// });\n\nwindow.addEventListener(\"phx:page-loading-stop\", function (info) {\n  console.log('stop');\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9qcy9hcHAuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9qcy9hcHAuanM/NzQ3MyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBXZSBuZWVkIHRvIGltcG9ydCB0aGUgQ1NTIHNvIHRoYXQgd2VicGFjayB3aWxsIGxvYWQgaXQuXG4vLyBUaGUgTWluaUNzc0V4dHJhY3RQbHVnaW4gaXMgdXNlZCB0byBzZXBhcmF0ZSBpdCBvdXQgaW50b1xuLy8gaXRzIG93biBDU1MgZmlsZS5cbmltcG9ydCBcIi4uL2Nzcy9hcHAuc2Nzc1wiXG5cbi8vIHdlYnBhY2sgYXV0b21hdGljYWxseSBidW5kbGVzIGFsbCBtb2R1bGVzIGluIHlvdXJcbi8vIGVudHJ5IHBvaW50cy4gVGhvc2UgZW50cnkgcG9pbnRzIGNhbiBiZSBjb25maWd1cmVkXG4vLyBpbiBcIndlYnBhY2suY29uZmlnLmpzXCIuXG4vL1xuLy8gSW1wb3J0IGRlcHMgd2l0aCB0aGUgZGVwIG5hbWUgb3IgbG9jYWwgZmlsZXMgd2l0aCBhIHJlbGF0aXZlIHBhdGgsIGZvciBleGFtcGxlOlxuLy9cbi8vICAgICBpbXBvcnQge1NvY2tldH0gZnJvbSBcInBob2VuaXhcIlxuLy8gICAgIGltcG9ydCBzb2NrZXQgZnJvbSBcIi4vc29ja2V0XCJcbi8vXG5pbXBvcnQgXCJwaG9lbml4X2h0bWxcIlxuaW1wb3J0IHtTb2NrZXR9IGZyb20gXCJwaG9lbml4XCJcbmltcG9ydCB0b3BiYXIgZnJvbSBcInRvcGJhclwiXG5pbXBvcnQge0xpdmVTb2NrZXR9IGZyb20gXCJwaG9lbml4X2xpdmVfdmlld1wiXG5cbi8vIHdpbmRvdy50d3R0ciA9IChmdW5jdGlvbihkLCBzLCBpZCkge1xuLy8gICB2YXIganMsIGZqcyA9IGQuZ2V0RWxlbWVudHNCeVRhZ05hbWUocylbMF0sXG4vLyAgICAgdCA9IHdpbmRvdy50d3R0ciB8fCB7fTtcbi8vICAgaWYgKGQuZ2V0RWxlbWVudEJ5SWQoaWQpKSByZXR1cm47XG4vLyAgIGpzID0gZC5jcmVhdGVFbGVtZW50KHMpO1xuLy8gICBqcy5pZCA9IGlkO1xuLy8gICBqcy5zcmMgPSBcImh0dHBzOi8vcGxhdGZvcm0udHdpdHRlci5jb20vd2lkZ2V0cy5qc1wiO1xuLy8gICBmanMucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoanMsIGZqcyk7XG4vLyBcbi8vICAgdC5fZSA9IFtdO1xuLy8gICB0LnJlYWR5ID0gZnVuY3Rpb24oZikge1xuLy8gICAgIHQuX2UucHVzaChmKTtcbi8vICAgfTtcbi8vIFxuLy8gICBjb25zb2xlLmxvZygnaW5qZWN0IHdpZGdldCcpXG4vLyBcbi8vICAgcmV0dXJuIHQ7XG4vLyB9KGRvY3VtZW50LCBcInNjcmlwdFwiLCBcInR3aXR0ZXItd2pzXCIpKTtcblxubGV0IGNzcmZUb2tlbiA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCJtZXRhW25hbWU9J2NzcmYtdG9rZW4nXVwiKS5nZXRBdHRyaWJ1dGUoXCJjb250ZW50XCIpXG5cbmxldCBIb29rcyA9IHt9XG5Ib29rcy5SZWxvYWRUd2VldHMgPSB7XG4gIHVwZGF0ZWQoKSB7XG4gICAgY29uc29sZS5sb2coJ3JlbG9hZCcpXG4gICAgdHd0dHIud2lkZ2V0cy5sb2FkKClcbiAgfVxufVxuXG5sZXQgbGl2ZVNvY2tldCA9IG5ldyBMaXZlU29ja2V0KFwiL2xpdmVcIiwgU29ja2V0LCB7cGFyYW1zOiB7X2NzcmZfdG9rZW46IGNzcmZUb2tlbn0sIGhvb2tzOiBIb29rc30pXG5cbi8vIFNob3cgcHJvZ3Jlc3MgYmFyIG9uIGxpdmUgbmF2aWdhdGlvbiBhbmQgZm9ybSBzdWJtaXRzXG50b3BiYXIuY29uZmlnKHtiYXJDb2xvcnM6IHswOiBcIiMyOWRcIn0sIHNoYWRvd0NvbG9yOiBcInJnYmEoMCwgMCwgMCwgLjMpXCJ9KVxud2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJwaHg6cGFnZS1sb2FkaW5nLXN0YXJ0XCIsIGluZm8gPT4gdG9wYmFyLnNob3coKSlcbndpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwicGh4OnBhZ2UtbG9hZGluZy1zdG9wXCIsIGluZm8gPT4gdG9wYmFyLmhpZGUoKSlcblxuLy8gY29ubmVjdCBpZiB0aGVyZSBhcmUgYW55IExpdmVWaWV3cyBvbiB0aGUgcGFnZVxubGl2ZVNvY2tldC5jb25uZWN0KClcblxuLy8gZXhwb3NlIGxpdmVTb2NrZXQgb24gd2luZG93IGZvciB3ZWIgY29uc29sZSBkZWJ1ZyBsb2dzIGFuZCBsYXRlbmN5IHNpbXVsYXRpb246XG4vLyA+PiBsaXZlU29ja2V0LmVuYWJsZURlYnVnKClcbi8vID4+IGxpdmVTb2NrZXQuZW5hYmxlTGF0ZW5jeVNpbSgxMDAwKSAgLy8gZW5hYmxlZCBmb3IgZHVyYXRpb24gb2YgYnJvd3NlciBzZXNzaW9uXG4vLyA+PiBsaXZlU29ja2V0LmRpc2FibGVMYXRlbmN5U2ltKClcbndpbmRvdy5saXZlU29ja2V0ID0gbGl2ZVNvY2tldFxuXG4vLyBmdW5jdGlvbiBoaWRlQmFubmVyTG9hZGluZyhldmVudCkge1xuLy8gICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImxvYWRpbmdcIikuc3R5bGUudmlzaWJpbGl0eSA9IFwiaGlkZGVuXCJcbi8vIH1cbi8vIFxuLy8gdHd0dHIucmVhZHkoZnVuY3Rpb24gKHR3dHRyKSB7XG4vLyAgIHR3dHRyLmV2ZW50cy5iaW5kKCdyZW5kZXJlZCcsIGhpZGVCYW5uZXJMb2FkaW5nKTtcbi8vIH0pO1xuXG5cblxuXG5cblxuXG5cbndpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwicGh4OnBhZ2UtbG9hZGluZy1zdG9wXCIsIGluZm8gPT4ge1xuICBjb25zb2xlLmxvZygnc3RvcCcpXG5cbn0pXG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQU9BO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBRUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFFQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVFBO0FBQ0E7QUFFQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./js/app.js\n");

/***/ }),

/***/ "./node_modules/topbar/topbar.js":
/*!***************************************!*\
  !*** ./node_modules/topbar/topbar.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_RESULT__;/*! topbar 0.1.4, 2020-04-27\n *  http://buunguyen.github.io/topbar\n *  Copyright (c) 2019 Buu Nguyen\n *  Licensed under the MIT License */\n;(function(window, document) {\n    'use strict'\n\n    // https://gist.github.com/paulirish/1579671\n    ;(function() {\n        var lastTime = 0;\n        var vendors = ['ms', 'moz', 'webkit', 'o'];\n        for(var x = 0; x < vendors.length && !window.requestAnimationFrame; ++x) {\n            window.requestAnimationFrame = window[vendors[x]+'RequestAnimationFrame'];\n            window.cancelAnimationFrame = window[vendors[x]+'CancelAnimationFrame']\n                || window[vendors[x]+'CancelRequestAnimationFrame'];\n        }\n        if (!window.requestAnimationFrame)\n            window.requestAnimationFrame = function(callback, element) {\n                var currTime = new Date().getTime();\n                var timeToCall = Math.max(0, 16 - (currTime - lastTime));\n                var id = window.setTimeout(function() { callback(currTime + timeToCall); },\n                    timeToCall);\n                lastTime = currTime + timeToCall;\n                return id;\n            };\n        if (!window.cancelAnimationFrame)\n            window.cancelAnimationFrame = function(id) {\n                clearTimeout(id);\n            };\n    }());\n\n    var canvas, progressTimerId, fadeTimerId, currentProgress, showing,\n        addEvent = function(elem, type, handler) {\n            if (elem.addEventListener) elem.addEventListener(type, handler, false)\n            else if (elem.attachEvent) elem.attachEvent('on' + type, handler)\n            else                       elem['on' + type] = handler\n        },\n        options = {\n            autoRun      : true,\n            barThickness : 3,\n            barColors    : {\n                '0'      : 'rgba(26,  188, 156, .9)',\n                '.25'    : 'rgba(52,  152, 219, .9)',\n                '.50'    : 'rgba(241, 196, 15,  .9)',\n                '.75'    : 'rgba(230, 126, 34,  .9)',\n                '1.0'    : 'rgba(211, 84,  0,   .9)'\n            },\n            shadowBlur   : 10,\n            shadowColor  : 'rgba(0,   0,   0,   .6)',\n            className    : null,\n        },\n        repaint = function() {\n            canvas.width = window.innerWidth\n            canvas.height = options.barThickness * 5 // need space for shadow\n\n            var ctx = canvas.getContext('2d')\n            ctx.shadowBlur = options.shadowBlur\n            ctx.shadowColor = options.shadowColor\n\n            var lineGradient = ctx.createLinearGradient(0, 0, canvas.width, 0)\n            for (var stop in options.barColors)\n                lineGradient.addColorStop(stop, options.barColors[stop])\n            ctx.lineWidth = options.barThickness\n            ctx.beginPath()\n            ctx.moveTo(0, options.barThickness/2)\n            ctx.lineTo(Math.ceil(currentProgress * canvas.width), options.barThickness/2)\n            ctx.strokeStyle = lineGradient\n            ctx.stroke()\n        },\n        createCanvas = function() {\n            canvas = document.createElement('canvas')\n            var style = canvas.style\n            style.position = 'fixed'\n            style.top = style.left = style.right = style.margin = style.padding = 0\n            style.zIndex = 100001\n            style.display = 'none'\n            if (options.className)\n                canvas.classList.add(options.className)\n            document.body.appendChild(canvas)\n            addEvent(window, 'resize', repaint)\n        },\n        topbar = {\n            config: function(opts) {\n                for (var key in opts)\n                    if (options.hasOwnProperty(key))\n                        options[key] = opts[key]\n            },\n            show: function() {\n                if (showing) return\n                showing = true\n                if (fadeTimerId !== null)\n                    window.cancelAnimationFrame(fadeTimerId)\n                if (!canvas) createCanvas()\n                canvas.style.opacity = 1\n                canvas.style.display = 'block'\n                topbar.progress(0)\n                if (options.autoRun) {\n                    (function loop() {\n                        progressTimerId = window.requestAnimationFrame(loop)\n                        topbar.progress('+' + (.05 * Math.pow(1-Math.sqrt(currentProgress), 2)))\n                    })()\n                }\n            },\n            progress: function(to) {\n                if (typeof to === \"undefined\")\n                    return currentProgress\n                if (typeof to === \"string\") {\n                    to = (to.indexOf('+') >= 0 || to.indexOf('-') >= 0 ? currentProgress : 0) + parseFloat(to)\n                }\n                currentProgress = to > 1 ? 1 : to\n                repaint()\n                return currentProgress\n            },\n            hide: function() {\n                if (!showing) return\n                showing = false\n                if (progressTimerId != null) {\n                    window.cancelAnimationFrame(progressTimerId)\n                    progressTimerId = null\n                }\n                (function loop() {\n                    if (topbar.progress('+.1') >= 1) {\n                        canvas.style.opacity -= .05\n                        if (canvas.style.opacity <= .05) {\n                            canvas.style.display = 'none'\n                            fadeTimerId = null\n                            return\n                        }\n                    }\n                    fadeTimerId = window.requestAnimationFrame(loop)\n                })()\n            }\n        }\n\n    if ( true && typeof module.exports === 'object') {\n        module.exports = topbar\n    } else if (true) {\n        !(__WEBPACK_AMD_DEFINE_RESULT__ = (function() { return topbar }).call(exports, __webpack_require__, exports, module),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))\n    } else {}\n}).call(this, window, document)\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdG9wYmFyL3RvcGJhci5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy90b3BiYXIvdG9wYmFyLmpzP2U5ZjAiXSwic291cmNlc0NvbnRlbnQiOlsiLyohIHRvcGJhciAwLjEuNCwgMjAyMC0wNC0yN1xuICogIGh0dHA6Ly9idXVuZ3V5ZW4uZ2l0aHViLmlvL3RvcGJhclxuICogIENvcHlyaWdodCAoYykgMjAxOSBCdXUgTmd1eWVuXG4gKiAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlICovXG47KGZ1bmN0aW9uKHdpbmRvdywgZG9jdW1lbnQpIHtcbiAgICAndXNlIHN0cmljdCdcblxuICAgIC8vIGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL3BhdWxpcmlzaC8xNTc5NjcxXG4gICAgOyhmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGxhc3RUaW1lID0gMDtcbiAgICAgICAgdmFyIHZlbmRvcnMgPSBbJ21zJywgJ21veicsICd3ZWJraXQnLCAnbyddO1xuICAgICAgICBmb3IodmFyIHggPSAwOyB4IDwgdmVuZG9ycy5sZW5ndGggJiYgIXdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWU7ICsreCkge1xuICAgICAgICAgICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSA9IHdpbmRvd1t2ZW5kb3JzW3hdKydSZXF1ZXN0QW5pbWF0aW9uRnJhbWUnXTtcbiAgICAgICAgICAgIHdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZSA9IHdpbmRvd1t2ZW5kb3JzW3hdKydDYW5jZWxBbmltYXRpb25GcmFtZSddXG4gICAgICAgICAgICAgICAgfHwgd2luZG93W3ZlbmRvcnNbeF0rJ0NhbmNlbFJlcXVlc3RBbmltYXRpb25GcmFtZSddO1xuICAgICAgICB9XG4gICAgICAgIGlmICghd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSlcbiAgICAgICAgICAgIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPSBmdW5jdGlvbihjYWxsYmFjaywgZWxlbWVudCkge1xuICAgICAgICAgICAgICAgIHZhciBjdXJyVGltZSA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICAgICAgICAgICAgICAgIHZhciB0aW1lVG9DYWxsID0gTWF0aC5tYXgoMCwgMTYgLSAoY3VyclRpbWUgLSBsYXN0VGltZSkpO1xuICAgICAgICAgICAgICAgIHZhciBpZCA9IHdpbmRvdy5zZXRUaW1lb3V0KGZ1bmN0aW9uKCkgeyBjYWxsYmFjayhjdXJyVGltZSArIHRpbWVUb0NhbGwpOyB9LFxuICAgICAgICAgICAgICAgICAgICB0aW1lVG9DYWxsKTtcbiAgICAgICAgICAgICAgICBsYXN0VGltZSA9IGN1cnJUaW1lICsgdGltZVRvQ2FsbDtcbiAgICAgICAgICAgICAgICByZXR1cm4gaWQ7XG4gICAgICAgICAgICB9O1xuICAgICAgICBpZiAoIXdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZSlcbiAgICAgICAgICAgIHdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZSA9IGZ1bmN0aW9uKGlkKSB7XG4gICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KGlkKTtcbiAgICAgICAgICAgIH07XG4gICAgfSgpKTtcblxuICAgIHZhciBjYW52YXMsIHByb2dyZXNzVGltZXJJZCwgZmFkZVRpbWVySWQsIGN1cnJlbnRQcm9ncmVzcywgc2hvd2luZyxcbiAgICAgICAgYWRkRXZlbnQgPSBmdW5jdGlvbihlbGVtLCB0eXBlLCBoYW5kbGVyKSB7XG4gICAgICAgICAgICBpZiAoZWxlbS5hZGRFdmVudExpc3RlbmVyKSBlbGVtLmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgaGFuZGxlciwgZmFsc2UpXG4gICAgICAgICAgICBlbHNlIGlmIChlbGVtLmF0dGFjaEV2ZW50KSBlbGVtLmF0dGFjaEV2ZW50KCdvbicgKyB0eXBlLCBoYW5kbGVyKVxuICAgICAgICAgICAgZWxzZSAgICAgICAgICAgICAgICAgICAgICAgZWxlbVsnb24nICsgdHlwZV0gPSBoYW5kbGVyXG4gICAgICAgIH0sXG4gICAgICAgIG9wdGlvbnMgPSB7XG4gICAgICAgICAgICBhdXRvUnVuICAgICAgOiB0cnVlLFxuICAgICAgICAgICAgYmFyVGhpY2tuZXNzIDogMyxcbiAgICAgICAgICAgIGJhckNvbG9ycyAgICA6IHtcbiAgICAgICAgICAgICAgICAnMCcgICAgICA6ICdyZ2JhKDI2LCAgMTg4LCAxNTYsIC45KScsXG4gICAgICAgICAgICAgICAgJy4yNScgICAgOiAncmdiYSg1MiwgIDE1MiwgMjE5LCAuOSknLFxuICAgICAgICAgICAgICAgICcuNTAnICAgIDogJ3JnYmEoMjQxLCAxOTYsIDE1LCAgLjkpJyxcbiAgICAgICAgICAgICAgICAnLjc1JyAgICA6ICdyZ2JhKDIzMCwgMTI2LCAzNCwgIC45KScsXG4gICAgICAgICAgICAgICAgJzEuMCcgICAgOiAncmdiYSgyMTEsIDg0LCAgMCwgICAuOSknXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2hhZG93Qmx1ciAgIDogMTAsXG4gICAgICAgICAgICBzaGFkb3dDb2xvciAgOiAncmdiYSgwLCAgIDAsICAgMCwgICAuNiknLFxuICAgICAgICAgICAgY2xhc3NOYW1lICAgIDogbnVsbCxcbiAgICAgICAgfSxcbiAgICAgICAgcmVwYWludCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgY2FudmFzLndpZHRoID0gd2luZG93LmlubmVyV2lkdGhcbiAgICAgICAgICAgIGNhbnZhcy5oZWlnaHQgPSBvcHRpb25zLmJhclRoaWNrbmVzcyAqIDUgLy8gbmVlZCBzcGFjZSBmb3Igc2hhZG93XG5cbiAgICAgICAgICAgIHZhciBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKVxuICAgICAgICAgICAgY3R4LnNoYWRvd0JsdXIgPSBvcHRpb25zLnNoYWRvd0JsdXJcbiAgICAgICAgICAgIGN0eC5zaGFkb3dDb2xvciA9IG9wdGlvbnMuc2hhZG93Q29sb3JcblxuICAgICAgICAgICAgdmFyIGxpbmVHcmFkaWVudCA9IGN0eC5jcmVhdGVMaW5lYXJHcmFkaWVudCgwLCAwLCBjYW52YXMud2lkdGgsIDApXG4gICAgICAgICAgICBmb3IgKHZhciBzdG9wIGluIG9wdGlvbnMuYmFyQ29sb3JzKVxuICAgICAgICAgICAgICAgIGxpbmVHcmFkaWVudC5hZGRDb2xvclN0b3Aoc3RvcCwgb3B0aW9ucy5iYXJDb2xvcnNbc3RvcF0pXG4gICAgICAgICAgICBjdHgubGluZVdpZHRoID0gb3B0aW9ucy5iYXJUaGlja25lc3NcbiAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKVxuICAgICAgICAgICAgY3R4Lm1vdmVUbygwLCBvcHRpb25zLmJhclRoaWNrbmVzcy8yKVxuICAgICAgICAgICAgY3R4LmxpbmVUbyhNYXRoLmNlaWwoY3VycmVudFByb2dyZXNzICogY2FudmFzLndpZHRoKSwgb3B0aW9ucy5iYXJUaGlja25lc3MvMilcbiAgICAgICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IGxpbmVHcmFkaWVudFxuICAgICAgICAgICAgY3R4LnN0cm9rZSgpXG4gICAgICAgIH0sXG4gICAgICAgIGNyZWF0ZUNhbnZhcyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJylcbiAgICAgICAgICAgIHZhciBzdHlsZSA9IGNhbnZhcy5zdHlsZVxuICAgICAgICAgICAgc3R5bGUucG9zaXRpb24gPSAnZml4ZWQnXG4gICAgICAgICAgICBzdHlsZS50b3AgPSBzdHlsZS5sZWZ0ID0gc3R5bGUucmlnaHQgPSBzdHlsZS5tYXJnaW4gPSBzdHlsZS5wYWRkaW5nID0gMFxuICAgICAgICAgICAgc3R5bGUuekluZGV4ID0gMTAwMDAxXG4gICAgICAgICAgICBzdHlsZS5kaXNwbGF5ID0gJ25vbmUnXG4gICAgICAgICAgICBpZiAob3B0aW9ucy5jbGFzc05hbWUpXG4gICAgICAgICAgICAgICAgY2FudmFzLmNsYXNzTGlzdC5hZGQob3B0aW9ucy5jbGFzc05hbWUpXG4gICAgICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGNhbnZhcylcbiAgICAgICAgICAgIGFkZEV2ZW50KHdpbmRvdywgJ3Jlc2l6ZScsIHJlcGFpbnQpXG4gICAgICAgIH0sXG4gICAgICAgIHRvcGJhciA9IHtcbiAgICAgICAgICAgIGNvbmZpZzogZnVuY3Rpb24ob3B0cykge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiBvcHRzKVxuICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5oYXNPd25Qcm9wZXJ0eShrZXkpKVxuICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9uc1trZXldID0gb3B0c1trZXldXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2hvdzogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNob3dpbmcpIHJldHVyblxuICAgICAgICAgICAgICAgIHNob3dpbmcgPSB0cnVlXG4gICAgICAgICAgICAgICAgaWYgKGZhZGVUaW1lcklkICE9PSBudWxsKVxuICAgICAgICAgICAgICAgICAgICB3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWUoZmFkZVRpbWVySWQpXG4gICAgICAgICAgICAgICAgaWYgKCFjYW52YXMpIGNyZWF0ZUNhbnZhcygpXG4gICAgICAgICAgICAgICAgY2FudmFzLnN0eWxlLm9wYWNpdHkgPSAxXG4gICAgICAgICAgICAgICAgY2FudmFzLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snXG4gICAgICAgICAgICAgICAgdG9wYmFyLnByb2dyZXNzKDApXG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuYXV0b1J1bikge1xuICAgICAgICAgICAgICAgICAgICAoZnVuY3Rpb24gbG9vcCgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb2dyZXNzVGltZXJJZCA9IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUobG9vcClcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvcGJhci5wcm9ncmVzcygnKycgKyAoLjA1ICogTWF0aC5wb3coMS1NYXRoLnNxcnQoY3VycmVudFByb2dyZXNzKSwgMikpKVxuICAgICAgICAgICAgICAgICAgICB9KSgpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHByb2dyZXNzOiBmdW5jdGlvbih0bykge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdG8gPT09IFwidW5kZWZpbmVkXCIpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjdXJyZW50UHJvZ3Jlc3NcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHRvID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIHRvID0gKHRvLmluZGV4T2YoJysnKSA+PSAwIHx8IHRvLmluZGV4T2YoJy0nKSA+PSAwID8gY3VycmVudFByb2dyZXNzIDogMCkgKyBwYXJzZUZsb2F0KHRvKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjdXJyZW50UHJvZ3Jlc3MgPSB0byA+IDEgPyAxIDogdG9cbiAgICAgICAgICAgICAgICByZXBhaW50KClcbiAgICAgICAgICAgICAgICByZXR1cm4gY3VycmVudFByb2dyZXNzXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaGlkZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFzaG93aW5nKSByZXR1cm5cbiAgICAgICAgICAgICAgICBzaG93aW5nID0gZmFsc2VcbiAgICAgICAgICAgICAgICBpZiAocHJvZ3Jlc3NUaW1lcklkICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgd2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lKHByb2dyZXNzVGltZXJJZClcbiAgICAgICAgICAgICAgICAgICAgcHJvZ3Jlc3NUaW1lcklkID0gbnVsbFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAoZnVuY3Rpb24gbG9vcCgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRvcGJhci5wcm9ncmVzcygnKy4xJykgPj0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FudmFzLnN0eWxlLm9wYWNpdHkgLT0gLjA1XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2FudmFzLnN0eWxlLm9wYWNpdHkgPD0gLjA1KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FudmFzLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmYWRlVGltZXJJZCA9IG51bGxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBmYWRlVGltZXJJZCA9IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUobG9vcClcbiAgICAgICAgICAgICAgICB9KSgpXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgIGlmICh0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlLmV4cG9ydHMgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIG1vZHVsZS5leHBvcnRzID0gdG9wYmFyXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcbiAgICAgICAgZGVmaW5lKGZ1bmN0aW9uKCkgeyByZXR1cm4gdG9wYmFyIH0pXG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy50b3BiYXIgPSB0b3BiYXJcbiAgICB9XG59KS5jYWxsKHRoaXMsIHdpbmRvdywgZG9jdW1lbnQpXG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0EsYUFFQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/topbar/topbar.js\n");

/***/ }),

/***/ 0:
/*!*************************!*\
  !*** multi ./js/app.js ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(/*! ./js/app.js */"./js/app.js");


/***/ })

/******/ });